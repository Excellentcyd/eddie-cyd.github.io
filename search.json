[{"title":"1.和小达一起学HTML","url":"/2022/08/11/1.%E5%92%8C%E5%B0%8F%E8%BE%BE%E4%B8%80%E8%B5%B7%E5%AD%A6HTML/","content":"⭐HTML1.基础认知HTML(Hyper Text Markup Language):超文本标记语言\nWeb标准：在不同的浏览器按照相同的标准显示效果，展示统一。包括以下三部分\n\n\n\n构成\n语言\n说明\n\n\n\n结构\nHTML\n页面元素和内容\n\n\n表现\nCSS\n网页元素的外观和位置等页面样式（颜色、大小等）\n\n\n行为\nJavaScript\n页面交互效果\n\n\n2.常用标签2.1基础标签1.排版标签\n\n\n标签\n作用\n\n\n\nh1-h5\n标题\n\n\np\n段落\n\n\nbr\n换行\n\n\nhr\n分割线\n\n\ndiv&#x2F;span\n没有语义\n\n\n2.文本格式标签\n\n\n标签\n作用\n\n\n\nb&#x2F;strong\n加粗\n\n\nu&#x2F;ins\n下划线\n\n\ni&#x2F;em\n倾斜\n\n\ns&#x2F;del\n删除线\n\n\n3.图片标签&lt;img src=&quot;路径&quot; alt=&quot;加载失败的替换文本&quot; title=&quot;悬停显示文本&quot; &gt;\n4.音频标签&lt;audio src=&quot;路径&quot; controls autoplay loop&gt;&lt;/audio&gt;\n\n\n\n属性\n作用\n\n\n\ncontrols\n控件界面\n\n\n&lt;video&gt; 标签内的内容\n后备内容 — 当浏览器不支持 &lt;video&gt; 标签的时候，就会显示这段内容\n\n\nautoplay\n音频和视频内容立即播放\n\n\nloop\n让音频或者视频文件循环播放\n\n\nmuted\n媒体播放时，默认关闭声音\n\n\nposter\n指向了一个图像的URL，这个图像会在视频播放前显示。通常用于粗略的预览或者广告\n\n\npreload\n用来缓冲较大的文件，有3个值可选：”none” ：不缓冲；”auto” ：页面加载后缓存媒体文件；”metadata” ：仅缓冲文件的元数据\n\n\n5.视频标签&lt;video src=&quot;路径&quot; controls autoplay loop&gt;&lt;/video&gt;\n6.超链接标签&lt;a href=&quot;https://www.baidu.com/&quot; target=&quot;_blank&quot;&gt;跳转到百度&lt;/a&gt;&lt;!--  _blank:新窗口打开   _self:当前窗口打开  --&gt;\n\n绝对超链接：链接到网络上（非本站）的网页链接\n相对超链接：链接到本网站内的一个网页链接\n锚点超链接（书签）：链接到本页面特定位置（文字，段落，标题等）的链接\n\n\n\n\n属性\n作用\n注意\n\n\n\nhref\n超链接的\n#代表本页面\n\n\nname\n锚点的名称\n用 #+锚点名称 跳转到锚点\n\n\ntarget\n重定向打开方式\n\n\n\n2.2.列表、表格、表单标签1.列表标签&lt;!--无序列表--&gt;&lt;!-- ul标签：表示无序列表的整体，只允许嵌套li标签；li标签：表示无序列表的每一项，可以嵌套任意内容--&gt; &lt;ul&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!--有序列表--&gt;&lt;!-- 列表的每一项前默认显示序号标识--&gt;&lt;!-- ol标签：表示无序列表的整体，只允许嵌套li标签；li标签：表示无序列表的每一项，可以嵌套任意内容--&gt;&lt;ol&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;&lt;/ol&gt;&lt;!--自定义列表--&gt;&lt;!--dl标签：自定义列表的整体;dt标签：自定义列表的主题;dd标签：主题的每一项内容--&gt;&lt;dl&gt;        &lt;dt&gt;&lt;/dt&gt;        &lt;dd&gt;&lt;/dd&gt;        &lt;dd&gt;&lt;/dd&gt;&lt;/dl&gt;\n2.表格标签&lt;table&gt;    &lt;caption&gt;表格大标题&lt;/caption&gt;    &lt;tr&gt;        &lt;th&gt;表头单元格默认加粗居中&lt;/th&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;表格内容&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;\n列表属性\n\n\n\n属性值\n作用\n\n\n\n1，I，i，A，a (il)\n有序列表样式\n\n\ndisc\n实心圆点\n\n\ncircle\n空心圆点\n\n\nsquare\n实心方形\n\n\n​\t合并单元格：给保留的单元格设置跨行合并(rowspan)跨列合并(colspan)\n\n\n\n3.表单标签​\t\t3.1 input系列标签\n&lt;input type=&quot;text&quot;&gt;\n\n\n\ntype属性内容\n作用\n\n\n\ntext\n文本框\n\n\npassword\n密码框\n\n\nradio\n单选框\n\n\ncheckbox\n多选框\n\n\nfile\n文件选择\n\n\nsubmit\n提交按钮\n\n\nreset\n重置按钮\n\n\nbutton\n按钮\n\n\n​\t\t3.2 select下拉菜单标签\n\n\n\n&lt;select&gt;    &lt;option&gt;北京&lt;/option&gt;    &lt;option&gt;上海&lt;/option&gt;    &lt;option&gt;广州&lt;/option&gt;    &lt;option selected&gt;深圳&lt;/option&gt;&lt;/select&gt;&lt;!--selected  默认选择--&gt;\n​\t\t3.3 textarea文本域标签\n&lt;textarea&gt;&lt;/textarea&gt;\n2.3语义化标签\n\n\n标签\n作用\n\n\n\nheader\n网页头部\n\n\nnav\n网页导航\n\n\nfooter\n网页尾部\n\n\naside\n网页侧边栏\n\n\nsection\n网页区块\n\n\narticle\n网页文章\n\n\n3.head标签内含标签包括：\n\n\n\n标签\n作用\n\n\n\nmeta\n网页介绍，关键字，网页编码，作者，自动跳转定义等\n\n\nbase\n定义html网页默认打开方式\n\n\nlink\n目标文件链接（css,js,favicon.ico等)\n\n\nscript\n引入或嵌入js代码\n\n\nstyle\n嵌入网页的css代码\n\n\ntitle\n网页唯一标题\n\n\nmeta\n//http-equiv:http协议文件头&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html&quot; charset=&quot;utf-8&quot; &gt;//字符集&lt;meta http-equiv=&quot;Content-Language&quot; content=&quot;en&quot; &gt;//页面语言&lt;meta http-equiv=&quot;refresh&quot; content=&quot;1;url=http://www.baidu.com&quot; /&gt;//重定向&lt;meta name=&quot;author&quot; content=&quot;king&quot;&gt;&lt;meta name=&quot;revised&quot; content=&quot;king,01/15/2017&quot;&gt;&lt;meta name=&quot;generator&quot; content=&quot;Sublime Text3&quot;&gt;&lt;meta name=&quot;description&quot; content=&quot;HTML5文档head标签元素使用&quot;&gt;&lt;meta name=&quot;keywords&quot; content=&quot;HTML5, CSS, JavaScript&quot;&gt;\n\n\n\n\nhttp-equiv属性\n描述\n使用方法\n功能\n\n\n\nContent-Type\n字符集\n&lt;meta http-equiv=&quot;Content-Language&quot; content=&quot;en&quot; &gt;\n\n\n\nContent-Language\n页面语言\n&lt;meta http-equiv=&quot;Content-Language&quot; content=&quot;en&quot; &gt;\n\n\n\nrefresh\n重定向\n&lt;meta http-equiv=&quot;refresh&quot; content=&quot;1;url=http://www.baidu.com&quot; /&gt;\n\n\n\nexpires\n期限\n&lt;meta http-equiv=&quot;expires&quot; content=&quot;GMT格式时间&quot; /&gt;\n设定网页过期时间\n\n\npragma\ncache模式\n&lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cashe&quot; /&gt;\n禁止浏览器从本地计算机的缓存中访问网页\n\n\nSet-Cookie\ncookie过期设定\n&lt;meta http-equiv=&quot;Set-Cookie&quot; content=&quot;cookie-value=xxx;expires=GMT格式时间；path&quot; /&gt;\n如果网页过期，保存在本机的全部cookie自动删除\n\n\nWindow-target\n显示窗口的设定\n&lt;meta http-equiv=&quot;Window-target&quot; content=&quot;GMT 格式时间&quot; /&gt;\n强制在当前窗口以独立页面方式显示（防止外部页面在框架里调用本页面）\n\n\nlink\n&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/style.css&quot; &gt;\n\nstyle\n&lt;style type=&quot;text/css&quot;&gt;\th1 &#123;font: bold 20px/2.0em arial,verdana;&#125;&lt;/style&gt;\n\nscript\n&lt;script type=&quot;text/javascript&quot;&gt;\tdocument.write(&quot;&lt;h1&gt;HTML5 + CSS + JS --- head标签&lt;/h1&gt;&quot;);&lt;/script&gt;\n\ntitle\n&lt;title&gt;HTML 5 之网页标题&lt;/title&gt;\n\nbase\n页面上的所有链接规定的默认地址\n\n前面的base标签会覆盖后面的标签\n\n&lt;base href=&quot;./url/&quot; target=&quot;_blank&quot; /&gt;\n\n\n\n\ntarget属性值\n作用\n\n\n\n_blank\n在新的窗口打开链接\n\n\n_self（默认值）\n自身窗口\n\n\n_parent\n父窗口或超链接引用框架的框架集中打开\n\n\n_top\n清除所有被包含的框架并将文档载入整个浏览器窗口\n\n\n块级元素 &amp; 内联元素 &amp; 空元素\n块级元素在页面中以块的形式展现 —— 相对于其前面的内容它会出现在新的一行，其后的内容也会被挤到下一行展现。块级元素通常用于展示页面上结构化的内容，例如段落、列表、导航菜单、页脚等等。一个以block形式展现的块级元素不会被嵌套进内联元素中，但可以嵌套在其它块级元素中。\n\n内联元素通常出现在块级元素中并环绕文档内容的一小部分，而不是一整个段落或者一组内容。内联元素不会导致文本换行：它通常出现在一堆文字之间例如超链接元素&lt;a&gt;或者强调元素&lt;em&gt;和&lt;strong&gt;。\n\n不是所有元素都拥有开始标签，内容，结束标签。一些元素只有一个标签，通常用来在此元素所在位置插入&#x2F;嵌入一些东西。例如：元素&lt;img&gt;是用来在元素&lt;img&gt;所在位置插入一张指定的图片。\n\n\n嵌入 iframe&lt;iframe&gt;元素旨在允许您将其他Web文档嵌入到当前文档中\n&lt;iframe src=&quot;https://developer.mozilla.org/en-US/docs/Glossary&quot;        width=&quot;100%&quot; height=&quot;500&quot; frameborder=&quot;0&quot;        allowfullscreen sandbox&gt;  &lt;p&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary&quot;&gt;    Fallback link for browsers that don&#x27;t support iframes  &lt;/a&gt; &lt;/p&gt;&lt;/iframe&gt;\n\nSVG在网上，你会和两种类型的图片打交道 — 位图和矢量图:\n\n位图使用像素网格来定义 — 一个位图文件精确得包含了每个像素的位置和它的色彩信息。流行的位图格式包括 Bitmap (.bmp), PNG (.png), JPEG (.jpg), and GIF (.gif.)\n矢量图使用算法来定义 — 一个矢量图文件包含了图形和路径的定义，电脑可以根据这些定义计算出当它们在屏幕上渲染时应该呈现的样子。 SVG 格式可以让我们创造用于 Web 的精彩的矢量图形。无论它的尺寸如何，都使用算法来计算出图像的形状，仅仅是根据放大的倍数来调整算法中的值。\n\nSVG 是用于描述矢量图像的XML语言。 它基本上是像HTML一样的标记，只是你有许多不同的元素来定义要显示在图像中的形状，以及要应用于这些形状的效果。 SVG用于标记图形，而不是内容。\n&lt;svg version=&quot;1.1&quot;     baseProfile=&quot;full&quot;     width=&quot;300&quot; height=&quot;200&quot;     xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;  &lt;rect width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;black&quot; /&gt;  &lt;circle cx=&quot;150&quot; cy=&quot;100&quot; r=&quot;90&quot; fill=&quot;blue&quot; /&gt;&lt;/svg&gt;\n","categories":["前端"],"tags":["HTML"]},{"title":"10.和小达一起学MySQL","url":"/2022/08/11/10.%E5%92%8C%E5%B0%8F%E8%BE%BE%E4%B8%80%E8%B5%B7%E5%AD%A6MySQL/","content":"1.数据库的基本概念1.1数据库的基本概念1.1.1什么是数据库​\t数据库是用来组织、存储、管理数据的仓库\n​\t为了方便管理数据，就有了数据库管理系统的概念(简称：数据库)。用户可以对数据库中的数据进行新增、查询、更新、删除等操作\n1.1.2常见的数据库和分类\nMySQL数据库（目前使用最广泛、流行度最高的开源免费数据库；Community + Enterprise） \nOracle 数据库（收费）\nSQL Server 数据库（收费）\nMongodb 数据库（Community + Enterprise）\n\n传统型数据库（关系型数据库 or SQL数据库）：MySQL、Oracle、SQL Server，这三者设计理念相同，用法类似\n新型数据库（非关系型数据库 or NoSQL数据库）：Mongodb，它在一定程度上弥补了传统型数据库的缺陷\n1.1.3传统型数据库的组织结构Excel，每个 Excel 中，数据的组织结构分别为工作簿、工作表、数据行、列这 4 大部分组成。\n\n\n整个 Excel 叫做工作簿\nusers 和 books 是工作表\nusers 工作表中有 3 行数据，每行数据由 6 列信息组成\n每列信息都有对应的数据类型\n\n传统型数据库，数据的组织结构分为**数据库(database)、数据表(table)、数据行(row)、字段(field)**这 4 大部分组成。\n\n数据库类似于 Excel 的工作簿\n数据表类似于 Excel 的工作表\n数据行类似于 Excel 的每一行数据\n字段类似于 Excel 的列，每个字段都有对应的数据类型\n\n实际开发中库、表、行、字段的关系\n\n在实际项目开发中，一般情况下，每个项目都对应独立的数据库。\n不同的数据，要存储到数据库的不同表中，例如：用户数据存储到 users 表中，图书数据存储到 books 表中\n每个表中具体存储哪些信息，由字段来决定，例如：我们可以为 users 表设计 id、username、password 这 3 个 字段\n表中的行，代表每一条具体的数据。\n\n2.MySQL的基本使用2.1使用MySQL Workbench管理数据库2.1.1连接数据库\n2.1.2界面组成部分\n2.1.3创建数据库\n2.1.4创建数据表\nDataType数据类型：\n\nINT整数\nvarchar(len) 字符串\n**tinyint(1) **布尔值\n\n字段的特殊标识：\n\nPK（Primary Key）主键、唯一标识\nNN（Not Null）值不允许为空\nUQ（Unique）值唯一\nAI（Auto Increment）值自动增长\n\n2.1.5向表中写入数据\n2.2使用SQL管理数据2.2.1什么是SQLSQL（Structured Query Language）是结构化查询语言，专门用来访问和处理数据库的编程语言。能够让 \n我们以编程的形式，操作数据库里面的数据。\n\nSQL 是一门数据库编程语言\n使用 SQL 语言编写出来的代码，叫做 SQL 语句\nSQL 语言只能在关系型数据库中使用（例如 MySQL、Oracle、SQL Server）。非关系型数据库（例如 Mongodb） 不支持 SQL 语言\n\n2.2.2SQL可以做什么\n从数据库中查询数据\n向数据库中插入新的数据\n更新数据库中的数据\n从数据库删除数据\n可以创建新数据库\n可在数据库中创建新表\n可在数据库中创建存储过程、视图\n…\n\n2.2.3查询 - SELECT语句​\tSELECT语句用于从表中查询数据，执行的结果被存储在结果表中\n-- 这是注释-- 从 FROM 指定的表中，查询出所有的数据。-- *号表示所有列SELECT * FROM 表名称-- 从 FROM 指定的表中，查询出指定 列名称（字段）的数据SELECT 列名称 FROM 表名称\n\n​\t注： SQL语句中的关键字对大小写不敏感。SELECT 等效于 select，FROM 等效于 from\nselect * from usersselect username from usersselect username,password from users\n\n2.2.4插入 - INSERT INTO​\tINSERT INTO 语句用于向数据表中插入新的数据行\n-- 语法：向指定的表中，插入如下几列数据，列的值通过 VALUES 一一制定-- 注意：列和值要一一对应，多个列和多个值之间使用英文,分隔INSERT INTO 表名(列1，列2，...) VALUES (值1，值2，...)\n\ninsert into users(name,password) values(&#x27;bob&#x27;,&#x27;123456&#x27;)\n\n2.2.5更新 - UPDATE​\tUPDATE 语句用于修改表中的数据\n-- 1.用 UPDATE 指定要更新哪个表中的数据-- 2.用 SET 指定列对应的新值-- 3.用 WHERE 指定更新的条件UPDATE 表名称 SET 列名称=新值 WHERE 某列名=某值\n\nupdate users set password=&quot;8888&quot; where id=2-- 多个更新之间用英文的,进行分隔-- 一定记得加WHERE条件，否则整张表的数据都被更新update users set password=&#x27;8888&#x27;, status=1 where id=2\n\n2.2.6删除 - DELETE FROM​\tDELETE 语句用于删除表中的行\n-- 从 FROM 指定的表中，根据 WHERE 条件，删除对应的数据行DELETE FROM 表名称 WHERE 列名称=值\n\ndelete from user where id=1\n\n2.2.7 WHERE子句​\tWHERE 子句用于限定选择的标准。在 SELECT、UPDATE、DELETE 语句中，皆可使用 WHERE 子句来限定选择的标准。\nSELECT 列名 FROM 表名 WHERE 列 运算符 值UPDATE 表名 SET 列=新值 WHERE 列 运算符 值DELETE FROM 表名 WHERE 列 运算符 值\n\n​\t运算符可以为：&#x3D;、&gt;、&lt;、&gt;&#x3D;、&lt;&#x3D;、BETWEEN、LIKE、&lt;&gt;（不等于，有些SQL版本可以为 !&#x3D; ）\n2.2.8 AND和OR运算符​\tAND 和 OR 可在 WHERE 子语句中把两个或多个条件结合起来\n\nAND 表示必须同时满足多个条件，相当于 JavaScript 中的 &amp;&amp; 运算符，例如 if (a !&#x3D;&#x3D; 10 &amp;&amp; a !&#x3D;&#x3D; 20)\nOR 表示只要满足任意一个条件即可，相当于 JavaScript 中的 || 运算符，例如 if(a !&#x3D;&#x3D; 10 || a !&#x3D;&#x3D; 20)\n\n2.2.9 ORDER BY子句\nORDER BY 语句用于根据指定的列对结果集进行排序，默认升序，降序可以使用DESC关键字。\n\n-- 升序select * from users order by id-- 降序select * from users order by id desc-- 多重排序：先按照status降序，再按照name升序（asc语义性更明显）select * from users order by status desc,name asc\n\n2.2.10 COUNT(*)函数​\tCOUNT(*) 函数用于返回查询结果的总数据条数\nSELECT COUNT(*) FROM 表名称\n\n2.3在项目中操作MySQL2.3.1安装与配置//1.初始化包管理配置文件init -y //2.安装包的管理配置文件npm i install mysql//3.配置mysql模块//导入mysql模块const mysql = require(&#x27;mysql&#x27;)//建立与mysql数据库的连接const db = mysql.createPool(&#123;    host:&#x27;127.0.0.1&#x27;,//数据库的IP地址    user:&#x27;root&#x27;,//登录数据库的账号    password:&#x27;admin123&#x27;,//登录数据库的密码    database:&#x27;my_db_01&#x27;//指定要操作哪个数据库&#125;)//4.测试mysql模块是否能够正常工作db.query(&#x27;SELECT 1&#x27;,(err,results)=&gt;&#123;    if(err) console.log(err.message)    console.log(results)//只要能打印出[&#123;RowDataPacket&#123;&#x27;1&#x27;:1&#125;&#125;]，就说明数据库连接正常&#125;)\n\n2.3.2查询//查询const sqlStr1 = &#x27;select * from users&#x27;db.query(sqlStr1,(err,results)=&gt;&#123;    //查询失败    if(err) return console.log(err.message)    //查询成功    console.log(results)&#125;)\n\n2.3.3插入//插入新数据//待执行的 SQL 语句，其中 ？ 表示占位符const sqlStr2 = &#x27;INSERT INTO users(name,password) VALUES (?,?)&#x27;//要插入到users表中的数据对象const user2 = &#123;name:&#x27;sxk&#x27;,password:&#x27;liuzzhh&#x27;&#125;//使用数组的形式，依次为 ？ 占位符指定具体的值db.query(sqlStr2,[user2.name,user2.password],(err,results)=&gt;&#123;    if(err) return console.log(err.message)//失败    if(results.affectedRows === 1)&#123;console.log(&#x27;插入数据成功&#x27;)&#125;//成功&#125;)\n\n//简易写法//待执行的 SQL 语句，其中 ？ 表示占位符const sqlStr2 = &#x27;INSERT INTO users SET ?&#x27;//要插入到users表中的数据对象const user2 = &#123;name:&#x27;sxk&#x27;,password:&#x27;liuzzhh&#x27;&#125;//直接将数据对象当作占位符的值db.query(sqlStr2,user2,(err,results)=&gt;&#123;    if(err) return console.log(err.message)    if(results.affectedRows === 1)&#123;console.log(&#x27;插入数据成功&#x27;)&#125;&#125;)\n\n2.3.4更新//更新数据const sqlStr3 = &#x27;UPDATE users SET name=?,password=? where id=?&#x27;const user3 = &#123;id:26,name:&#x27;sj&#x27;,password:&#x27;sjssb&#x27;&#125;db.query(sqlStr3,[user3.name,user3.password,user3.id],(err,results)=&gt;&#123;    if(err) return console.log(err.message)    if(results.affectedRows === 1)&#123;console.log(&#x27;更新数据成功&#x27;)&#125;&#125;)\n\n//简易写法const sqlStr3 = &#x27;UPDATE users SET ? where id=?&#x27;const user3 = &#123;id:26,name:&#x27;sj&#x27;,password:&#x27;sjssb&#x27;&#125;db.query(sqlStr3,[user3,user3.id],(err,results)=&gt;&#123;    if(err) return console.log(err.message)    if(results.affectedRows === 1)&#123;console.log(&#x27;更新数据成功&#x27;)&#125;&#125;)\n\n2.3.5删除、标记删除const sqlStr4 = &#x27;DELETE FROM users WHERE id = ?&#x27;db.query(sqlStr4,26,(err,results)=&gt;&#123;    if(err) return console.log(err.message)    if(results.affectedRows === 1)&#123;console.log(&#x27;删除数据成功&#x27;)&#125;&#125;)\n\n标记删除：\n使用 DELETE 语句会把真正的把数据从表中删除掉。为了保险起见，推荐使用标记删除的形式，模拟删除的动作。 \n所谓的标记删除，就是在表中设置类似于 status 这样的状态字段，来标记当前这条数据是否被删除。 \n当用户执行了删除的动作时，我们并没有执行 DELETE 语句把数据删除掉，而是执行了 UPDATE 语句，将这条数据对应 的 status 字段标记为删除即可\n3.前后端身份认证3.1 WEB开发模式​\t目前主流的 Web 开发模式有两种，分别是： \n\n基于服务端渲染的传统 Web 开发模式 \n基于前后端分离的新型 Web 开发模式\n\n3.1.1服务端渲染的 Web 开发模式​\t服务端渲染的概念：服务器发送给客户端的 HTML 页面，是在服务器通过字符串的拼接，动态生成的。因此，客户端不需要使用 Ajax 这样的技术额外请求页面的数据。\n\n3.1.2服务端渲染的优缺点优点：\n\n前端耗时少。因为服务器端负责动态生成 HTML 内容，浏览器只需要直接渲染页面即可。尤其是移动端，更省电\n有利于SEO。因为服务器端响应的是完整的 HTML 页面内容，所以爬虫更容易爬取获得信息，更有利于 SEO\n\n缺点：\n\n占用服务器端资源。即服务器端完成 HTML 页面内容的拼接，如果请求较多，会对服务器造成一定的访问压力\n不利于前后端分离，开发效率低。使用服务器端渲染，则无法进行分工合作，尤其对于前端复杂度高的项目，不利于项目高效开发\n\n3.1.3前后端分离的WEB开发模式​\t前后端分离的概念：前后端分离的开发模式，依赖于 Ajax 技术的广泛应用。简而言之，就是后端只负责提供 API 接口，前端使用 Ajax 调用接口的开发模式\n3.1.4前后端分离的优缺点优点：\n\n开发体验好。前端专注于 UI 页面的开发，后端专注于api 的开发，且前端有更多的选择性。\n用户体验好。Ajax 技术的广泛应用，极大的提高了用户的体验，可以轻松实现页面的局部刷新。\n减轻了服务器端的渲染压力。因为页面最终是在每个用户的浏览器中生成的。\n\n缺点：\n\n不利于 SEO。因为完整的 HTML 页面需要在客户端动态拼接完成，所以爬虫对无法爬取页面的有效信息。（解决方案：利用 Vue、React 等前端框架的 SSR （server side render）技术能够很好的解决 SEO 问题！）\n\n3.1.5开发模式的选择\n企业级网站，主要功能是展示而没有复杂的交互，并且需要良好的 SEO，则这时我们就需要使用服务器端渲染\n类似后台管理项目，交互性比较强，不需要考虑 SEO，那么就可以使用前后端分离的开发模式。\n\n另外，具体使 用何种开发模式并不是绝对的，为了同时兼顾了首页的渲染速度和前后端分离的开发效率，一些网站采用了首屏服务器端渲染 + 其他页面前后端分离的开发模式。\n3.2身份认证3.2.1什么是身份认证​\t身份认证（Authentication）又称“身份验证”、“鉴权”，是指通过一定的手段，完成对用户身份的确认。\n如：检票、手机密码、指纹解锁、手机验证码、邮箱密码登录、二维码登录\n3.2.1为什么需要身份认证​\t身份认证的目的，是为了确认当前所声称为某种身份的用户，确实是所声称的用户。\n3.2.3不同开发模式下的身份认证\n服务端渲染推荐使用 Session 认证机制\n前后端分离推荐使用 JWT 认证机制\n\n3.3 Session认证机制3.3.1 HTTP 协议的无状态性​\t了解 HTTP 协议的无状态性是进一步学习 Session 认证机制的必要前提。\n​\tHTTP 协议的无状态性，指的是客户端的每次 HTTP 请求都是独立的，连续多个请求之间没有直接的关系，服务器不会主动保留每次 HTTP 请求的状态。\n3.3.2突破HTTP无状态的限制、Cookie​\t对于超市来说，为了方便收银员在进行结算时给 VIP 用户打折，超市可以为每个 VIP 用户发放会员卡，现实生活中的会员卡身份认证方式，在 Web 开发中的专业术语叫做 Cookie\n​\tCookie 是存储在用户浏览器中的一段不超过 4 KB 的字符串。它由一个名称（Name）、一个值（Value）和其它几个用于控制 Cookie 有效期、安全性、使用范围的可选属性组成。 \n​\tCookie的几大特性：\n\n自动发送\n域名独立\n过期时限\n4kb限制\n\n3.3.3Cookie在身份认证中的作用​\t客户端第一次请求服务器的时候，服务器通过响应头的形式，向客户端发送一个身份认证的 Cookie，客户端会自动将 Cookie 保存在浏览器中。 \n​\t随后，当客户端浏览器每次请求服务器的时候，浏览器会自动将身份认证相关的 Cookie，通过请求头的形式发送给 服务器，服务器即可验明客户端的身份\n\n3.3.4安全性（NO）​\t由于 Cookie 是存储在浏览器中的，而且浏览器也提供了读写 Cookie 的 API，因此 Cookie 很容易被伪造，不具有安全性。因此不建议服务器将重要的隐私数据，通过 Cookie 的形式发送给浏览器。 \n​\t注意：千万不要使用 Cookie 存储重要且隐私的数据！比如用户的身份信息、密码等\n​\t为了防止客户伪造会员卡，收银员在拿到客户出示的会员卡之后，可以在收银机上进行刷卡认证。只有收银机确认存在的会员卡，才能被正常使用\n​\t这种“会员卡”+“刷卡认证”的设计理念，就是SESSION认证机制的精髓\n3.3.5 Session的工作原理\n3.3.6 Session认证的局限性​\tSession 认证机制需要配合 Cookie 才能实现。由于 Cookie 默认不支持跨域访问，所以，当涉及到前端跨域请求后端接口的时候，需要做很多额外的配置，才能实现跨域 Session 认证。 \n\n当前端请求后端接口不存在跨域问题的时候，推荐使用 Session 身份认证机制\n当前端需要跨域请求后端接口的时候，不推荐使用 Session 身份认证机制，推荐使用 JWT 认证机制。\n\n3.4在Express中使用Session认证3.4.1安装 express-session 中间件npm i express-session\n\n3.4.2配置 express-session​\texpress-session 中间件安装成功后，需要通过 app.use() 来注册 session 中间件\nconst express = require(&#x27;express&#x27;)//1.导入express-sessionconst session = require()const app = express()//2.配置express-session中间件app.use(session(&#123;    secret:&#x27;itcyd&#x27;, //secret属性的值可以为任意字符串    resave:false,//固定写法    saveUninitialized:true//固定写法&#125;))\n\n3.4.3向Session存数据​\t当 express-session 中间件配置成功后，即可通过 req.session 来访问和使用 session 对象，从而存储用户的关键信息\n// 登录的 API 接口app.post(&#x27;/api/login&#x27;, (req, res) =&gt; &#123;  // 判断用户提交的登录信息是否正确  if (req.body.username !== &#x27;admin&#x27; || req.body.password !== &#x27;000000&#x27;) &#123;    return res.send(&#123; status: 1, msg: &#x27;登录失败&#x27; &#125;)  &#125;  // TODO_02：请将登录成功后的用户信息，保存到 Session 中  //注意：只有成功配置了 express-session 中间件后，才能通过req点出来  req.session.user = req.body //用户信息  req.session.islogin = true//用户的登录状态  res.send(&#123; status: 0, msg: &#x27;登录成功&#x27; &#125;)&#125;)\n\n3.4.4从Session取数据// 获取用户姓名的接口app.get(&#x27;/api/username&#x27;, (req, res) =&gt; &#123;  // TODO_03：请从 Session 中获取用户的名称，响应给客户端  if(!req.session.islogin)&#123;    return res.send(&#123;status:1,msg:&#x27;fail&#x27;&#125;)  &#125;  req.send(&#123;    status:0,    msg:&quot;success&quot;,    username:req.session.user.username  &#125;)&#125;)\n\n3.4.5清空 Session调用  req.session.destroy() 函数，即可清空服务器保存的 session 信息\n// 退出登录的接口app.post(&#x27;/api/logout&#x27;, (req, res) =&gt; &#123;  // TODO_04：清空 Session 信息  req.session.destroy()  res.send(&#123;    status:0,    msg:&#x27;退出登录成功&#x27;  &#125;)&#125;)\n\n3.5 JWT认证机制3.5.1什么是JWT​\tJWT（英文全称：JSON Web Token）是目前最流行的跨域认证解决方案。\n3.5.2 JWT的工作原理​\t用户的信息通过 Token 字符串的形式，保存在客户端浏览器中。服务器通过还原 Token 字符串的形式来认证用户的身份。\n\n3.5.3 JWT组成部分​\tJWT 通常由三部分组成，分别是 Header（头部）、Payload（有效荷载）、Signature（签名），三者之间用 . 分隔\nHeader.Payload.Signature\n\n\nPayload,才是真正的用户信息，它是用户信息经过加密之后生成的字符串\nHeader和Signature是安全性相关的部分，只是为了保证Token的安全性\n\n3.5.4 JWT的使用方式​\t客户端收到服务器返回的 JWT 之后，通常会将它储存在 localStorage 或 sessionStorage 中，此后，客户端每次与服务器通信，都要带上这个 JWT 的字符串，从而进行身份认证。推荐的做法是把 JWT 放在 HTTP请求头的 Authorization 字段中，格式如下：\nAuthorization: Bearer &lt;token&gt;\n\n3.6在Express中使用JWT3.6.1安装JWT相关的包npm i jsonwebtoken express-jwt\n\n\njsonwebtoken 用于生成JWT字符串\nexpress-jwt 用于将 JWT 字符串解析还原成 JSON 对象\n\n3.6.2定义secret密钥​\t为了保证 JWT 字符串的安全性，防止 JWT 字符串在网络传输过程中被别人破解，我们需要专门定义一个用于加密和解密的 secret 密钥，本质就是一个字符串。\n\n当生成 JWT 字符串的时候，需要使用 secret 密钥对用户的信息进行加密，最终得到加密好的 JWT 字符串\n当把 JWT 字符串解析还原成 JSON 对象的时候，需要使用 secret 密钥进行解密\n\n3.6.3在登录成功后生成 JWT 字符串​\t调用 jsonwebtoken 包提供的 sign() 方法，将用户的信息加密成 JWT 字符串，响应给客户端\n// 登录接口app.post(&#x27;/api/login&#x27;, function (req, res) &#123;  // 将 req.body 请求体中的数据，转存为 userinfo 常量  const userinfo = req.body  // 登录失败  if (userinfo.username !== &#x27;admin&#x27; || userinfo.password !== &#x27;000000&#x27;) &#123;    return res.send(&#123;      status: 400,      message: &#x27;登录失败！&#x27;    &#125;)  &#125;  // 登录成功  // TODO_03：在登录成功之后，调用 jwt.sign() 方法生成 JWT 字符串。并通过 token 属性发送给客户端  //三个参数分别书 用户信息对象，加密密钥，配置对象  tokenStr = jwt.sign(&#123;username:userinfo.username&#125;,secretKey,&#123;expiresIn:&#x27;30s&#x27;&#125;)  res.send(&#123;    status: 200,    message: &#x27;登录成功！&#x27;,    token: tokenStr// 要发送给客户端的 token 字符串  &#125;)&#125;)\n\n3.6.4 将 JWT 字符串还原为JSON 对象​\t客户端每次在访问那些有权限接口的时候，都需要主动通过请求头中的 Authorization 字段，将 Token 字符串发送到服务器进行身份认证。 \n​\t服务器可以通过 express-jwt 这个中间件，自动将客户端发送过来的 Token 解析还原成 JSON 对象\n// TODO_04：注册将 JWT 字符串解析还原成 JSON 对象的中间件//使用app.use注册中间件//expressJWT(&#123;secret:secretKey&#125;)就是用来解析 Token 的中间件//.unless(&#123;path:[/^\\/api\\//]&#125;)用来指定哪些接口不需要访问权限app.use(expressJWT(&#123;secret:secretKey&#125;).unless(&#123;path:[/^\\/api\\//]&#125;))\n\n3.6.5使用req.user获取用户信息​\t当 express-jwt 这个中间件配置成功之后，即可在那些有权限的接口中，使用 req.user 对象，来访问从 JWT 字符串中解析出来的用户信息\n// 这是一个有权限的 API 接口//只要配置成功了express-jwt就会把解析出来的用户信息，挂在到req.user属性上app.get(&#x27;/admin/getinfo&#x27;, function (req, res) &#123;  // TODO_05：使用 req.user 获取用户信息，并使用 data 属性将用户信息发送给客户端  res.send(&#123;    status: 200,    message: &#x27;获取用户信息成功！&#x27;,    data: req.user // 要发送给客户端的用户信息  &#125;)&#125;)\n\n3.6.6捕获解析JWT失败后产生的错误​\t当使用 express-jwt 解析 Token 字符串时，如果客户端发送过来的 Token 字符串过期或不合法，会产生一个解析失败的错误，影响项目的正常运行。我们可以通过 Express 的错误中间件，捕获这个错误并进行相关的处理\napp.use((err,req,res,next)=&gt;&#123;  //Token解析失败导致的错误  if(err.name === &#x27;UnauthorizedError&#x27;)&#123;    return res.send(&#123;status:401,message:&#x27;无效的Token&#x27;&#125;)  &#125;  //其他原因导致的错误  res.send(&#123;status:500,message:&#x27;未知错误&#x27;&#125;)&#125;)\n\n// 导入 express 模块const express = require(&#x27;express&#x27;)// 创建 express 的服务器实例const app = express()// TODO_01：安装并导入 JWT 相关的两个包，分别是 jsonwebtoken 和 express-jwtconst jwt = require(&#x27;jsonwebtoken&#x27;)const expressJWT = require(&#x27;express-jwt&#x27;)// 允许跨域资源共享const cors = require(&#x27;cors&#x27;)app.use(cors())// 解析 post 表单数据的中间件const bodyParser = require(&#x27;body-parser&#x27;)app.use(bodyParser.urlencoded(&#123; extended: false &#125;))// TODO_02：定义 secret 密钥，建议将密钥命名为 secretKeyconst secretKey = &#x27;itheima No1 ^_^&#x27;// TODO_04：注册将 JWT 字符串解析还原成 JSON 对象的中间件// 注意：只要配置成功了 express-jwt 这个中间件，就可以把解析出来的用户信息，挂载到 req.user 属性上app.use(expressJWT(&#123; secret: secretKey &#125;).unless(&#123; path: [/^\\/api\\//] &#125;))// 登录接口app.post(&#x27;/api/login&#x27;, function (req, res) &#123;  // 将 req.body 请求体中的数据，转存为 userinfo 常量  const userinfo = req.body  // 登录失败  if (userinfo.username !== &#x27;admin&#x27; || userinfo.password !== &#x27;000000&#x27;) &#123;    return res.send(&#123;      status: 400,      message: &#x27;登录失败！&#x27;,    &#125;)  &#125;  // 登录成功  // TODO_03：在登录成功之后，调用 jwt.sign() 方法生成 JWT 字符串。并通过 token 属性发送给客户端  // 参数1：用户的信息对象  // 参数2：加密的秘钥  // 参数3：配置对象，可以配置当前 token 的有效期  // 记住：千万不要把密码加密到 token 字符中  const tokenStr = jwt.sign(&#123; username: userinfo.username &#125;, secretKey, &#123; expiresIn: &#x27;30s&#x27; &#125;)  res.send(&#123;    status: 200,    message: &#x27;登录成功！&#x27;,    token: tokenStr, // 要发送给客户端的 token 字符串  &#125;)&#125;)// 这是一个有权限的 API 接口app.get(&#x27;/admin/getinfo&#x27;, function (req, res) &#123;  // TODO_05：使用 req.user 获取用户信息，并使用 data 属性将用户信息发送给客户端  console.log(req.user)  res.send(&#123;    status: 200,    message: &#x27;获取用户信息成功！&#x27;,    data: req.user, // 要发送给客户端的用户信息  &#125;)&#125;)// TODO_06：使用全局错误处理中间件，捕获解析 JWT 失败后产生的错误app.use((err, req, res, next) =&gt; &#123;  // 这次错误是由 token 解析失败导致的  if (err.name === &#x27;UnauthorizedError&#x27;) &#123;    return res.send(&#123;      status: 401,      message: &#x27;无效的token&#x27;,    &#125;)  &#125;  res.send(&#123;    status: 500,    message: &#x27;未知的错误&#x27;,  &#125;)&#125;)// 调用 app.listen 方法，指定端口号并启动web服务器app.listen(8888, function () &#123;  console.log(&#x27;Express server running at http://127.0.0.1:8888&#x27;)&#125;)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["数据库"],"tags":["MySQL"]},{"title":"11.和小达一起学Redux","url":"/2022/08/11/12.%E5%92%8C%E5%B0%8F%E8%BE%BE%E4%B8%80%E8%B5%B7%E5%AD%A6Redux/","content":"\nredux中文文档 \tredux官网（英文） \nReact技术栈：\n\nReact核心：React   Hooks\nreact-router（react-router-dom）\n状态管理： mobx（简单）&#x2F; redux（复杂）—–中间件： redux-thunk  redux-saga(用于发异步请求)\n\n1.Redux介绍React负责渲染UI，Redux负责管理组件的状态\n1.1概念​\tRedux 是 react 中最流行的状态管理工具之一\n​\t集中的方式统一管理所有的共享数据。  \n1.2起源​\tReact 只是 DOM 的一个抽象层（UI 库），并不是 Web 应用的完整解决方案。因此react在涉及到数据的处理以及组件之间的通信时会很吃力\n\n对于大型的复杂应用来说，这两方面恰恰是最关键的。因此，只用 React，写大型应用比较吃力。\n2014 年 Facebook 提出了 Flux 架构的概念，引发了很多的实现。\n2015 年，Redux 出现，将 Flux 与函数式编程（reducer）结合一起，很短时间内就成为了最热门的前端架构。 Flux 是最早的状态管理工具，它提供了状态管理的思想，也提供对应的实现\n除了 Flux、Redux 之外，还有：Mobx 等状态管理工具\n\n2.Redux基本使用(独立使用)2.1Redux管理流程\n\nReact Components:\t组件，组件用于渲染数据，可以自己提供数据，也可以从Store的state获取数据，store的数据变了，组件的数据也会跟着变\n\nstore：redux仓库。存储数据并提供数据(提供了state与操作state的方法)。把action交给Reducers处理，是整个redux应用的管理者，指挥action和reducer干活的。一个redux项目中只有一个store。\n\nAction Creators：创建action，然后dispatch分发action。action表示一个动作（添加内容，删除内容等），但是不执行，只提供“想法”。\n\nReducers：用于处理各种各样的action，接收就状态，返回新状态。（根据action来完成这个动作，reducer不会主动完成action，需要store控制）\n\n\n2.2安装、导入\n安装\n\nnpm install reduxyarn add redux\n\n\n导入redux包\n\n&lt;script src=&quot;../node_modules/redux/dist/redux.js&quot;&gt;&lt;/script&gt;\n\n\n测试redux是否安装成功\n\nconsole.log(window.Redux)\n\n2.3redux-action2.3.1redux-action介绍\nactions 只是描述了有事情发生了这一事实，而不是真正修改数据的位置\naction 是任务的抽象，视图中的每个用户交互都是一个 action，比如：添加任务、删除任务、登录、加入购物车等\nAction 本质上是 JavaScript 普通对象，action 内必须使用一个字符串类型的 type 字段来表示将要执行的动作type的值是一个字符串，且唯一\n\nconst add = &#123;    type: &#x27;ADD&#x27;&#125;const sub = &#123;    type: &#x27;SUB&#x27;&#125;\n\n规则：\n\naction必须提供type属性，值是一个字符串，采用全大写字母表示，多个单词使用 _ 连接\n\n2.3.2redux-action creator(函数创建action)\n直接使用对象来创建action不灵活，参数写死了。一般会使用函数来创建action，我们把创建action的函数叫做actionCreator\naction creator创建函数只是简单的返回一个 action\naction creator创建函数的好处是更容易被移植和测试，里面不应有任何逻辑，唯一的逻辑就是为了返回对象\n\n//直接定义对象const increment = &#123;    type: &#x27;INCREMENT&#x27;&#125;//函数创建对象const del = (id) =&gt; &#123;    return &#123;        type:&#x27;DEL&#x27; ,        id    &#125;&#125;const del = (id) =&gt; (&#123;type:&#x27;DEL&#x27; ,d&#125;)//简写要用小括号包裹，不然对象的花括号会被当成箭头函数的花括号//要得到对象，直接调用函数del(5)\n\n注意：action创建函数只是为了易移植\n2.4redux-reducer函数2.4.1 redux-reducer介绍state、action都书写完毕，但二者目前没任何关系，通过学习reducer将二者产生联系\n\nReducer是一个函数，用于提供处理action的逻辑\nreducer 就是一个纯函数(只要是固定的输入，必定得到固定的输出)，接收旧的 state 和 action，返回新的 state\n\n// reducuer的作用：处理action//1. reudcer的state需要有一个默认值，这个默认值就是redux的初始值//2. reducer内部需要判断action的type，根据type进行处理，处理的时候不能修改原来的数据//3. reducer如果遇到不认识的type，一定要返回原来的state(注意！)function reducer(state = 0, action)&#123;    switch(action.type)&#123;        case &#x27;ADD&#x27;:            return state + 1        case &#x27;MINUS&#x27;:            return state - 1        default :            return state    &#125;&#125;\n\n\n要保证reducer函数的纯函数特点，不要直接修改state\n遇到未知的 action 时，一定要返回旧的 state\n\n2.4.2纯函数\n特点：相同的输入，必定得到相同的输出\n好处：\n没有副作用，副作用指的是例如函数中一些异步调用或者会影响函数作用域之外的变量一类的操作\n可以缓存\n\n\n纯函数的原则：\n不得改写参数\n不能调用Date.now()或者Math.random()等不纯的方法，因为会得到不同的结果\n不能使用全局变量(全局变量会被别人改掉)\n\n\n\n2.4redux-store状态管理state、action、reducer都书写完毕，但目前三者还没联系，reducer函数没有调用，通过store进行使用打通数据管理\n\nStore 是把actioin、reducer联系到一起的对象 &#x3D;&gt; 利用Redux的API进行创建createStore()\n提供 getState() 方法获取 state\n提供 dispatch(action) 方法更新 state；\n通过 subscribe(listener) 注册监听器;\n通过 subscribe(listener) 返回的函数注销监听器。\n\n//store//1.解构出storeconst &#123; createStore &#125; = window.Redux//2.通过createStore()创建出一个store，注意需要传参数，把reducer传进去const store = createStore(reducer)//3. store.getState() 获取redux中的数据，注意：第一次获取的是默认值document.querySelector(&#x27;span&#x27;).innerHTML = store.getState()//5. 订阅subscribe()：只要state发生了变化，这个订阅的回调函数就会执行store.subscribe(() =&gt; &#123;console.log(store.getState())document.querySelector(&#x27;span&#x27;).innerHTML = store.getState()&#125;)//4. 安排任务store.dispatch()document.querySelector(&#x27;.add&#x27;).onclick = function () &#123;store.dispatch(add())&#125;document.querySelector(&#x27;.minus&#x27;).onclick = function () &#123;store.dispatch(minus())&#125;// 停止监听 state 更新unsubscribe()，使用了就会取消监听unsubscribe();\n\n注意代码数据：先创建store，启动监听，修改数据时自动在监听里面获取最新的数据\n//单纯用Redux实现加一减一的功能&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div&gt;      &lt;h3&gt;我当前的数量：&lt;span&gt;0&lt;/span&gt;&lt;/h3&gt;      &lt;button class=&quot;add&quot;&gt;+1&lt;/button&gt;      &lt;button class=&quot;minus&quot;&gt;-1&lt;/button&gt;    &lt;/div&gt;    &lt;script src=&quot;./node_modules/redux/dist/redux.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;      const add = () =&gt; &#123;        return &#123; type: &#x27;ADD&#x27; &#125;      &#125;      const minus = () =&gt; &#123;        return &#123; type: &#x27;MINUS&#x27; &#125;      &#125;      // reducuer的作用：处理action      //1. reudcer的state需要有一个默认值，这个默认值就是redux的初始值      //2. reducer内部需要判断action的type，根据type进行处理，处理的时候不能修改原来的数据      //3. reducer如果遇到不认识的type，一定要返回原来的state(注意！)      function reducer(state = 100, action) &#123;        switch (action.type) &#123;          case &#x27;ADD&#x27;:            return state + 1          case &#x27;MINUS&#x27;:            return state - 1          default:            return state        &#125;      &#125;      //store      //1.解构出store      const &#123; createStore &#125; = window.Redux      //2.通过createStore()创建出一个store，注意需要传参数，把reducer传进去      const store = createStore(reducer)      //3. store.getState() 获取redux中的数据，注意：第一次获取的是默认值      document.querySelector(&#x27;span&#x27;).innerHTML = store.getState()      //5. 订阅subscribe()：只要state发生了变化，这个订阅的回调函数就会执行      store.subscribe(() =&gt; &#123;        console.log(store.getState())        document.querySelector(&#x27;span&#x27;).innerHTML = store.getState()      &#125;)      //4. 安排任务store.dispatch()      document.querySelector(&#x27;.add&#x27;).onclick = function () &#123;        store.dispatch(add())      &#125;      document.querySelector(&#x27;.minus&#x27;).onclick = function () &#123;        store.dispatch(minus())      &#125;    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;\n\n\n\n3.Redux配合React使用3.1react-redux包的基本使用目标：使用react-redux简化redux在react项目中的使用 \n内容：\n\n介绍react-redux &#x3D;&gt; yarn add react-redux\n安装并且配置react-redux &#x3D;&gt; 参考文档\n优化刚才的代码\n\n核心代码\nstore/store.js\nimport &#123; createStore &#125; from &#x27;redux&#x27;import &#123; addReducer &#125; from &#x27;./reducers.js&#x27;let store = createStore(addReducer)export default store\n\nstore/reducers.js\nexport const addReducer = (  state = &#123;    count: 1,  &#125;,  action) =&gt; &#123;  switch (action.type) &#123;    case &#x27;ADD&#x27;:      return Object.assign(&#123;&#125;, state, &#123; count: action.count &#125;)    default:      return state  &#125;&#125;\n\nindex.js\nimport ReactDOM from &#x27;react-dom&#x27;import App from &#x27;./App.js&#x27;import store from &#x27;./store/store.js&#x27;import &#123; Provider &#125; from &#x27;react-redux&#x27;ReactDOM.render(  &lt;Provider store=&#123;store&#125;&gt;    &lt;App /&gt;  &lt;/Provider&gt;,  document.querySelector(&#x27;#root&#x27;))\n\nApp.js\nimport &#123; add &#125; from &#x27;./store/actions&#x27;import &#123; connect &#125; from &#x27;react-redux&#x27;const App = (props) =&gt; &#123;  console.log(props)  const &#123; count, dispatch1 &#125; = props  return (    &lt;div&gt;      &lt;h3&gt;App&lt;/h3&gt;      &lt;p&gt;&#123;count&#125;&lt;/p&gt;      &lt;button        onClick=&#123;() =&gt; &#123;          dispatch1()        &#125;&#125;      &gt;        点我+2      &lt;/button&gt;    &lt;/div&gt;  )&#125;const mapStateToProps = (state, ownProps) =&gt; &#123;  const &#123; count &#125; = state  return &#123;    count,  &#125;&#125;const mapDispatchToProps = (dispatch, ownProps) =&gt; &#123;  return &#123;    dispatch1: () =&gt; &#123;      dispatch(add(2))    &#125;,  &#125;&#125;export default connect(mapStateToProps, mapDispatchToProps)(App)\n\n要点：\n\nreact-redux只是简化了在react项目中使用redux的过程\nredux和react-redux两个包都需要安装和使用，各司其职\n需要知道Provider和connect的作用\nconnect是高阶组件 &#x3D;&gt; 把redux里面数据和修改数据的方法映射到组件中为了使用方便\n\n3.2react-redux结合hooks用法-useSelector目标：结合hooks使用react-redux\n内容：\n\nreact-redux提供了useSelector\nuseSelector： 从Redux 的 store 中获取 状态(state) 数据。\nselector 函数应该是个纯函数\n\nApp.js\n// import &#123; add, addAfterOneSecond &#125; from &#x27;./store/actions&#x27;import &#123; useSelector &#125; from &#x27;react-redux&#x27;const App = () =&gt; &#123;  const count = useSelector((state) =&gt; state.count)  return (    &lt;div&gt;      &lt;h3&gt;App&lt;/h3&gt;      &lt;p&gt;&#123;count&#125;&lt;/p&gt;      &lt;button        onClick=&#123;() =&gt; &#123;          // dispatch(add(2))        &#125;&#125;      &gt;        点我+2      &lt;/button&gt;      &lt;button        onClick=&#123;() =&gt; &#123;          // dispatch(addAfterOneSecond(2))        &#125;&#125;      &gt;        点我1s后+2      &lt;/button&gt;    &lt;/div&gt;  )&#125;export default App\n\n要点：\n\nProvider组件依然需要使用\n\n3.3react-redux结合hooks用法-useDispatch目标：结合hooks使用react-redux，修改数据\n内容：\n\nreact-redux提供了useDispatch\nuseDispatch：修改数据的hooks\n\nApp.js\nimport &#123; add, addAfterOneSecond &#125; from &#x27;./store/actions&#x27;import &#123; useSelector, useDispatch &#125; from &#x27;react-redux&#x27;const App = () =&gt; &#123;  const count = useSelector((state) =&gt; state.count)  const dispatch = useDispatch()  return (    &lt;div&gt;      &lt;h3&gt;App&lt;/h3&gt;      &lt;p&gt;&#123;count&#125;&lt;/p&gt;      &lt;button        onClick=&#123;() =&gt; &#123;          dispatch(add(2))        &#125;&#125;      &gt;        点我+2      &lt;/button&gt;      &lt;button        onClick=&#123;() =&gt; &#123;          dispatch(addAfterOneSecond(2))        &#125;&#125;      &gt;        点我1s后+2      &lt;/button&gt;    &lt;/div&gt;  )&#125;export default App\n\n要点：无\n3.4redux-异步action中间件redux-thunk的使用目标：如何处理异步的action呢？比如点击按钮，1s后+1\n内容：\n\nredux-thunk的介绍，安装 \n配置redux-thunk\n编写异步action\nApp.js中测试\n\n核心代码\nstore/reducers.js 不变\nindex.js不变\nstore/store.js\nimport &#123; createStore, applyMiddleware &#125; from &#x27;redux&#x27;import thunk from &#x27;redux-thunk&#x27;import &#123; addReducer &#125; from &#x27;./reducers.js&#x27;// let store = createStore(addReducer)const store = createStore(addReducer, applyMiddleware(thunk))export default store\n\nstore/actions.js\nexport const add = (count) =&gt; &#123;  return &#123;    type: &#x27;ADD&#x27;,    count,  &#125;&#125;export const addAfterOneSecond = (count) =&gt; &#123;  return (dispatch) =&gt; &#123;    // console.log(dispatch)    setTimeout(() =&gt; &#123;      dispatch(add(count))    &#125;, 1000)  &#125;&#125;\n\nApp.js\nimport &#123; add, addAfterOneSecond &#125; from &#x27;./store/actions&#x27;// import &#123; add &#125; from &#x27;./store/actions&#x27;const App = (props) =&gt; &#123;  const &#123;    store: &#123; getState, dispatch &#125;,  &#125; = props  const &#123; count &#125; = getState()  return (    &lt;div&gt;      &lt;h3&gt;App&lt;/h3&gt;      &lt;p&gt;&#123;count&#125;&lt;/p&gt;      &lt;button        onClick=&#123;() =&gt; &#123;          dispatch(add(2))        &#125;&#125;      &gt;        点我+2      &lt;/button&gt;      &lt;button        onClick=&#123;() =&gt; &#123;          dispatch(addAfterOneSecond(2))        &#125;&#125;      &gt;        点我1s后+2      &lt;/button&gt;    &lt;/div&gt;  )&#125;export default App\n\n注意：\n\nredux-thunk是专门处理redux中异步action的中间件\n当要异步操作数据变化时，需要用redux-thunk包\n常见的异步：定时器，ajax，注册事件\n\n3.5redux-devtools-extension的使用目标：模拟vue的devtools，开发react项目时，通过chrome开发者工具调试跟踪redux状态\n步骤：\n\n通过包管理器在项目中安装 yarn add redux-devtools-extension\n在index.js中进行配置和导入\n安装chrome浏览器插件 \n启动react项目，打开chrome开发者工具，测试\n\n文档 redux-devtools-exension  \n","categories":["前端"],"tags":["Redux"]},{"title":"2.和小达一起学CSS","url":"/2022/08/11/2.%E5%92%8C%E5%B0%8F%E8%BE%BE%E4%B8%80%E8%B5%B7%E5%AD%A6CSS/","content":"⭐CSS 基础CSS—层叠样式表(Cascading Style Sheets)\n1.引用 css1.外链式\n&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/style.css&quot; /&gt;\n\n2.嵌入式\n\n在 head 中\n\n单个页面\n\n\n&lt;style type=&quot;text/css&quot;&gt;  h1 &#123;    font: bold 20px/2em arial, verdana;  &#125;&lt;/style&gt;\n\n3.内联式\n\n单个元素\n\n&lt;p style=&quot;color:black; margin:16px&quot;&gt;Something&lt;/p&gt;\n\n2.选择器2.1 基础选择器/* 标签选择器 就是 选中改标签名的标签 */p &#123;&#125;/* 类选择器  选中html中定义了class类的标签 */.classname &#123;&#125;/* id选择器  选中html中定义了id的标签 */#idname &#123;&#125;\n\n2.2 选择器进阶/* 后代选择器*/选择器1 选择器2 &#123;&#125;/* 子代选择器*/选择器1 &gt; 选择器2 &#123;&#125;/* 并集选择器*/选择器1,选择器2 &#123;&#125;/* 交集选择器*/选择器1.选择器2 &#123;&#125;/* hover伪类选择器*/选择器:hover &#123;&#125;\n\n2.3 结构伪类选择器 根据元素在 html 中的结构关系查找元素，减少对于 HTML 中类的依赖，有利于保持代码整洁。\n\n\n\n选择器\n说明\n\n\n\nE:first-child{}\n匹配父元素中第一个子元素，并且是 E 元素\n\n\nE:last-child{}\n匹配父元素中最后一个子元素，并且是 E 元素\n\n\nE:nth-child(n){}\n匹配父元素中第 n 个子元素，并且是 E 元素\n\n\nE:nth-last-child(n){}\n匹配父元素中倒数第 n 个子元素，并且是 E 元素\n\n\n注意：n 为 0 1 2 3 4 5 6 ……\n通过 n 可以组成常见公式，如：\n\n\n\n功能\n公式\n\n\n\n奇数\n2n+1 ; odd\n\n\n偶数\n2n ; even\n\n\n找到前 5 个\n-n+5\n\n\n第五个往后\nn+5\n\n\n2.4 链接伪类选择器 场景：用于选中超链接的不同状态\n\n\n\n选择器语法\n说明\n\n\n\na:link{}\n选中链接 a未访问过的状态\n\n\na:visited{}\n选中链接 a访问之后的状态\n\n\na:hover{}\n选中链接 a鼠标悬停的状态\n\n\na:active{}\n选中链接 a鼠标按下的状态\n\n\n注意：若需要同时实现以上四种状态效果，需要按表所示的顺序书写\n2.5 焦点伪类选择器 场景：用于选中元素获取焦点时状态，常用于表单控件\n\n\n\n选择器语法\n说明\n\n\n\ninput:focus{}\n获取焦点时状态\n\n\n注意：表单控件获取焦点时默认会显示外部轮廓线\n2.6 属性选择器 场景：用于选中元素有该属性的元素\n\n\n\n选择器语法\n说明\n\n\n\nE[attr]\n选择有 attr 属性的元素\n\n\nE[attr&#x3D;’val’]\n选择有 attr 属性且值为 val 的元素\n\n\n3.字体和文本样式3.1 字体样式\n\n\n字体样式\n属性名\n属性值\n\n\n\n字体大小\nfont-size\n16px(默认)\n\n\n字体粗细\nfont-weight\n400；normal(400)；blod(700)\n\n\n字体样式\nfont-style\nnormal&#x2F;italic(倾斜)\n\n\n字体系列\nfont-family\n具体字体 1,具体字体 2,具体字体 3,具体字体 4,…,字体系列\n\n\n行高\nline-height\n50px ; 倍数(当前标签 font-seze 的倍数)\n\n\nfont-family 渲染规则：\n\n从左往右按照顺序查找，如果电脑中未安装该字体，则显示下一个字体\n如果都不支持，此时会根据操作系统，显示最后字体系列的默认字体\n\n字体连写：font : style weight size&#x2F;line-height family;\n3.2 文本样式\n\n\n文本样式\n属性名\n属性值\n\n\n\n文本缩进\ntext-indent\n100px ; 1em(1em &#x3D; 当前标签的 font-size 大小)\n\n\n水平对齐方式\next-align\ncenter；left; right(给文本的父元素设置)\n\n\n文本修饰\ntext-decoration\nnone; underline(下划线)\n\n\n4.背景和显示模式4.1 背景\n\n\n背景\n属性名\n属性值\n\n\n\n背景色\nbackground-color\nrgba(0, 0, 0, .5) ; rgb(0,0,0) ; #ccc ; pink\n\n\n背景图\nbackground-image\nurl(地址);\n\n\n背景平铺\nbackground-repeat\nrepeat ; no-repeat ; repeat-x ; repeat-y\n\n\n背景位置\nbackground-position\n水平位置 垂直位置 （方位名词 or 数字+px）\n\n\n背景连写：background: colr image repeat position&#x2F;size\n背景图\n\n\n属性名\n属性值\n场景\n\n\n\nbackground-size\n数字+px\n简单常用\n\n\nbackground-size\n百分比\n相对于当前盒子的宽高的百分比\n\n\nbackground-size\ncontain\n包含，将背景图按自身大小等比缩放\n\n\nbackground-size\ncover\n覆盖，将背景图等比缩放，刚好填满整个盒子\n\n\n4.2 显示模式(块，行内，行内块)\n块\n特点\n独占一行\n设置宽高生效\n宽度默认是父级的 100%\n\n\n转换写法 : display: block\n\n\n行内\n特点\n一行显示多个\n设置宽高不生效\n尺寸和内容一样大\n\n\n转换写法 : display: inline;\n\n\n行内块\n特点\n一行显示多个\n设置宽高生效\n\n\n转换写法: display: inline-block\n\n\n\n5.CSS 特性(继承性，层叠性)4.1 继承性子元素可以继承父元素的属性：文字控制属性都能继承, 不是控制文字的都不能继承；自己有相关的属性则执行自己的, 不执行继承。\n控制继承\nCSS 为控制继承提供了四个特殊的通用属性值。每个 css 属性都接收这些值。\n\ninherit\n设置该属性会使子元素属性和父元素相同。实际上，就是 “开启继承”.\n\ninitial\n设置属性值和浏览器默认样式相同。如果浏览器默认样式中未设置且该属性是自然继承的，那么会设置为 inherit 。\n\nunset\n将属性重置为自然值，也就是如果属性是自然继承那么就是 inherit，否则和 initial一样\n\n\n4.2 层叠性优先级：继承 &lt; 通配符 &lt; 标签 &lt; 类 &lt; id &lt; 行内样式 &lt; !important\n权重叠加计算一个选择器的优先级可以说是由四个部分相加 (分量)\n\n\n\n千位\n百位\n十位\n个位\n\n\n\n行内选择器个数\nid 选择器个数\n类选择器个数\n标签选择器个数\n\n\n!important：覆盖所有上面所有优先级计算（强烈建议除了非常情况不要使用它。 !important 改变了层叠的常规工作方式，它会使调试 CSS 问题非常困难，特别是在大型样式表中）\n6.盒子模型6.1 盒子的概念 1.页面中的每一个标签，都可看做是一个 “盒子”，通过盒子的视角更方便的进行布局\n 2.浏览器在渲染（显示）网页时，会将网页中的元素看做是一个个的矩形区域，我们也形象的称之为 盒子\n6.2 内容(content)div &#123;  width: 200px;  height: 200px;  background-color: pink;&#125;\n\n\n\n6.3 内边距(padding)div &#123;  padding: 5px; /*一个值：上下左右*/  padding: 5px 5px; /*两个值：上下，左右*/  padding: 5px 5px 10px; /*三个值：上，左右，下*/  padding: 5px 5px 10px 10px; /*四个值：上，右，下，左*/  padding-top: 5px;  padding-bottom: 5px;  padding-left: 5px;  padding-right: 5px;&#125;\n\n6.4 边框(border)div &#123;  /* border: 粗细  线条样式   颜色 -- 不分先后顺序 */  border: 1px solid #000; /*实线*/  border: 5px dashed #000; /*虚线*/  border: 5px dotted #000; /*点线*/&#125;\n\n6.5 外边距(margin)div &#123;  margin: 5px; /*一个值：上下左右*/  margin: 5px 5px; /*两个值：上下，左右*/  margin: 5px 5px 10px; /*三个值：上，左右，下*/  margin: 5px 5px 10px 10px; /*四个值：上，右，下，左*/  margin-top: 5px;  margin-bottom: 5px;  margin-left: 5px;  margin-right: 5px;&#125;\n\n版心居中： margin: 0 auto;\n7.伪元素伪元素是由 css 模拟出的标签效果，根据元素在 HTML 中的结构关系查找元素，减少对于 HTML 中类的依赖，有利于保持代码整洁。常用于查找某父级选择器中的子元素\n\n\n\n伪元素\n作用\n\n\n\n::before\n在父元素内容的最前面添加一个伪元素\n\n\n::after\n在父元素内容的最后面添加一个伪元素\n\n\n注意：\n\n必须设置 content 属性才能生效\n伪元素默认是行内元素\n\n.father::after &#123;  content: &#x27;&#x27;;&#125;.father::before &#123;  content: &#x27;&#x27;;&#125;\n\n8.浮动 float8.1 标准流 标准流：又称文档流，是浏览器在渲染显示网页内容时默认采用的一套排版规则，规定了应该以何种方式排列元素\n➢ 常见标准流排版规则：\n\n块级元素：从上往下，垂直布局，独占一行\n\n行内元素 或 行内块元素：从左往右，水平布局，空间不够自动折行\n\n\n8.2 浮动 让垂直布局的盒子变成水平布局\n.one &#123;  background-color: pink;  float: left;&#125;.two &#123;  background-color: skyblue;  /* flr */  /* float: right; */  float: right;&#125;\n\n8.3 浮动的特点\n浮动元素会脱离标准流（简称：脱标），在标准流中不占位置\n\n浮动元素比标准流高半个级别，可以覆盖标准流中的元素\n\n浮动找浮动，下一个浮动元素会在上一个浮动元素后面左右浮动\n\n浮动元素有特殊的显示效果\n• 一行可以显示多个\n• 可以设置宽高\n\n\n➢ 注意点： • 浮动的元素不能通过 text-align:center 或者 margin:0 auto\n8.4 清除浮动 浮动后脱标，不占位置。若子元素浮动了，此时子元素不能撑开标准流的块级父元素。需要清除浮动。\n方法 1：直接给父元素设置高度 优点：简单粗暴 缺点：有些布局中，父元素的高度是不能固定的，不适用。\n方法 2：在父元素内容的最后添加一个块级元素 ，给添加的块级元素设置 clear:both。缺点：会在页面中添加额外的标签，让页面 HTML 结构更加复杂。\n.clearfix &#123;  /* 清除左右两侧浮动的影响 */  clear: both;&#125;\n\n方法 3：单伪元素清除：用伪元素替代了方法 2 中的额外标签，直接给标签添加类即可清除浮动\n.clearfix::after &#123;  content: &#x27;&#x27;;  display: block;  clear: both;  /* 为了兼容性 */  height: 0;  visibility: hidden;&#125;\n\n方法 4：双伪元素清除：用伪元素替代了额外标签，直接给标签添加类即可清除浮动\n/* 清除浮动 */.clearfix::before,.clearfix::after &#123;  content: &#x27;&#x27;;  display: table;&#125;/* 真正清除浮动的标签 */.clearfix::after &#123;  /* content: &#x27;&#x27;;    display: table; */  clear: both;&#125;\n\n方法 5：给父元素设置overflow : hidden\n9.定位 position9.1 标准流、浮动、定位 标准流：又称文档流，是浏览器在渲染显示网页内容时默认采用的一套排版规则，规定了应该以何种方式排列元素\n 浮动：可以让原本垂直布局的 块级元素变成水平布局\n 定位：可以让元素自由摆放在网页的任意位置\n9.2 定位的使用 1. 设置定位方式\n\n\n\n属性名\n属性值\n定位方式\n\n\n\nposition\nstatic\n静态定位\n\n\nposition\nrelative\n相对定位\n\n\nposition\nabsolute\n绝对定位\n\n\nposition\nfixed\n固定定位\n\n\n 2. 设置偏移量\n\n\n\n方向\n属性名\n属性值\n\n\n\n左:水平\nleft\n数字 + px\n\n\n右:水平\nright\n数字 + px\n\n\n上:垂直\ntop\n数字 + px\n\n\n下:垂直\nbottom\n数字 + px\n\n\n9.3 静态定位 static.box &#123;  /* 静态定位, 默认值, 标准流 */  position: static;  left: 100px;  top: 200px;  width: 200px;  height: 200px;  background-color: pink;&#125;\n\n注意点： 静态定位就是之前标准流，不能通过方位属性进行移动\n9.4 相对定位 relative.box &#123;  position: relative;  right: 200px;  bottom: 400px;  left: 100px;  top: 200px;  /*         1. 占有原来的位置        2. 仍然具体标签原有的显示模式特点        3. 改变位置参照自己原来的位置    */  width: 200px;  height: 200px;  background-color: pink;&#125;\n\n特点：\n\n需要配合方位属性实现移动\n\n相对于自己原来位置进行移动\n\n在页面中占位置 → 没有脱标\n\n\n9.5 绝对定位 absolute.box &#123;  /* 绝对定位:         先找已经定位的父级, 如果有这样的父级就以这个父级为参照物进行定位;        有父级, 但父级没有定位, 以浏览器窗口为参照为进行定位    */  position: absolute;  /* left: 50px; */  left: 0;  top: 0;  /*     1. 脱标, 不占位    2. 改变标签的显示模式特点: 具体行内块特点(在一行共存, 宽高生效)    */  width: 200px;  height: 200px;  background-color: pink;&#125;\n\n特点：\n\n需要配合方位属性实现移动\n\n如果祖先元素没有定位，则默认相对于浏览器进行移动\n\n如果祖先元素有定位，则相对于最近的 有定位 的祖先元素进行移动\n\n脱标，在页面中不占位置\n\n\n9.6 固定定位 fixed.box &#123;  position: fixed;  left: 0;  top: 0;  /*         1. 脱标-不占位置        2. 改变位置参考浏览器窗口        3. 具备行内块特点    */  width: 200px;  height: 200px;  background-color: pink;&#125;\n\n特点：\n\n需要配合方位属性实现移动\n\n相对于浏览器可视区域进行移动\n3.脱标，在页面中不占位置\n\n\n9.7 子绝父相 • 子元素：绝对定位\n • 父元素：相对定位\n 让子元素相对于父元素进行自由移动，此时父元素是相对定位，对网页的布局影响最小\n子元素相对父元素水平居中 子元素绝对定位，父元素相对定位\n 先让子元素往右移动父盒子的一半，left ： 50%\n 再让子元素往左移动自己的一半 transform : translateX(-50%)\n9.8 层级关系 • 标准流 &lt; 浮动 &lt; 定位\n • 相对、绝对、固定默认层级相同，此时 HTML 中写在下面的元素层级更高，会覆盖上面的元素\n更改定位元素层级 属性名：z-index 属性值 数字 数字越大，层级越高\n10.装饰10.1 垂直对齐方式 vertical\n\n\n属性名\n属性值\n效果\n\n\n\nvertical-align\nbaseline\n默认，基线对齐\n\n\nvertical-align\ntop\n顶部对齐\n\n\nvertical-align\nmiddle\n中部对齐\n\n\nvertical-align\nbottom\n底部对齐\n\n\n➢ 可以解决：\n\n文本框和表单按钮无法对齐\ninput 和 img 无法对齐\ndiv 中的文本框，文本框无法贴顶\ndiv 不设高度由 img 标签撑开，此时 img 标签下面会存在额外间隙\n\n10.2 光标类型 cursor 设置鼠标光标在元素上时显示的样式\n\n\n\n属性名\n属性值\n效果\n\n\n\ncursor\ndefult\n默认，箭头\n\n\ncursor\npointer\n抓手，提示用户点击\n\n\ncursor\ntext\n工，提示用户选择文字\n\n\ncursor\nmove\n十字光标，提示用户移动\n\n\n10.3 边框圆角 border-radius\n\n\n属性名\n属性值\n\n\n\nborder-radius\n数字+px ; 百分比\n\n\n赋值顺序：左上角开始顺时针，若未赋值，与对角相同\n正圆 盒子为正方形，设置边框为盒子宽高的一半 border-radius:50%\n胶囊 盒子为长方形，边框为盒子高度的一半 border-radius:盒子高度的一半\n三角形 设置一个盒子，四周不同颜色的边框，将盒子的宽高设置为 0 仅保留 border，得到四个三角形，将其余边框（三角形）设置为透明。opacity：0；\n10.4 溢出部分显示特效 overflow盒子的内容部分超出盒子的区域范围时的显示：\n\n\n\n属性名\n属性值\n效果\n\n\n\noverflow\nvisible\n默认，溢出可见\n\n\noverflow\nhidden\n溢出部分隐藏\n\n\noverflow\nscroll\n无论是否溢出都显示滚动条\n\n\noverflow\nauto\n溢出显示滚动条\n\n\n10.5 元素的显示&#x2F;隐藏 visibility&#x2F;display元素本身的显示或隐藏，如 hover 后元素隐藏&#x2F;可见\n\n\n\n属性名\n属性值\n效果\n\n\n\nvisibility\nhidden\n隐藏元素，占位\n\n\ndisplay\nnone&#x2F;clock\n隐藏元素，不占位\n\n\n10.6 透明度 opacity让元素整体变透明\n\n\n\n属性名\n属性值\n效果\n\n\n\nopacity\n0-1 之间的数字\n0 完全透明，1 不透明\n\n\n10.7 精灵图场景：项目中将多张小图片，合并成一张大图片，这张大图片称之为精灵图\n减少服务器发送次数，提高页面加载速度\n使用步骤 1.创建一个盒子\n 2.量取所需小图的宽高，并且将宽高设为盒子的宽高\n 3.将精灵图设为盒子的背景图片 backgroungimg\n 4.测量小图左上角的坐标，取负设置 background-position:x y\n10.8 阴影 shadow文字阴影\n\n\n属性名\n参数\n效果\n\n\n\ntext-shadow\nh-shadow\n水平偏移量\n\n\ntext-shadow\nv-shadow\n垂直偏移量\n\n\ntext-shadow\nblur\n模糊度\n\n\ntext-shadow\ncolor\n阴影色\n\n\n前两个属性必需，阴影可以叠加设置，每组阴影取值之间逗号隔开\n盒子阴影\n\n\n属性名\n参数\n效果\n\n\n\nbox-shadow\nh-shadow\n水平偏移量\n\n\nbox-shadow\nv-shadow\n垂直偏移量\n\n\nbox-shadow\nblur\n模糊度\n\n\nbox-shadow\nspread\n阴影扩大\n\n\nbox-shadow\ncolor\n阴影色\n\n\nbox-shadow\ninset\n改为内部阴影\n\n\n10.9 过渡 transition\n\n\n属性名\n参数\n取值\n\n\n\ntransition\n过渡的属性\nall 或 具体的属性名称，如 width：只有 width 过渡\n\n\ntransition\n过渡时长\n数字 + s\n\n\n注意点：\n\n过渡需要：默认状态 和 hover 状态样式不同，才能有过渡效果\n\ntransition 属性给需要过渡的元素本身加\n\ntransition 属性设置在不同状态中，效果不同的\n① 给默认状态设置，鼠标移入移出都有过渡效果\n② 给 hover 状态设置，鼠标移入有过渡效果，移出没有过渡效果\n\n\n10.10 字体图标 icon图标库 www.icon-font.com 字体图标的本质也是字体\n使用方法 1.引样式表\n&lt;link rel=&quot;stylesheet&quot; href=&quot;./iconfont/iconfont.css&quot; /&gt;\n\n 2.使用字体图标对应的类名，必须两个类名\n&lt;i class=&quot;iconfont icon-xxx&quot;&gt;&lt;/i&gt;\n\n10.11 平面转换 transform1.位移 translate.div:hover &#123;  /* transform: translate(水平移动距离, 垂直移动距离); */  /* transform: translate(100px, 50px); */  /* 百分比: 盒子自身尺寸的百分比 */  /* transform: translate(100%, 50%); */  /* transform: translate(-100%, 50%); */  /* 只给出一个值表示x轴移动距离 */  /* transform: translate(100px); */&#125;\n\ntransform:translate(水平移动距离, 垂直移动距离);\nX 轴向右为正，Y 轴向下为正\n取值：像素单位数值 百分比（参照物为盒子自身的尺寸）\n单独设置单个方向的距离：transform: translateX（） transform: translateY（）\n2.旋转 rotateimg:hover &#123;  transform: rotate(90deg);&#125;\n\ntransform: rotate(角度); 角度单位为 deg\n取值为正，顺时针\n修改转换原点\nimg &#123;  transition: all 2s;  transform-origin: right bottom;  /*transform-origin: 水平位置 垂直位置;*/&#125;\n\n默认圆点是盒子中心点\n取值可以为 数字+px 方位名词 百分比（参照物为盒子自身尺寸）\n3.缩放 scaleimg:hover &#123;  transform: scale(1.2);  /*transform: scale(缩放倍数);*/&#125;\n\nscale 大于 1 表示放大，小于 1 表示缩小\n4.渐变 background-imgbox &#123;  /*background-img:linear-gradient(颜色1，颜色2);*/  background-image: linear-gradient(transparent, rgba(0, 0, 0, 0.8));&#125;\n\ntransparent 透明\n10.11 空间转换 transform1.位移 translate.div:hover &#123;  /* transform: translate3d(水平移动距离, 垂直移动距离,Z轴移动距离); */  /* 百分比: 盒子自身尺寸的百分比 */  /* transform: translate(100%, 50%,50%)*/&#125;\n\ntransform:translate(水平移动距离, 垂直移动距离，Z 轴移动距离);\nX 轴向右为正，Y 轴向下为正，Z 轴从 screen 指向自己为正\n取值：像素单位数值 百分比（参照物为盒子自身的尺寸）\n单独设置单个方向的距离：transform: translateX（） transform: translateY（）transform: translateZ（）\n2.旋转 rotateimg:hover &#123;  transform: rotateX(90deg);  transform: rotateY(90deg);  transform: rotateZ(90deg);&#125;\n\ntransform: rotateX&#x2F;Y&#x2F;Z(角度); 角度单位为 deg判断旋转方向：左手法则，左手握住旋转轴，大拇指指向正值方向，手指方向为旋转正值的方向\n3.透视 perspectivebody &#123;  perspective: 1000px;  /*perspective:值;*/&#125;\n\nperspective 属性添加给父级，取值为像素单位值，一般取 800-1200\n在空间转换的过程中，为元素添加近大远小，近实远虚的视觉效果\n4.立体呈现box &#123;  /*background-img:linear-gradient(颜色1，颜色2);*/  background-image: linear-gradient(transparent, rgba(0, 0, 0, 0.8));&#125;\n\n使用 perspective 透视属性不能呈现立体图形，父元素需要添加 transform-style:preserve-3d;使子元素处于 3d 空间\n5.空间缩放img:hover &#123;  transform: scaleX(1.2);  transform: scaleY(1.2);  transform: scaleZ(1.2);  transform: scale3d(x, y, z);&#125;\n\n10.12 动画 animation1.使用动画.box &#123;  width: 200px;  height: 100px;  background-color: pink;  /* 使用动画 */  animation: change 1s;&#125;/*定义动画*//*@keyframes 动画名称&#123;\tfrom&#123;&#125;\tto()&#125;*//*@keyframes 动画名称&#123;\t0%&#123;&#125;\t20%&#123;&#125;\t100%&#123;&#125;&#125;*/@keyframes change &#123;  0% &#123;    width: 200px;  &#125;  50% &#123;    width: 500px;    height: 300px;  &#125;  100% &#123;    width: 800px;    height: 500px;  &#125;&#125;/* 百分比指的是动画总时长的占比 */\n\n步骤： 1.定义动画 2.使用动画\n2.动画属性animation: 动画名称 动画时长 速度曲线 延迟事件 重复次数 动画方向  执行完毕时的状态;\n\n动画名称和动画时长必须赋值；\n取值不分先后顺序；\n如果有 2 个时间值，第一个时间表示动画时长，第二个时间表示延迟时间\n11.HTML 前置认知11.1 网站与网页 网页相当于一本书，网页相当于一本书的每一页，网站是多个冲主题的网页的整合。\n11.2 骨架结构标签&lt;!DOCTYPE html&gt;\n\n 文档类型声明，告诉浏览器该网页的 html 版本\n&lt;html lang=&quot;en&quot;&gt;&lt;/html&gt;\n\n 认识网页所用的语言，用于搜索引擎归类和浏览器翻译\n&lt;meta charset=&quot;UTF-8&quot; /&gt;\n\n 认识网页所用的字符编码，保存和打开的字符编码需要统一设置，否则可能会出现乱码\n 常见字符编码：\n\nUTF-8：万国码，国际化的字符编码，收录了全球语言的文字\n\nGB2312：6000+ 汉字\n\nGBK：20000+ 汉字\n注意点：开发中 统一使用 UTF-8 字符编码 即可\n\n\n11.3SEO(Search Engine Optimization)搜索引擎优化作用 让网站在搜索引擎上的排名更靠前\n提升 SEO\n竞价排名\n\n将网页制作成 html 后缀\n\n标签语义化（在合适的地方使用合适的标签） ……\n\n\nSEO 三大标签&lt;title&gt;京东(JD.COM)-正品低价、品质保障、配送及时、轻松购物！&lt;/title&gt;\n\n网页标题标签\n&lt;meta  name=&quot;description&quot;  content=&quot;京东JD.COM-专业的综合网上购物商城，为您提供正品低价的购物选择、优质便捷的服务体验。商品来自全球数十万品牌商家，囊括家电、手机、电脑、服装、居家、母婴、美妆、个护、食品、生鲜等丰富品类，满足各种购物需求。&quot;/&gt;\n\n网页描述标签\n&lt;meta  name=&quot;keywords&quot;  content=&quot;网上购物,网上商城,家电,手机,电脑,服装,居家,母婴,美妆,个护,食品,生鲜,京东&quot;/&gt;\n\n网页关键词标签​\n12.CSS 书写规范\n\n\n顺序\n类型\n举例\n\n\n\n1\n布局属性\ndisplay position float clear visibility overflow\n\n\n2\n盒子模型\nwidth height margin padding border background\n\n\n3\n文本内容\ncolor font text-decoration text-align line-height\n\n\n4\n装饰\ncursor border-radius text-shadow\n\n\n13.CSS 加载过程当浏览器展示一个文件的时候，它必须兼顾文件的内容和文件的样式信息，下面我们会了解到它处理文件的标准的流程。需要知道的是，下面的步骤是浏览加载网页的简化版本，而且不同的浏览器在处理文件的时候会有不同的方式，但是下面的步骤基本都会出现。\n\n浏览器载入 HTML 文件（比如从网络上获取）。\n将 HTML 文件转化成一个 DOM（Document Object Model），DOM 是文件在计算机内存中的表现形式。\n接下来，浏览器会拉取该 HTML 相关的大部分资源，比如嵌入到页面的图片、视频和 CSS 样式。JavaScript 则会稍后进行处理，简单起见，同时此节主讲 CSS，所以这里对如何加载 JavaScript 不会展开叙述。\n浏览器拉取到 CSS 之后会进行解析，根据选择器的不同类型（比如 element、class、id 等等）把他们分到不同的“桶”中。浏览器基于它找到的不同的选择器，将不同的规则（基于选择器的规则，如元素选择器、类选择器、id 选择器等）应用在对应的 DOM 的节点中，并添加节点依赖的样式（这个中间步骤称为渲染树）。\n上述的规则应用于渲染树之后，渲染树会依照应该出现的结构进行布局。\n网页展示在屏幕上（这一步被称为着色）。\n\n当浏览器遇到无法解析的 CSS 代码时，浏览器什么也不会做，继续解析下一个 CSS 样式。\n","categories":["前端"],"tags":["CSS"]},{"title":"3.和小达一起学CSS移动端","url":"/2022/08/11/3.%E5%92%8C%E5%B0%8F%E8%BE%BE%E4%B8%80%E8%B5%B7%E5%AD%A6CSS%E7%A7%BB%E5%8A%A8%E7%AB%AF/","content":"⭐CSS移动端CSS—层叠样式表(Cascading Style Sheets)\n1.基本知识1.1屏幕尺寸​\t屏幕对角线的长度，一般用英寸来度量\n1.2分辨率​\t物理分辨率：生产屏幕时就固定，不可被改变\n​\t逻辑分辨率：由软件（驱动）决定的，制作网页参考的是逻辑分辨率\n1.3.视口：&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n\n​\tviewport：视口       width&#x3D;device-width：视口宽度 &#x3D; 设备宽度      initial-scale&#x3D;1.0：缩放1倍（不缩放）\n2.Flex布局2.1特点​\tFlex布局又称为弹性布局： \n​\t1.是一种浏览器提倡的布局模型 \n​\t2.布局网页更简单、灵活 \n​\t3.避免浮动脱标的问题\n2.2添加方式.box &#123;    display: flex;    justify-content: space-between;&#125;\n\n给父级元素添加 **disply:flex’**子元素可以自动拉伸和压缩。\n组成部分包括：弹性容器，弹性盒子，主轴(main axis)，侧轴(cross axis)\n2.3主轴对齐方式justify-content.box &#123;    display: flex;    /* 居中 */    justify-content: center;    /* 间距在弹性盒子(子级)之间 */    justify-content: space-between;    /* 所有地方的间距都相等 */    justify-content: space-evenly;    /* 间距加在子级的两侧 */    /* 视觉效果: 子级之间的距离是父级两头距离的2倍 */    justify-content: space-around;            height: 200px;    margin: auto;    border: 1px solid #000;&#125;\n\n\n\n\n属性值\n作用\n\n\n\nflex-start\n默认值, 起点开始依次排列\n\n\nflex-end\n终点开始依次排列\n\n\ncenter\n沿主轴居中排列\n\n\nspace-around\n弹性盒子沿主轴均匀排列, 空白间距均分在弹性盒子两侧\n\n\nspace-between\n弹性盒子沿主轴均匀排列, 空白间距均分在相邻盒子之间\n\n\nspace-evenly\n弹性盒子沿主轴均匀排列, 弹性盒子与容器之间间距相等\n\n\n2.4侧轴对齐方式align-items&#x2F;align-self.box &#123;    display: flex;    /* 居中 */    /* align-items: center; */    /* 拉伸,默认值(现有状态,测试的时候去掉子级的高度) */    /* align-items: stretch; */    height: 300px;    margin: auto;    border: 1px solid #000;&#125;/* 单独设置某个弹性盒子的侧轴对齐方式 */.box div:nth-child(2) &#123;    /*align-self: center;*/&#125;\n\n\n\n\n属性值\n作用\n\n\n\nflex-start\n默认值, 起点开始依次排列\n\n\nflex-end\n终点开始依次排列\n\n\ncenter\n沿主轴居中排列\n\n\nstretch\n默认值， 弹性盒子沿着主轴线被拉伸至铺满容器\n\n\nalign-items（添加到弹性容器）\nalign-self： 控制某个弹性盒子在侧轴的对齐方式（添加到弹性盒子）\n2.5使用flex属性修改弹性盒子的伸缩比.box &#123;    display: flex;&#125;.box div &#123;    height: 200px;    margin: 0 20px;    background-color: pink;&#125;.box div:nth-child(1) &#123;    width: 50px;&#125;.box div:nth-child(2) &#123;    /* 占用父级剩余尺寸的份数 */    flex: 3;&#125;.box div:nth-child(3) &#123;    flex: 1;&#125;\n\n注意：添加到子盒子上，只占用父盒子的剩余尺寸，把父盒子的剩余尺寸分成n份，我占m份\n2.5修改元素排列方向flex-direction.box li &#123;    display: flex;    /* 1. 先确定主轴方向; 2. 再选择对应的属性实现主轴或侧轴的对齐方式 */    /* 修改主轴方向: 列 */    flex-direction: column;    /* 视觉效果: 实现盒子水平居中 */    align-items: center;    /* 视觉效果: 垂直居中 */    justify-content: center;        width: 80px;    height: 80px;    border: 1px solid #ccc;&#125;\n\n\n\n\n属性值\n作用\n\n\n\nrow\n行, 水平(默认值)\n\n\ncolumn\n列, 垂直\n\n\nrow-reverse\n行, 从右向左\n\n\ncolumn-reverse\n列, 从下向上\n\n\n2.6弹性盒子换行​\t\t场景：只要父元素添加了flex，子元素会自动缩放(宽度不够，会挤压改变子元素尺寸)\n..box &#123;    display: flex;    /* 默认值, 不换行 */    /* flex-wrap: nowrap; */    /* 弹性盒子换行 */    flex-wrap: wrap;    /* 调节行对齐方式 */    /* align-content: center; */    /* align-content: space-around; */    align-content: space-between;    height: 500px;    border: 1px solid #000;&#125;\n\n\n\n\n属性名\n属性值\n\n\n\nflex-wrap\nwrap&#x2F;nowrap\n\n\n3.移动适配-rem3.1长度单位rem\nrem是相对单位\n相对于HTML标签的字号，1rem &#x3D; 1HTML字号大小\n可以使用flexible.js，根据不同的视口宽度给网页的html根节点设置不同的font-size\n\n3.2媒体查询/* 使用媒体查询, 根据不同的视口宽度, 设置不同的根字号 *//*视口宽度为320px,根字号为32px（1/10视口宽度）*/@media (width:375px) &#123;    html &#123;        font-size: 40px;    &#125;&#125;@media (width:400px) &#123;    html &#123;        font-size: 40px;    &#125;&#125;/* 2. 书写盒子尺寸, 单位rem */.box &#123;    width: 5rem;    height: 3rem;    background-color: pink;&#125;\n\n3.3Less3.3.1说明​\t\tLess是一个CSS预处理器, Less文件后缀是**.less**\n​\t\t扩充了 CSS 语言, 使 CSS 具备一定的逻辑性、计算能力\n​\t\t注意：浏览器不识别Less代码，目前阶段，网页要引入对应的CSS文件\n​\t\t可以在vscode中使用Less插件Easy Less，less文件自动保存生成css文件\n3.3.2语法//1.注释//单行注释/*块注释*///2.计算.box &#123;    //加、减、乘    width: 100 + 10px;    width: 100 - 20px;    width: 100 * 2px;    // 除法：需要加小括号或者./    width: (68 / 37.5rem);    height: 29 ./ 37.5rem;&#125;//3.快速生成后代选择器.father &#123;    width: 100px;    .son &#123;        color: pink;        // &amp; 表示当前选择器，不生成后代选择器，通常配合伪类使用        &amp;:hover &#123;            color: green;        &#125;    &#125;    &amp;:hover &#123;        color: orange;    &#125;&#125;//4.导入其他Less文件@import &#x27;base.less&#x27;    //5.导出css文件// out： ./css/happy.css//6.禁止导出// out:false\n\n\n\n4.移动适配-vw&#x2F;vh4.1长度单位vw&#x2F;vh\nvw&#x2F;vh是相对单位,相对视口的尺寸计算结果\nvw(viewport width)：1vw &#x3D; 1&#x2F;100视口宽度\nvh(viewport height)：1vw &#x3D; 1&#x2F;100视口高度\n开发中，vw和vh不会混用，混用会导致盒子变形\n\n/* 1. vw = 1/100视口宽度 */.box &#123;    width: 50vw;    height: 30vw;    background-color: pink;&#125;\n\n4.2rem和vw&#x2F;vh比较rem：\n需要不断修改html文字大小\n需要使用媒体查询@media\n需要使用flexible.js\n\n\t\nvw&#x2F;vw：\n以上都不需要\n\n省去各种判断以及修改\n\n\n5.响应式布局5.1bootstrap","categories":["前端"],"tags":["CSS移动端"]},{"title":"10.和小达一起学React","url":"/2022/08/11/11.%E5%92%8C%E5%B0%8F%E8%BE%BE%E4%B8%80%E8%B5%B7%E5%AD%A6React/","content":"\n1.React基本介绍\nReact是用于构建用户界面的JavaScript库\nReact—–React-Dom—–React-Router—–Redux    组成React框架\n官网       https://reactjs.org/\n中文网   https://zh-hans.reactjs.org/\n\n1.1React特点\n声明式UI：只需要描述UI看起来是什么样的，就跟写HTML一样。声明式(what)，命令式（how）\n\nconst jsx = &lt;div className=&quot;app&quot;&gt;    &lt;h1&gt;Hello React! 动态数据变化:&#123;count&#125;&lt;/h1&gt;&lt;/div&gt;\n\n\n组件化：基于组件进行开发，开发项目是在组合、复用多个组件\n学习一次，随处使用：可以开发所有界面，Web,移动端，VR\n\n\n1.2React脚手架1.2.1脚手架​\t保证前端开发过程顺利进行而搭设的开发平台\n1.2.2作用​\t省去繁琐的工具配置过程\n​\t开始时：搭好架子，省去Webpack的配置\n​\t开发时：热更新、格式化代码、git提交时自动校验代码格式\n​\t发布时：一键自动打包(代码压缩、优化、按需加载)\n1.2.3命令，初始化项目原始：1.全局安装npm i -g create-react-app 2. 通过脚手架的命令来创建 React 项目\n推荐：在终端输入npx create-react-app react-basic\n\nnpx create-react-app 是固定命令\ncreate-react-app是React脚手架名称\nreact-basic表示项目名称，可以修改\nnpx是 npm v5.2 版本新添加的命令，用来简化 npm 中工具包的使用\n\n启动项目：npm start或yarn start\n1.2.4项目目录结构调整\n说明：\nsrc是写代码进行项目开发的目录\n查看 package.json 两个核心库：react、react-dom（脚手架已经帮我们安装好，我们直接用即可）\n\n\n调整：\n删除 src 目录下的所有文件\n创建Index.js作为项目的入口文件，直接写React代码即可\n\n\n\n1.3React基本使用//1.导入2个核心包，React和ReactDOMimport React from &#x27;react&#x27;import ReactDOM from &#x27;react-dom&#x27;//2.创建元素（虚拟DOM）//参数1：标签的名字 h1,div,p//参数2：标签的属性，对象//参数3：标签的内容const element = React.createElement(&#x27;h1&#x27;,&#123;id:&#x27;box&#x27;,title:&#x27;haha&#x27;&#125;,&#x27;hello react&#x27;)//3.渲染React元素到页面//参数1：渲染哪个React元素//参数2：渲染到哪个容器里面ReactDOM.render(element,document.getElementById(&#x27;root&#x27;))\n\n创建如下所示：&lt;ul class=&quot;list&quot;&gt;    &lt;li&gt;香蕉&lt;/li&gt;    &lt;li&gt;橘子&lt;/li&gt;    &lt;li&gt;苹果&lt;/li&gt;&lt;/ul&gt;const element = React.createElement(&#x27;ul&#x27;,&#123;className:&#x27;list&#x27;&#125;,[    React.createElement(&#x27;li&#x27;,null,&#x27;香蕉&#x27;),    React.createElement(&#x27;li&#x27;,null,&#x27;橘子&#x27;),    React.createElement(&#x27;li&#x27;,null,&#x27;苹果&#x27;),])\n\n2.JSX2.1 createElement的问题\n繁琐不简洁\n不直观，无法一眼看出所描述的结构\n不优雅，开发体验不好\n\n2.2 JSX简介​\t是什么： JSX是JavaScript XML的缩写，表示在Javascript代码中写XML(HTML)格式的代码。\n​\t优势： 声明式语法更加直观，与HTML结构相同，降低学习成本，提高开发效率。\n![JSX 声明式vs命令式](..&#x2F;pictures&#x2F;JSX 声明式vs命令式.png)\n2.3使用步骤1.导入react和reactDOM包2.使用jsx语法创建react元素3.把react元素渲染到页面中\n\n//1.导入2个核心包，React和ReactDOMimport React from &#x27;react&#x27;import ReactDOM from &#x27;react-dom&#x27;//2.创建元素（虚拟DOM）const element = &lt;div id=&#x27;box&#x27;&gt;    &lt;h1&gt;我是box&lt;/h1&gt;    &lt;ul&gt;        &lt;li&gt;第一个li&lt;/li&gt;        &lt;li&gt;第二个li&lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;//3.渲染React元素到页面//参数1：渲染哪个React元素//参数2：渲染到哪个容器里面ReactDOM.render(element,document.getElementById(&#x27;root&#x27;))\n\n2.4 JSX的注意事项\n只有在脚手架中才能使用 jsx 语法，因为JSX需要经过 babel 的编译处理，才能在浏览器中使用。脚手架中已经默认有了这个配置。\nJSX必须要有一个根节点\n幽灵节点，不会渲染任何内容  &lt;&gt;&lt;/&gt; &lt;React.Fragment&gt;&lt;/React.Fragment&gt;\n\n\n标签有开始就要有结束，没有子节点的元素可以使用/&gt;结束，比如&lt;img  /&gt;\nJSX中语法更接近 JavaScript\nclass &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; className\nfor&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;  htmlFor\n\n\nJSX可以换行，如果JSX有多行，推荐使用()包裹 JSX，防止自动插入分号的bug\n\n2.5 prettier插件自动格式化代码\n安装：\n\n\n添加prettier配置\n\n\n//1.保存到额时候用使用prettier进行格式化&quot;editor.formatOnSave&quot;: true,//2.不要有分号&quot;prettier.semi&quot;: false,//3.使用单引号&quot;prettier.singleQuote&quot;: true,//4.默认使用prittier作为格式化工具&quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;,\n\n2.6 JSX中嵌入JavaScript表达式能被console.log()打印的才是表达式在jsx中使用花括号&#123;&#125;，提供js表达式\n\n\n基本使用\n\nconst name = &#x27;张三&#x27;const age = 18const title = (  &lt;h1&gt;    姓名：&#123;name&#125;, 年龄：&#123;age&#125;  &lt;/h1&gt;)\n\n\n可以访问对象的属性\n\nconst car = &#123;    brand: &#x27;玛莎拉蒂&#x27;&#125;const title = (  &lt;h1&gt;    汽车：&#123;car.brand&#125;  &lt;/h1&gt;)\n\n\n可以访问数组的下标\n\nconst friends = [&#x27;张三&#x27;, &#x27;李四&#x27;]const title = (  &lt;h1&gt;    汽车：&#123;friends[1]&#125;  &lt;/h1&gt;)\n\n\n可以使用三元运算符\n\nconst gender = 18const title = (  &lt;h1&gt;    性别：&#123;age &gt;= 18? &#x27;是&#x27;:&#x27;否&#x27;&#125;  &lt;/h1&gt;)\n\n\n可以调用方法\n\nfunction sayHi() &#123;  return &#x27;你好&#x27;&#125;const title = &lt;h1&gt;姓名：&#123;sayHi()&#125;&lt;/h1&gt;\n\n\nJSX本身\n\nconst span = &lt;span&gt;我是一个span&lt;/span&gt;const title = &lt;h1&gt;盒子&#123;span&#125;&lt;/h1&gt;\n\n\nJSX中的注释\n\n&#123;/* 这是jsx中的注释 */&#125;   推荐快键键 ctrl + /\n\n\n不要出现语句，比如if for\n\n2.7条件渲染在react中，一切都是javascript，所以条件渲染完全是通过js来控制的,没有任何新知识点\n\n\n通过判断if/else控制\n\nconst isLoding = falseconst loadData = () =&gt; &#123;  if (isLoding) &#123;    return &lt;div&gt;数据加载中.....&lt;/div&gt;  &#125; else &#123;    return &lt;div&gt;数据加载完成，此处显示加载后的数据&lt;/div&gt;  &#125;&#125;const title = &lt;div&gt;&#123;loadData()&#125;&lt;/div&gt;ReactDOM.render(title, document.getElementById(&#x27;root&#x27;))\n\n\n通过三元运算符控制\n\nconst isLoding = falseconst loadData = () =&gt; &#123;  return isLoding ? (    &lt;div&gt;数据加载中.....&lt;/div&gt;  ) : (    &lt;div&gt;数据加载完成，此处显示加载后的数据&lt;/div&gt;  )&#125;\n\n\n逻辑运算符\n\nconst isLoding = falseconst loadData = () =&gt; &#123;  return isLoding &amp;&amp; &lt;div&gt;加载中...&lt;/div&gt;&#125;const title = &lt;div&gt;&#123;loadData()&#125;&lt;/div&gt;\n\n2.8 vscode配置自动补全// 当按tab键的时候，会自动提示&quot;emmet.triggerExpansionOnTab&quot;: true,&quot;emmet.showAbbreviationSuggestions&quot;: true,// jsx的提示&quot;emmet.includeLanguages&quot;: &#123;  &quot;javascript&quot;: &quot;javascriptreact&quot;&#125;\n\n2.9列表渲染我们经常需要遍历一个数组来重复渲染一段结构在react中，通过 map方法 进行列表的渲染\n\n\n列表的渲染\n\nconst names = [&#x27;关羽&#x27;, &#x27;张飞&#x27;, &#x27;赵云&#x27;]const list = names.map(item =&gt; &lt;li&gt;&#123;item&#125;&lt;/li&gt;)const dv = (  &lt;div&gt;    &lt;ul&gt;&#123;list&#125;&lt;/ul&gt;  &lt;/div&gt;)ReactDOM.render(dv, document.getElementById(&#x27;root&#x27;))\n\n\n直接在JSX中渲染\n\nconst names = [&#x27;关羽&#x27;, &#x27;张飞&#x27;, &#x27;赵云&#x27;]const dv = (  &lt;div&gt;    &lt;ul&gt;&#123;names.map(item =&gt; &lt;li&gt;&#123;item&#125;&lt;/li&gt;)&#125;&lt;/ul&gt;  &lt;/div&gt;)\n\n\nkey属性的使用\n\n注意：列表渲染时应该给重复渲染的元素添加key属性，key属性的值要保证唯一\n注意：key值避免使用index下标，因为下标会发生改变\nconst dv = (  &lt;div&gt;    &lt;ul&gt;      &#123;names.map(item =&gt; (        &lt;li key=&#123;item&#125;&gt;&#123;item&#125;&lt;/li&gt;      ))&#125;    &lt;/ul&gt;  &lt;/div&gt;)\n\n2.10样式2.10.1行内样式-styleconst dv = (  &lt;div style=&#123;&#123; color: &#x27;red&#x27;, backgroundColor: &#x27;pink&#x27; &#125;&#125;&gt;style样式&lt;/div&gt;)\n\n2.10.2类名-className// 导入样式import &#x27;./base.css&#x27;const dv = &lt;div className=&quot;title&quot;&gt;style样式&lt;/div&gt;\n\nbase.css样式文件.title &#123;  text-align: center;  color: red;  background-color: pink;&#125;\n\n2.11总结\nJSX是React的核心内容\nJSX表示在JS代码中书写HTML结构，是React声明式的体现\n使用JSX配合嵌入的JS表达式，条件渲染，列表渲染，可以渲染任意的UI结构\n结果使用className和style的方式给JSX添加样式\nReact完全利用JS的语言自身的能力来编写UI，而不是造轮子增强HTML的功能。（对比VUE）\n\n3.组件3.1组件的基本介绍\n组件是React中最基本的内容，使用React就一定在使用组件\n组件表示页面中的部分功能，页面中的东西都是由组件组成的\n多个组件组合而成，可以实现完整的页面功能\n组件特点：可复用，每个组件相互独立，可组合\n\n3.2React创建组件3.2.1函数组件函数组件：使用JS的函数或者箭头函数创建的组件\n\n\n为了区分普通标签，函数组件的名称必须大写字母开头\n必须有返回值，返回一个结构\n如果不渲染任何内容，return一个null即可\n\n使用函数创建组件：\nfunction Hello()&#123;    return &lt;h3&gt;这是一个函数组件&lt;/h3&gt;&#125;const element = &lt;div&gt;    &lt;h1&gt;函数组件&lt;/h1&gt;    &lt;Hello&gt;&lt;/Hello&gt;\t&lt;Hello&gt;&lt;/Hello&gt;&lt;/div&gt;\n\n使用箭头函数创建组件：\nconst Hello = () =&gt; &lt;div&gt;这是一个函数组件&lt;/div&gt;const element = &lt;div&gt;    &lt;h1&gt;函数组件&lt;/h1&gt;    &lt;Hello&gt;&lt;/Hello&gt;\t&lt;Hello&gt;&lt;/Hello&gt;&lt;/div&gt;\n\n调用&#x2F;渲染组件：\nReactDOM.render(&lt;Hello /&gt;, document.getElementById(&#x27;root&#x27;))\n\n3.2.2知识回顾(类与继承)Class基本语法\n\n在 ES6 之前通过构造函数创建对象\n\n在 ES6 中新增了一个关键字 class, 类 和构造函数类似，用于创建对象\n\n类与对象的区别\n类：指的是一类的事物，是个概念，比如车 手机 水杯等\n对象：一个具体的事物，有具体的特征和行为，比如一个手机，我的手机等， 类可以创建出来对象。\n\n\n类创建对象的基本语法\n\n基本语法class 类名&#123;&#125;\n构造函数constructor的用法，创建对象\n在类中提供方法，直接提供即可\n在类中不需要使用,分隔\n\n//1.ES6之前的写法function Teacher(name,age)&#123;    this.name = name    this.age = age&#125;Teacher.prototype.sayHi = function()&#123;    console.log(`大家好我是` + this.name)&#125;const itmo = new Teacher(&#x27;王&#x27;,30)console.log(itmo)//2.ES6的写法class Teacher&#123;    //构造函数    constructor(name,age)&#123;        this.name = name        this.age = age    &#125;    sayHi()&#123;        console.log(&#x27;大家好，我是&#x27; + this.name)    &#125;&#125;\n\nextends实现继承\n\n类可以使用它继承的类中所有的成员（属性和方法）\n类中可以提供自己的属性和方法\n注意：如果想要给类中新增属性，必须先调用 super 方法\n\nclass Chinese extends Person&#123;     constructor(name,gender)&#123;        super(name,gender)//!父类的构造函数        this.skin = &#x27;yellow&#x27;    &#125;    pingpong()&#123;        console.log(&#x27;乒乓球&#x27;)    &#125; &#125;// Chinese继承了Person的方法和属性，然后还有自己的属性skin和方法pingpong\n\n3.2.3类组件用类创建组件的约束\n\n类组件的名称必须大写字母开头\n类组件应该继承 React.Component父类，从而可以使用父类中提供的方法和属性\n类组件必须提供render方法,render方法必须有返回值，表示该组件的结构\n\n定义组件\nclass Hello extends React.Component&#123;    render()&#123;        return &lt;div&gt;我是Hello组件&lt;/div&gt;    &#125;&#125;\n\n使用组件\nconst element = (    &lt;div&gt;        &lt;h1&gt;函数组件&lt;/h1&gt;        &lt;Hello&gt;&lt;/Hello&gt;        &lt;Hello&gt;&lt;/Hello&gt;    &lt;/div&gt;)\n\n3.2.4提取组件到单独的js文件\n组件作为一个独立的个体，一般会放到一个独立的JS文件中\n\n\n在src中准备文件夹components,创建Hello.js或者Hello.jsx\n在 Hello.js 中导入React (函数组件可以不导入，类组件必须导入，因为要继承React.Component)\n创建组件（函数 或 类）\n在 Hello.js 中导出该组件\n在 index.js 中导入 Hello 组件\n渲染组件\n\n//1.类组件import &#123; Component &#125; from &quot;react&quot;;class Hello extends Component&#123;    render()&#123;        return(            &lt;div&gt;这是一个Hello组件&lt;/div&gt;        )    &#125;&#125;//导出组件export default Hello//2.函数组件const Demo = () =&gt; &lt;div&gt;这是一个函数组件&lt;/div&gt;export default Demo\n\nimport React from &quot;react&quot;import ReactDOM from &quot;react-dom&quot;//导入组件import Hello from &#x27;./components/Hello.js&#x27;import Demo from &#x27;./components/Demo.js&#x27;const element = (    &lt;div&gt;        &lt;h1&gt;函数组件&lt;/h1&gt;        &lt;Hello&gt;&lt;/Hello&gt;        &lt;Hello&gt;&lt;/Hello&gt;        &lt;Demo&gt;&lt;/Demo&gt;    &lt;/div&gt;)ReactDOM.render(element,document.getElementById(&#x27;root&#x27;))\n\n3.2.5有状态组件&#x2F;无状态组件\n状态（state）即组件的私有数据，当组件的状态发生了改变，页面结构也就发生了改变。\n函数组件又叫做无状态组件   函数组件是不能自己提供数据(hooks允许函数组件提供数据)\n函数组件没有状态，只负责页面的展示(静态，不会发生变化)性能比较高\n类组件又叫做有状态组件 类组件可以自己提供数据，数据如果发生了改变，内容会自动的更新\n类组件有自己的状态，负责更新UI，只要类组件的数据发生了改变，UI就会发生更新\n\n在复杂的项目中，一般都是由函数组件和类组件共同配合来完成的。【增加了负担，所以有了hooks】比如计数器案例，点击按钮让数值+1， 0和1就是不同时刻的状态，当状态从0变成1之后，UI也要跟着发生变化。React想要实现这种功能，就需要使用有状态组件来完成。\n\n3.2.6类组件的状态\n状态state即数据，是组件内部的私有数据,只有在组件内部可以使用\nstate的值是一个对象,表示一个组件中可以有多个数据\n\nclass App extends React.Component&#123;    constructor()&#123;        super()        this.state = &#123;            msg:&#x27;hello react&#x27;,            count:0        &#125;    &#125;    render()&#123;        return (            &lt;div&gt;                &lt;h1&gt;&#123;this.state.msg&#125;&lt;/h1&gt;            &lt;/div&gt;        )    &#125;&#125;\n\n更简单的语法\nclass App extends React.Component &#123;  state = &#123;    msg: &#x27;hello&#x27;,    count: 0,  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;h1&gt;&#123;this.state.msg&#125;&lt;/h1&gt;      &lt;/div&gt;    )  &#125;&#125;\n\n4.事件处理4.1注册事件on时间名=&#123;事件处理程序&#125;，如onClick=&#123;this.handleClick&#125;\n注意：React事件采用驼峰命名法，如onClick，onMouseEnter\nclass App extends React.Component&#123;        state = &#123;            count:0        &#125;        render()&#123;        return (            &lt;div&gt;                &lt;h1&gt;&#123;this.state.count&#125;&lt;/h1&gt;                &lt;button onClick=&#123;this.clickFn&#125;&gt;+1&lt;/button&gt;            &lt;/div&gt;        )    &#125;    clickFn()&#123;        console.log(&#x27;点击事件&#x27;)    &#125;&#125;\n\n4.2事件对象\n可以通过事件处理程序的参数获取到事件对象\nReact 中的事件对象叫做：合成事件（对象）\n合成事件：兼容所有浏览器，无需担心跨浏览器兼容性问题\n\nfunction handleClick(e) &#123;    e.preventDefault()//阻止默认事件    e.stopPropagation()//阻止冒泡    console.log(&#x27;事件对象&#x27;, e)&#125;&lt;a onClick=&#123;this.handleClick&#125;&gt;点我，不会跳转页面&lt;/a&gt;\n\n4.3this的指向\n注册事件的this指向undefined，有问题，需要解决\nrender方法中的this指向当前react组件\n\n解决方案1：注册事件先写箭头函数，再用箭头函数调用\n\n箭头函数的特点：自身没有this，访问的是外部的this\n但是该方法会把大量的js处理逻辑放到jsx中，将来不容易维护\n\nclass App extends React.Component&#123;        state = &#123;            count:0        &#125;        render()&#123;        return (            &lt;div&gt;                &lt;h1&gt;&#123;this.state.count&#125;&lt;/h1&gt;                &lt;div&gt;&#123;this.state.count&#125;&lt;/div&gt;                &lt;button onClick=&#123;() =&gt; this.clickFn()&#125;&gt;+1&lt;/button&gt;            &lt;/div&gt;        )    &#125;    clickFn()&#123;        console.log(&#x27;点击事件&#x27;)        console.log(this.state.count)    &#125;&#125;\n\n解决方案2：使用bind方法修改this的指向\nclass App extends React.Component&#123;        state = &#123;            count:0        &#125;        render()&#123;        return (            &lt;div&gt;                &lt;h1&gt;&#123;this.state.count&#125;&lt;/h1&gt;                &lt;div&gt;&#123;this.state.count&#125;&lt;/div&gt;                &lt;button onClick=&#123;() =&gt; this.clickFn.bind(this)&#125;&gt;+1&lt;/button&gt;            &lt;/div&gt;        )    &#125;    clickFn()&#123;        console.log(&#x27;点击事件&#x27;)        console.log(this.state.count)    &#125;&#125;\n\n解决方案3：class类实例语法\nclass App extends React.Component &#123;  state = &#123;    msg: &#x27;hello react&#x27;  &#125;//直接注册事件用箭头函数来写  clickFn = () =&gt; &#123;    console.log(this.state.msg)  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;button onClick=&#123;this.clickFn&#125;&gt;点我&lt;/button&gt;      &lt;/div&gt;    )  &#125;&#125;\n\n4.4.setState修改状态​\t组件中的状态是可变的，使用this.setState(&#123;要修改的数据&#125;)来进行修改，并更新UI\nimport React from &#x27;react&#x27;import ReactDOM from &#x27;react-dom&#x27;class App extends React.Component&#123;        state = &#123;            count:0        &#125;        render()&#123;        return (            &lt;div&gt;                &lt;h1&gt;&#123;this.state.count&#125;&lt;/h1&gt;                &lt;div&gt;&#123;this.state.count&#125;&lt;/div&gt;                &lt;button onClick=&#123;this.clickFn&#125;&gt;+1&lt;/button&gt;            &lt;/div&gt;        )    &#125;    clickFn = ()=&gt;&#123;        console.log(this.state.count)        //修改组件状态        this.setState(&#123;count:this.state.count + 1&#125;)            &#125;&#125;ReactDOM.render(&lt;App&gt;&lt;/App&gt;,document.getElementById(&#x27;root&#x27;))\n\n5.表单的处理\n我们在开发过程中，经常需要操作表单元素，比如获取表单的值或者是设置表单的值。\n\nreact中处理表单元素有两种方式：\n\n受控组件\n非受控组件（DOM操作）\n\n5.1受控组件\nHTML中表单元素是可输入的，即表单用户并维护着自己的可变状态（value）。\n\n但是在react中，可变状态通常是保存在state中的，并且要求状态只能通过setState进行修改。\n\nReact中将state中的数据与表单元素的value值绑定到了一起，由state的值来控制表单元素的值\n\n受控组件：value值受到react控制的表单元素\n\n\n\n5.2受控组件使用步骤\n在state中添加一个状态，作为表单元素的value值（控制表单元素的值）\n给表单元素添加onChange事件，设置state的值为表单元素的值（控制值的变化）\n\nclass App extends React.Component&#123;        state = &#123;           msg : &#x27;hello&#x27;        &#125;    render()&#123;        return (            &lt;div&gt;                &lt;h1&gt;受控组件&lt;/h1&gt;                &#123;/*input框的值通过value属性进行控制 */&#125;                &lt;input type=&quot;text&quot; value=&#123;this.state.msg&#125;                 onChange=&#123;this.handleChange&#125; /&gt;            &lt;/div&gt;          )    &#125;    handleChange = (e)=&gt;&#123;        this.setState(&#123;msg:e.target.value&#125;)        console.log(this.state.msg)    &#125;&#125;\n\n5.3常见的受控组件\n文本框、文本域、下拉框（操作value属性）\n复选框（操作checked属性）\n\nimport React from &#x27;react&#x27;import ReactDOM from &#x27;react-dom&#x27;class App extends React.Component &#123;  state = &#123;    username: &#x27;&#x27;,    desc: &#x27;&#x27;,    city:3,    agree:false  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;h1&gt;常见的受控组件&lt;/h1&gt;        &lt;h3&gt;文本框&lt;/h3&gt;        &lt;div&gt;          姓名：          &lt;input            type=&quot;text&quot;            value=&#123;this.state.username&#125;            onChange=&#123;this.changeUsername&#125;          /&gt;        &lt;/div&gt;        &lt;h3&gt;文本域&lt;/h3&gt;        &lt;div&gt;          描述：          &lt;textarea            value=&#123;this.state.desc&#125;            cols=&quot;30&quot;            rows=&quot;10&quot;            onChange=&#123;this.changeDesc&#125;          &gt;&lt;/textarea&gt;        &lt;/div&gt;        &lt;h3&gt;下拉框&lt;/h3&gt;        &lt;div&gt;          选择城市          &lt;select value=&#123;this.state.city&#125; onChange=&#123;this.changeCity&#125;&gt;            &lt;option value=&quot;1&quot;&gt;北京&lt;/option&gt;            &lt;option value=&quot;2&quot;&gt;上海&lt;/option&gt;            &lt;option value=&quot;3&quot;&gt;广州&lt;/option&gt;          &lt;/select&gt;        &lt;/div&gt;        &lt;h3&gt;复选框&lt;/h3&gt;        &lt;div&gt;          是否已经阅读了协议          &lt;input type=&quot;checkbox&quot; checked=&#123;this.state.agree&#125; onChange=&#123;this.changeAgree&#125; /&gt;        &lt;/div&gt;      &lt;/div&gt;    )  &#125;  changeUsername = (e) =&gt; &#123;    this.setState(&#123; username: e.target.value &#125;)  &#125;  changeDesc = (e) =&gt; &#123;    this.setState(&#123; desc: e.target.value &#125;)  &#125;  changeCity = (e) =&gt; &#123;    this.setState(&#123; city: e.target.value &#125;)  &#125;  changeAgree = (e) =&gt; &#123;    this.setState(&#123;agree: e.target.checked&#125;)  &#125;&#125;ReactDOM.render(&lt;App&gt;&lt;/App&gt;, document.getElementById(&#x27;root&#x27;))\n\n5.4多表单元素的优化问题：每个表单元素都需要一个单独的事件处理程序，处理太繁琐\n优化：使用一个事件处理程序处理多个表单元素\n步骤\n\n给表单元素添加name属性，名称与state属性名相同\n根据表单元素类型获取对应的值\n在事件处理程序中通过[name]修改对应的state\n\nimport React from &#x27;react&#x27;import ReactDOM from &#x27;react-dom&#x27;class App extends React.Component &#123;  state = &#123;    username: &#x27;&#x27;,    desc: &#x27;&#x27;,    city:3,    agree:false  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;h1&gt;常见的受控组件&lt;/h1&gt;        &lt;h3&gt;文本框&lt;/h3&gt;        &lt;div&gt;          姓名：          &lt;input            type=&quot;text&quot;            value=&#123;this.state.username&#125;            onChange=&#123;this.handleChange&#125;            name=&quot;username&quot;          /&gt;        &lt;/div&gt;        &lt;h3&gt;文本域&lt;/h3&gt;        &lt;div&gt;          描述：          &lt;textarea            value=&#123;this.state.desc&#125;            cols=&quot;30&quot;            rows=&quot;10&quot;            onChange=&#123;this.handleChange&#125;            name=&quot;desc&quot;          &gt;&lt;/textarea&gt;        &lt;/div&gt;        &lt;h3&gt;下拉框&lt;/h3&gt;        &lt;div&gt;          选择城市          &lt;select value=&#123;this.state.city&#125; onChange=&#123;this.handleChange&#125; name=&quot;city&quot;&gt;            &lt;option value=&quot;1&quot;&gt;北京&lt;/option&gt;            &lt;option value=&quot;2&quot;&gt;上海&lt;/option&gt;            &lt;option value=&quot;3&quot;&gt;广州&lt;/option&gt;          &lt;/select&gt;        &lt;/div&gt;        &lt;h3&gt;复选框&lt;/h3&gt;        &lt;div&gt;          是否已经阅读了协议          &lt;input type=&quot;checkbox&quot; checked=&#123;this.state.agree&#125; onChange=&#123;this.handleChange&#125; name=&quot;agree&quot; /&gt;        &lt;/div&gt;      &lt;/div&gt;    )  &#125;  handleChange = (e) =&gt; &#123;    //1.区分需要修改谁    const &#123; name,type &#125; = e.target    this.setState(&#123;        [name]: type === &#x27;checkbox&#x27; ? e.target.checked : e.target.value    &#125;)  &#125;&#125;ReactDOM.render(&lt;App&gt;&lt;/App&gt;, document.getElementById(&#x27;root&#x27;))\n\n5.5非受控组件\n非受控组件借助于ref，使用原生DOM的方式来获取表单元素的值\n\n使用步骤\n\n调用React.createRef()方法创建一个ref\n\nconstructor() &#123;  super()  this.txtRef = React.createRef()&#125;\n\n\n将创建好的ref对象添加到文本框中\n\n&lt;input type=&quot;text&quot; ref=&#123;this.txtRef&#125;/&gt;\n\n\n通过ref对象获取文本框的值\n\nhandleClick = () =&gt; &#123;    //this.txtRef.current可以找到这个文本框  console.log(this.txtRef.current.value)&#125;\n\nimport React from &#x27;react&#x27;import ReactDOM from &#x27;react-dom&#x27;class App extends React.Component &#123;  txtRef = React.createRef()  state = &#123;&#125;  render() &#123;    return (      &lt;&gt;        &lt;input type=&quot;text&quot; ref=&#123;this.txtRef&#125; /&gt;        &lt;button onClick=&#123;this.clickFn&#125;&gt;获取值&lt;/button&gt;      &lt;/&gt;    )  &#125;  clickFn = ()=&gt;&#123;    console.log(this.txtRef.current.value)  &#125; &#125;ReactDOM.render(&lt;App&gt;&lt;/App&gt;, document.getElementById(&#x27;root&#x27;))\n\n非受控组件用的不多，推荐使用受控组件\n6.组件通讯​\t\t组件是独立且封闭的单元，默认情况下，只能使用组件自己的数据。在组件化过程中，我们将一个完整的功能拆分成多个组件，以更好的完成整个应用的功能。而在这个过程中，多个组件之间不可避免的要共享某些数据。为了实现这些功能，就需要打破组件的独立封闭性，让其与外界沟通。这个过程就是组件通讯。\n​\t\t大白话：一个组件使用另外一个组件的状态\n6.1props\n组件本身是封闭的，但是组件可以通过一个props属性来接受外部的数据\nprops的作用：接受传递给组件的数据\n传递数据：给组件标签添加属性\n接收数据：函数组件通过参数props接收数据，类组件通过this.props接收数据\n\n6.1.1函数组件通讯在父组件里通过属性的方式，把值传到子组件里\n//父组件class App extends React.Component &#123;  render() &#123;    return (      &lt;div&gt;        &lt;h1&gt;这是一个App组件&lt;/h1&gt;        &lt;Demo car=&quot;小黄车&quot; money=&quot;100&quot; check=&#123;true&#125;&gt;&lt;/Demo&gt;      &lt;/div&gt;    )  &#125;&#125;\n子组件通过参数props进行接收，参数支持解构\n//子组件export default function Demo(props)&#123;    console.log(props)    return &lt;div&gt;        &lt;h3&gt;我是Demo组件&lt;/h3&gt;        &lt;div&gt;&#123;props.car&#125;&lt;/div&gt;        &lt;div&gt;&#123;props.money&#125;&lt;/div&gt;        &lt;div&gt;&#123;props.check?&#x27;yes&#x27;:&#x27;no&#x27;&#125;&lt;/div&gt;    &lt;/div&gt;&#125;\n\n6.1.2类组件通讯在父组件里通过属性的方式，把值传到子组件里\nclass App extends React.Component &#123;  render() &#123;    return (      &lt;div&gt;        &lt;h1&gt;这是一个App组件&lt;/h1&gt;        &lt;Demo car=&quot;小黄车&quot; money=&quot;100&quot; check=&#123;true&#125;&gt;&lt;/Demo&gt;        &lt;Hello car=&quot;小黄车&quot; money=&quot;100&quot; check=&#123;true&#125;&gt;&lt;/Hello&gt;      &lt;/div&gt;    )  &#125;&#125;\n\n子组件直接使用this.props\nclass Hello extends Component&#123;    render()&#123;        return &lt;div&gt;            &lt;p&gt;这是Hello组件&lt;/p&gt;            &lt;div&gt;&#123;this.props.car&#125;&lt;/div&gt;            &lt;div&gt;&#123;this.props.money&#125;&lt;/div&gt;            &lt;div&gt;&#123;this.props.check?&#x27;yes&#x27;:&#x27;no&#x27;&#125;&lt;/div&gt;        &lt;/div&gt;    &#125;&#125;\n\n\n\n6.1.3props的特点\n可以给组件传递任意类型的数据\nprops是只读的，不允许修改props的数据。父组件的数据变了，子组件的数据也会更新。\n注意：在类组件中使用的时候，**需要把props传递给super()**，否则构造函数无法获取到props\n\nclass Hello extends React.Component &#123;    constructor(props) &#123;        // 推荐将props传递给父类构造函数        super(props)    &#125;    render() &#123;    \treturn &lt;div&gt;接收到的数据：&#123;this.props.age&#125;&lt;/div&gt;    &#125;&#125;\n\n6.1.4props的children属性写到标签中间的内容就是children\n\nchildren属性：表示该组件的子节点，只要组件有子节点，props就有该属性\nchildren 属性与普通的props一样，值可以是任意值（文本、React元素、组件，甚至是函数）\n\n//写在中间的&lt;Hello&gt;首页&lt;/Hello&gt; function Hello(props) &#123;  return (    &lt;div&gt;      该组件的子节点：&#123;props.children&#125;    &lt;/div&gt;  )&#125;&lt;Hello&gt;我是子节点&lt;/Hello&gt;\n\n6.1.5props校验目的：校验接收的props的数据类型，把错误提示的更明显\n对于组件来说，props是外来的，无法保证组件使用者传入什么格式的数据，如果传入的数据格式不对，可能会导致组件内部报错。组件的使用者不能很明确的知道错误的原因。\n使用步骤：\n\n安装包 prop-types （yarn add prop-types &#x2F; npm i props-types）\n导入 prop-types\n组件名.propTypes &#x3D; {} 来给组件的props添加校验规则\n校验规则通过 PropTypes 对象来指定\n\nimport PropTypes from &#x27;prop-types&#x27;function App(props) &#123;    return (    \t&lt;h1&gt;Hi, &#123;props.colors&#125;&lt;/h1&gt;    )&#125;App.propTypes = &#123;    // 约定colors属性为array类型    // 如果类型不对，则报出明确错误，便于分析错误原因    colors: PropTypes.array&#125;\n\n约束规则\n\n常见类型：array、bool、func、number、object、string\nReact元素类型：element\n必填项：isRequired\n特定结构的对象：shape({ })\n\n// 常见类型optionalFunc: PropTypes.func,// 必选requiredFunc: PropTypes.func.isRequired,// 特定结构的对象optionalObjectWithShape: PropTypes.shape(&#123;\tcolor: PropTypes.string,\tfontSize: PropTypes.number&#125;)\n\n6.1.6props默认值function App(props) &#123;    return (        &lt;div&gt;            此处展示props的默认值：&#123;props.pageSize&#125;        &lt;/div&gt;    )&#125;// 默认值App.defaultProps = &#123;\tpageSize: 10&#125;// 不传入pageSize属性&lt;App /&gt;\n\n补充：类的静态属性class Person&#123;    name = &quot;&#x27;zs&#x27;,\tstatic age = 18\tsayHi()&#123;        console.log(&#x27;Hi&#x27;)    &#125;\tstatic sayBye()&#123;        console.log(&#x27;bye&#x27;)    &#125;&#125;const p = new Person()console.log(p.name)p.sayHi()console.log(Person.age)Person.sayBye()\n\n6.2组件通讯6.2.1父传子\n父组件的state对象提供数据\n父组件中给子组件的标签添加属性，值为state中的数据\n子组件通过props接受父组件中传递的数据\n\n//父组件import React from &#x27;react&#x27;import ReactDOM from &#x27;react-dom&#x27;import Child from &#x27;./18父传子_子&#x27;class Father extends React.Component &#123;  state = &#123;    wife:&#x27;&#x27;  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;h1&gt;我是父组件&lt;/h1&gt;        &lt;div&gt;          配偶：          &lt;input type=&quot;text&quot;            placeholder=&#x27;请输入配偶的名字&#x27;           value=&#123;this.state.wife&#125;          onChange=&#123;this.handleChange&#125;/&gt;        &lt;/div&gt;        &lt;hr /&gt;        &lt;Child mama=&#123;this.state.wife&#125;&gt;&lt;/Child&gt;      &lt;/div&gt;    )      &#125;  handleChange = (e)=&gt;&#123;    this.setState(&#123;wife:e.target.value&#125;)  &#125;&#125;ReactDOM.render(&lt;Father&gt;&lt;/Father&gt;, document.getElementById(&#x27;root&#x27;))\n\n//子组件export default function Child(props)&#123;  return(    &lt;div&gt;      &lt;h3&gt;我是子组件&lt;/h3&gt;      &lt;div&gt;妈妈的名字：&#123;props.mama&#125;&lt;/div&gt;    &lt;/div&gt;  )&#125;\n\n\n\n6.2.2子传父\n父组件提供一个回调函数（用于接收数据），将该函数作为属性的值，传递给子组件\n子组件通过 props 调用回调函数，将子组件的数据作为参数传递给回调函数\n\n//父组件import React from &#x27;react&#x27;import ReactDOM from &#x27;react-dom&#x27;import Child from &#x27;./19子传父_子.js&#x27;class Father extends React.Component &#123;    state = &#123;      wife:&#x27;&#x27;,      sonwife:&#x27;&#x27;    &#125;    render() &#123;      return (        &lt;div&gt;          &lt;h1&gt;我是父组件&lt;/h1&gt;          &lt;div&gt;            配偶：            &lt;input type=&quot;text&quot;              placeholder=&#x27;请输入配偶的名字&#x27;             value=&#123;this.state.wife&#125;            onChange=&#123;this.handleChange&#125;/&gt;          &lt;/div&gt;          &lt;div&gt;            儿媳妇：&#123;this.state.sonwife&#125;          &lt;/div&gt;          &lt;hr /&gt;          &lt;Child wife=&#123;this.state.wife&#125; changeName=&#123;this.changeName&#125;&gt;&lt;/Child&gt;        &lt;/div&gt;      )          &#125;    handleChange = (e)=&gt;&#123;      this.setState(&#123;wife:e.target.value&#125;)    &#125;    changeName = (name)=&gt;&#123;      this.setState(&#123;sonwife:name&#125;)    &#125;  &#125;  ReactDOM.render(&lt;Father&gt;&lt;/Father&gt;, document.getElementById(&#x27;root&#x27;))  \n\n//子组件import &#123; Component &#125; from &quot;react&quot;export default class Child extends Component&#123;    state=&#123;        wife:&quot;&quot;    &#125;    render()&#123;        return (            &lt;div&gt;                &lt;h3&gt;我是子组件&lt;/h3&gt;                &lt;div&gt;妈妈的名字：&#123;this.props.wife&#125;&lt;/div&gt;                &lt;div&gt;                    配偶的名字：                    &lt;input type=&quot;text&quot; value=&#123;this.state.wife&#125;                     onChange=&#123;this.handleChange &#125;/&gt;                &lt;/div&gt;            &lt;/div&gt;        )    &#125;    handleChange = (e)=&gt;&#123;        this.setState(&#123;wife:e.target.wife&#125;)        this.props.changeName(e.target.value)    &#125;&#125;\n\n6.2.3兄弟组件通讯​\t兄弟组件通讯的核心思想是状态提升，将共享状态放到到最近的公共父组件中，由父组件管理这个状态\n\n父组件职责：\n提供共享状态\n提供操作共享状态的方法\n\n\n要通讯的子组件只需通过props接受状态或操作状态的方法\n\n\n6.2.4Context跨级组件通讯 \n​\t需要跨级组件传递时，如果使用props一层一层向下传递非常繁琐，推荐使用Context\n实现\n\nindex调用 React. createContext() 创建 Provider（提供数据） 和 Consumer（消费数据） 两个组件。\n\nconst &#123; Provider,Consumer &#125; = React.createContext()export &#123;Consumer&#125;\n\n\nindex使用 Provider 包裹根元素，这样Provider就是最大的根元素。\n\n&lt;Provider value=&#123;this.state.color&#125;&gt;\t&lt;div&gt;\t\t&lt;h1&gt;APP组件&lt;/h1&gt;\t\t&lt;Father&gt;&lt;/Father&gt;\t&lt;/div&gt;&lt;/Provider&gt;\n\n\n设置 value 属性，表示要传递的数据。\n\n&lt;Provider value=&#123;this.state.color&#125;&gt;\n\n\n孙组件调用 Consumer 组件接收数据。\n\n&lt;Consumer&gt;\t&#123;(value) =&gt;    \t \t&lt;div&gt;    \t\t&lt;h3&gt;我是孙组件&#123;value&#125;&lt;/h3&gt;    \t&lt;/div&gt;\t&#125;&lt;/Consumer&gt;\n\n总结：\n\n如果两个组件是远方亲戚（比如，嵌套多层）可以使用Context实现组件通讯\nContext提供了两个组件：Provider 和 Consumer\nProvider组件：用来提供数据\nConsumer组件：用来消费数据\n\n7.组件的生命周期7.1概述​\t组件的生命周期：组件从被创建到挂载到页面中运行，再到组件不用时卸载的过程\n​\t钩子函数的作用：为开发人员在不同阶段操作组件提供了时机\n\n只有 类组件 才有 生命周期(函数组件没有生命周期)\n\n\nhttp://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\n7.2挂载阶段执行时机：组件创建时（页面加载时）\n执行顺序：\n\n\n\n\n钩子 函数\n触发时机\n作用\n\n\n\nconstructor\n创建组件时，最先执行\n1. 初始化state  2. 创建Ref等3.绑定this指向\n\n\nrender\n每次组件渲染都会触发\n渲染UI（注意： 不能调用setState() ）\n\n\ncomponentDidMount\n组件挂载（完成DOM渲染）后\n1. 发送网络请求   2.DOM操作\n\n\n7.3更新阶段\n执行时机：1. setState() 2. forceUpdate() 3. 组件接收到新的props\n说明：以上三者任意一种变化，组件就会重新渲染\n执行顺序\n\n\n\n\n\n钩子函数\n触发时机\n作用\n\n\n\nrender\n每次组件渲染都会触发\n渲染UI（与 挂载阶段 是同一个render）\n\n\ncomponentDidUpdate\n组件更新（完成DOM渲染）后\nDOM操作，可以获取到更新后的DOM内容（注意： 不能调用setState() ）\n\n\n7.4卸载阶段\n执行时机：组件从页面中消失\n\n\n\n\n钩子函数\n触发时机\n作用\n\n\n\ncomponentWillUnmount\n组件将要卸载（从页面中消失）\n执行清理工作，资源释放（比如：清理定时器等）\n\n\n8.setState()8.1更新数据\nsetState()修改数据是异步更新数据的\n\n当你调用 setState() 的时候，React.js 并不会马上修改 state,而是把这个对象放到一个更新队列里面,稍后才会从队列当中把新的状态提取出来合并【覆盖】到 state 当中，然后再触发组件更新\n\n多次调用 setState()只会触发一次重新渲染,所以后面的setState()不能依赖前面的，因为会覆盖掉。\n在使用 React.js 的时候，并不需要担心多次进行 setState 会带来性能问题。\n\nthis.setState(&#123;    count:this.state.count + 1&#125;)this.setState(&#123;    count:this.state.count + 1&#125;)this.setState(&#123;    money:200&#125;)this.setState(&#123;    count:this.state.count + 4&#125;)//相当于this.setState(&#123;    count:this.state.count + 4,    money:200&#125;)\n\n8.2推荐使用的setState语法\n推荐：使用 setState((preState) =&gt; &#123;&#125;) 语法\n\n参数preState: React.js 会把上一个 setState 的结果传入这个函数\n\n\nthis.setState((preState) =&gt; &#123;    return &#123;    \tcount: preState.count + 1    &#125;&#125;)console.log(this.state.count) // 1\n\n这种语法依旧是异步的，但是state可以获取到最新的状态，适用于需要调用多次setState。不会覆盖掉上面的\n8.2.3setState的第二个参数\n场景：在状态更新（页面完成重新渲染）后立即执行某个操作。因为setState是异步的，会先执行下面的函数再执行setState,但是用这种方式可以先修改state再执行回调函数\n语法：setState(updater[, callback])\n\nthis.setState(\t(state) =&gt; (&#123;&#125;),//第一个参数\t() =&gt; &#123;console.log(&#x27;这个回调函数会在状态更新后立即执行&#x27;)&#125;//第二个参数。会立即执行)\n\nthis.setState(\t(state, props) =&gt; &#123;&#125;,\t() =&gt; &#123;\t\tdocument.title = &#x27;更新state后的标题：&#x27; + this.state.count\t&#125;)\n9.组件性能优化9.1组件更新机制\nsetState() 的两个作用： 1. 修改 state 2. 更新组件（UI）\n\n过程：父组件重新渲染时，也会重新渲染子组件。但只会渲染当前组件子树（当前组件及其所有子组件）\n\n\n\n9.2减轻state\n减轻 state：只存储跟组件渲染相关的数据（比如：count &#x2F; 列表数据 &#x2F; loading 等）\n注意：不用做渲染的数据不要放在 state 中，比如定时器 id等 \n对于这种需要在多个方法中用到的数据，应该直接放在 this 中 \nthis.xxx &#x3D; ‘bbb’\nthis.xxx\n\n\n\nclass Hello extends Component &#123;    componentDidMount() &#123;        // timerId存储到this中，而不是state中        this.timerId = setInterval(() =&gt; &#123;&#125;, 2000)    &#125;    componentWillUnmount() &#123;    \tclearInterval(this.timerId)    &#125;    render() &#123; … &#125;&#125;\n\n9.3避免不必要的重新渲染\n组件更新机制：父组件更新会引起子组件也被更新，这种思路很清晰\n\n问题：子组件没有任何变化时也会重新渲染 （接收到的props没有发生任何的改变）\n\n解决方式：使用钩子函数 shouldComponentUpdate(nextProps, nextState)\n\n作用：通过返回值决定该组件是否重新渲染，返回 true 表示重新渲染，false 表示不重新渲染\n\n触发时机：更新阶段的钩子函数，组件重新渲染前执行 （shouldComponentUpdate &#x3D;&gt; render）\n\n\n//nextProps即将要更新的props；nextState即将要更新的组件自己的stateshouldComponentUpdate(nextProps)&#123;    if(this.props.money === nextProps.money)&#123;        return false    &#125;else&#123;        return true    &#125;&#125;\n\n9.4纯组件\n纯组件：React.PureComponent 与 React.Component 功能相似\n区别：PureComponent 内部自动实现了 shouldComponentUpdate 钩子，不需要手动比较，只要state和props发生变化，就不会重新渲染\n原理：纯组件内部通过分别 对比 前后两次 props 和 state 的值，来决定是否重新渲染组件\n\nclass Hello extends React.PureComponent &#123;    render() &#123;        return (        \t&lt;div&gt;纯组件&lt;/div&gt;        )    &#125;&#125;\n\n9.5纯组件比较-值类型\n说明：纯组件内部的对比是 shallow compare（浅层对比）\n\n对于值类型来说：比较两个值是否相同（直接赋值即可，没有坑）\n\n\nlet number = 0let newNumber = numbernewNumber = 2console.log(number === newNumber) // false\n\nstate = &#123; number: 0 &#125;setState(&#123;  number: Math.floor(Math.random() * 3)&#125;)// PureComponent内部对比：最新的state.number === 上一次的state.number // false，重新渲染组件\n\n9.6纯组件比较-引用类型\n说明：纯组件内部的对比是 shallow compare（浅层对比）\n对于引用类型来说：只比较对象的引用（地址）是否相同\n\nconst obj = &#123; number: 0 &#125;const newObj = objnewObj.number = 2console.log(newObj === obj) // true\n\n\n\nstate = &#123; obj: &#123; number: 0 &#125; &#125;// 错误做法state.obj.number = 2setState(&#123; obj: state.obj &#125;)// PureComponent内部比较：最新的state.obj === 上一次的state.obj // true，不重新渲染组件\n\n纯组件的最佳实践：\n 注意：state 或 props 中属性值为引用类型时，应该创建新数据，不要直接修改原数据！\n// 正确！创建新数据const newObj = &#123;...state.obj, number: 2&#125;setState(&#123; obj: newObj &#125;)// 正确！创建新数据// 不要用数组的push / unshift 等直接修改当前数组的的方法// 而应该用 concat 或 slice 等这些返回新数组的方法this.setState(&#123;\tlist: [...this.state.list, &#123;新数据&#125;]&#125;)\n\n10.React路由10.1单页应用程序\nSPA： Single Page Application  单页面应用程序，整个应用中只有一个页面（index.html）\nMPA : Multiple Page Application多页面应用程序，整个应用中有很多个页面（*.html）\n\n网易云音乐就是单页面应用程序。\n优势：\n\n加快页面响应速度，降低了对服务器的压力\n传统的多页面应用程序，每次请求服务器返回的都是一整个完整的页面\n单页面应用程序只有第一次会加载完整的页面，以后每次请求仅获取必要的数据\n\n\n更好的用户体验，运行更加流畅\n\n缺点：\n\n不利于 SEO 搜索引擎优化 \n因为 爬虫 只爬取 HTML 页面中的文本内容，不会执行 JS 代码\n可以通过 SSR（服务端渲染 Server Side Rendering）来解决 SEO 问题\n解释：先在服务器端把内容渲染出来，然后，返回给浏览器的就是纯 HTML 内容了\n\n\n页面静态化，比如，对于一个电商应用可以为每一个商品生产一个静态的HTML页面，静态 HTML 页面中是带有文字内容的，所以，有利于 SEO 的\n\n\n\n10.2React路由介绍​\t现代的前端应用大多都是 SPA（单页应用程序），为了有效的使用单个页面来管理原来多页面的功能，前端路由应运而生。前端路由的功能：让用户从一个视图（页面）导航到另一个视图（页面）\n\n前端路由是一套映射规则，在React中，是 URL路径 与 组件 的对应关系 ，简单来说就是：配置路径和组件（配对）\n\n\n模拟实现单页面\nimport React from &#x27;react&#x27;import ReactDOM from &#x27;react-dom&#x27;import Home from &#x27;./pages/Home&#x27;import Friend from &#x27;./pages/Friend&#x27;import My from &#x27;./pages/My&#x27;class App extends React.PureComponent &#123;  state = &#123;    currentHash:&#x27;&#x27;  &#125;  //hashchange事件：锚点值(hash)值改变触发  //当componentDidMount()页面渲染好了，就可以注册事件  componentDidMount()&#123;    //注册事件    window.addEventListener(&#x27;hashchange&#x27;,() =&gt; &#123;      console.log(&#x27;hash值变了&#x27;,window.location.hash)      this.setState(&#123;currentHash: window.location.hash.slice(1)&#125;)    &#125;)  &#125;  render() &#123;    const&#123;currentHash&#125; = this.state    return (        &lt;div&gt;          &lt;h1&gt;App组件&lt;/h1&gt;          &lt;ul&gt;            &lt;li&gt;&lt;a href=&quot;#/home&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;#/my&quot;&gt;我的音乐&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;#/friend&quot;&gt;我的朋友&lt;/a&gt;&lt;/li&gt;          &lt;/ul&gt;        //如果currentHash === &#x27;/home&#x27; 则渲染 &lt;Home&gt;&lt;/Home&gt;          &#123;currentHash === &#x27;/home&#x27; &amp;&amp; &lt;Home&gt;&lt;/Home&gt;&#125;          &#123;currentHash === &#x27;/my&#x27; &amp;&amp; &lt;My&gt;&lt;/My&gt;&#125;          &#123;currentHash === &#x27;/friend&#x27; &amp;&amp; &lt;Friend&gt;&lt;/Friend&gt;&#125;                                      &lt;/div&gt;    )  &#125;&#125;ReactDOM.render(&lt;App&gt;&lt;/App&gt;, document.getElementById(&#x27;root&#x27;))\n\n10.3路由的基本使用https://reactrouter.com\n针对react-router5的版本\n\n安装react-router-dom\n\nyarn add react-router-dom\n\n导入react-router-dom提供的 HashRouter, Route, Link\n\nimport &#123; HashRouter, Route, Link &#125; from &#x27;react-router-dom&#x27;\n\n\n使用HashRouter包裹整个应用\n\n&lt;Router&gt;    &lt;div className=&quot;App&quot;&gt;    // … 省略页面内容    &lt;/div&gt;&lt;/Router&gt;\n\n\n使用Link替换a链接，指定导航链接\n\n&lt;Link to=&quot;/first&quot;&gt;页面一&lt;/Link&gt;&lt;Link to=&quot;/two&quot;&gt;页面二&lt;/Link&gt;\n\n\n使用Route指定路由规则\n\n// 在哪里写的Route,最终匹配到的组件就会渲染到这&lt;Route path=&quot;/first&quot; component=&#123;First&#125;&gt;&lt;/Route&gt;\n\n10.3.1详细说明\nRouter 组件：包裹整个应用，一个 React 应用只需要使用一次\n两种常用 Router：HashRouter 和 BrowserRouter  \nHashRouter：使用 URL 的哈希值实现（http://localhost:3000/#/first）\n原理：监听 window 的 hashchange 事件来实现的\n\n\n（推荐）BrowserRouter：使用 H5 的 history API 实现（http://localhost:3000/first）\n原理：监听 window 的 popstate 事件来实现的\n\n\n\n**地址栏要#就用HashRouter，不要#就用BrowserRouter\n可以在导入的时候重命名\nimport &#123; HashRouter as Router, Route, Link &#125; from &#x27;react-router-dom&#x27;\n\n10.3.2路由的执行过程\n点击 Link 组件（a标签），修改了浏览器地址栏中的 url\nReact 路由监听到地址栏 url 的变化  (hashChange&#x2F; popState)\nReact 路由内部遍历所有 Route 组件，使用路由规则（path）与 pathname（hash）进行匹配\n当路由规则（path）能够匹配地址栏中的 pathname（hash） 时，就展示该 Route 组件的内容\n\n10.4Link与NavLinkLink组件最终会渲染成a标签，用于指定路由导航\n\nto属性，将来会渲染成a标签的href属性\n但是Link组件无法实现导航的高亮效果\n\nNavLink组件，一个更特殊的Link组件，可以用用于指定当前导航高亮\n\n点击Navlink之后当前点击的链接会自动添加一个类名为active，css中给active类设置样式\n\n\nto属性，用于指定地址，会渲染成a标签的href属性\nactiveClass: 用于指定高亮的类名，默认active,如下设置成aa后，在css中aa类设置样式\nexact: 精确匹配，表示必须精确匹配类名才生效。有时为了简便，首页就是一个/，模糊匹配时点别的也会高亮，用精确匹配就不会\n\n&lt;NavLink to=&quot;/friend&quot; activeClass=&quot;aa&quot; exact&gt;我的朋友&lt;/NavLink&gt;\n\n10.5Route\npath 的说明\n如果path指定为/，所有/开头的都可以被匹配\n如果 path 的路径匹配上了，那么就可以对应的组件就会被 render。如果 path 没有匹配上，那么会 render null\n如果path不写，能够匹配所有的匹配，一定会被渲染\n\n\nexact 的说明， exact 表示精确匹配某个路径\n一般来说，如果路径配置了 &#x2F;， 都需要配置 exact 属性\n\n\n\n10.6Switch与404错误提示页面\nSwitch作用：如果将来能够匹配到多个路由规则，只会让第一个渲染出来\n\n\n通常，我们会把Route包裹在一个Switch组件中\n\n通过Switch组件非常容易的就能实现404错误页面的提示（写个404页面放在最后一个Route,不写path）\n\n\n&lt;Switch&gt;  &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125;/&gt;  &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;  &lt;Route path=&quot;/user&quot; component=&#123;User&#125;/&gt;  &lt;Route component=&#123;NoMatch&#125;/&gt;&lt;/Switch&gt;\n\n10.7嵌套路由的配置\n在React中，配置嵌套路由非常的简单，因为Route就是一个组件，可以在任意想配置的地方进行配置\n在组件中依旧可以使用Link指定子路由的链接，Route指定子路由的规则，不用再使用Router组件\n但是配置嵌套路由的时候，二级路由的path必须包含一级路由，必须要先匹配到父级路由，才能匹配到子路由\n\n// 通过/home可以匹配Home父组件  再通过/list匹配子组件&lt;Route path=&quot;/home/list&quot; component=&#123;List&#125; /&gt;\n\n10.8Redirect重定向&lt;Redirect exact from=&#x27;/&#x27; to=&#x27;/home&#x27;&gt;&lt;/Redirect&gt;\n\n如果地址是&#x2F;，需要重定向直接跳到&#x2F;home去，注意：一旦用到&#x2F;，要用exact\n10.9编程式导航\n场景：点击登录按钮，登录成功后，通过代码跳转到后台首页\n编程式导航：通过 JS 代码来实现页面跳转\nhistory 是 React 路由提供的，用于获取浏览器历史记录的相关信息，通过prop获取history这个对象\npush(path)：跳转到某个页面，参数 path 表示要跳转的路径\ngo(n)： 前进或后退到某个页面，参数 n 表示前进或后退页面数量（比如：-1 表示后退到上一页）\n\nclass Login extends Component &#123;    handleLogin = () =&gt; &#123;        // ...        this.props.history.push(&#x27;/home&#x27;)        this.props.history.go(-1)    &#125;    render() &#123;...省略其他代码&#125;&#125;\n\n10.10动态路由与路由参数获取\n可以使用:id的方式来配置动态的路由参数\n\n// 可以匹配 /users/1  /users/2  /users/xxx&lt;Route path=&quot;/users/:id&quot; component=&#123;Users&#125; /&gt;\n\n\n在组件中，通过props.match.params.id可以接收到地址栏的id\n\nrender()&#123;    console.log(this.props.match.params)&#125;\n\n11.Ant Design组件库&#96;&#96;antd&#96; 是基于 Ant Design 设计体系的 React UI 组件库，主要用于研发企业级中后台产品。\n\n安装\n\nnpm install antd --save\n\n\n导入全局样式\n\nimport &#x27;antd/dist/antd.css&#x27;\n\n\n导入组件\n\nimport &#123; DatePicker &#125; from &#x27;antd&#x27;;ReactDOM.render(&lt;DatePicker /&gt;, mountNode\n\n12. React组件复用12.1组件复用说明​\t如果两个组件中的部分功能相似或相同，复用相似的功能。把逻辑复用起来，但是组件渲染的内容不同。\n\n三种解决方案\nrender-props\nHOC（高阶组件）\nmixins(Vue还在使用，React已经废弃)\n\n\n注意：这两种方式不是新的API，而是利用React自身特点的编码技巧，演化而成的固定模式（写法）\n\n12.2render-props使用需求：现在有一个App组件，在App组件中，需要渲染\n\n猫组件：跟着鼠标跑\n位置组件：显示当前鼠标的位置\n\n\t\n此时，猫组件和位置组件的逻辑相同，我们定义一个新组件\n\n鼠标组件：用于提供逻辑。该组件将来可能用于渲染Cat组件和位置组件，所以渲染的是不确定的,所以render可以直接返回一个属性children。因为无论是猫组件还是位置组件无非用到鼠标组件的state，所以this.state作为参数传过去\n\nrender()&#123;    return this.props.render(this.state)&#125;\n\n//鼠标组件import React, &#123; Component &#125; from &#x27;react&#x27;export default class index extends Component &#123;  state = &#123;    x: 0,    y: 0,  &#125;  move = (e) =&gt; &#123;    console.log(e.pageX, e.pageY)    this.setState(&#123;      x: e.pageX,      y: e.pageY,    &#125;)  &#125;  componentDidMount() &#123;    document.addEventListener(&#x27;mousemove&#x27;, this.move)  &#125;  componentWillUnmount() &#123;    document.removeEventListener(&#x27;mousemove&#x27;, this.move)  &#125;  render() &#123;    return this.props.children(this.state)  &#125;&#125;\n\n因为鼠标组件需要一个children属性，所以在App组件传一个children进去，children为一个函数，该函数可以传一个Cat组件进去\n//APP组件import React from &quot;react&quot;;import  ReactDOM  from &quot;react-dom&quot;;import Cat from &#x27;./Cat&#x27;import Position from &#x27;./Position&#x27;import Mouse from &#x27;./Mouse&#x27;class App extends React.Component &#123;  render() &#123;    return (      &lt;div&gt;        //解构一个x,y        &lt;Mouse&gt;&#123;(&#123;x,y&#125;) =&gt; &#123;&lt;Cat x=&#123;x&#125; y=&#123;y&#125;&gt;&lt;/Cat&gt;&#125;&#125;&lt;/Mouse&gt;      &lt;/div&gt;    )  &#125;&#125;ReactDOM.render(&lt;App&gt;&lt;/App&gt;, document.getElementById(&#x27;root&#x27;))\n\nCat组件直接从this.props拿x和y\nimport React, &#123; Component &#125; from &#x27;react&#x27;export default class Cat extends Component &#123;  render() &#123;    return (      &lt;img src=&#123;img&#125; alt=&quot;&quot; style=&#123;&#123;left:this.props.x,top:this.props.y&#125;&#125; /&gt;    )  &#125; &#125;\n\n12.3高阶组件  HOC higher order component​\t目的：实现状态逻辑复用   增强一个组件的能力。高阶组件就相当于手机壳，通过包装组件，增强组件功能\n\n高阶组件（HOC，Higher-Order Component）是一个函数，参数接收要包装的组件，返回增强的组件\n高阶组件的命名： withXXXxxx表示一个能力\n高阶组件内部创建一个类组件，在这个类组件中提供复用的状态逻辑代码，通过prop将复用的状态传递给被包装组件\n\n//高阶组件，参数：接受一个普通的组件export default function withMouse(Base)&#123;    class Mouse extends React.Component&#123;        // 处理鼠标的位置等逻辑        render()&#123;            return &lt;Base&#123;...this.state&#125;&gt;&lt;/BigBase&#123;...this.state&#125;&gt;        &#125;    &#125;    return Mouse&#125;\n\nimport withMouse from &#x27;./withMouse&#x27;const CatWithMouse = withMouse(Cat)&lt;CatWithMouse&gt;&lt;CatWithMouse/&gt;\n\n注意：\n使用高阶组件可能出现props丢失的现象，因为高阶组件没有往下传递props\n解决方法：渲染 时，将 state 和 this.props 一起传递给组件\n&lt;Base &#123;...this.state&#125; &#123;...this.props&#125; /&gt;\n\n13.Hooks13.1React Hooks 介绍13.1.1Hooks 是什么\nHooks：钩子、钓钩、钩住；是 React v16.8 中的新增功能\n作用：为函数组件提供状态、生命周期等原本 class 组件中提供的 React 功能 \n注意：Hooks 只能在函数组件中使用，自此，函数组件成为 React 的新宠儿\n\n13.1.2组件开发模式的对比\nReact v16.8 以前： class 组件(提供状态) + 函数组件(展示内容)\nReact v16.8 及其以后：\nclass 组件(提供状态) + 函数组件(展示内容)\nHooks(提供状态) + 函数组件(展示内容)\n混用以上两种方式：部分功能用 class 组件，部分功能用 Hooks+函数组件\n\n\n\n注意1：虽然有了 Hooks，但 React 官方并没有计划从 React 库中移除 class。注意2：有了 Hooks 以后，不能再把函数组件称为无状态组件了，因为 Hooks 为函数组件提供了状态。\n13.1.3为什么要有 Hooks两个角度：1 组件的状态逻辑复用 2 class 组件自身的问题\n\n组件的状态逻辑复用：\n在 Hooks 之前，组件的状态逻辑复用经历了：mixins（混入）、HOCs（高阶组件）、render-props 等模式。\n（早已废弃）mixins 的问题：1 数据来源不清晰 2 命名冲突。\nHOCs、render-props 的问题：重构组件结构，导致组件形成 JSX 嵌套地狱问题。\n\n\nclass 组件自身的问题：\n选择：函数组件和 class 组件之间的区别以及使用哪种组件更合适\n需要理解 class 中的 this 是如何工作的\n相互关联且需要对照修改的代码被拆分到不同生命周期函数中\ncomponentDidMount -&gt;  window.addEventListener(‘resize’, this.fn)\ncomponentWillUnmount -&gt; window.addEventListener(‘resize’, this.fn)\n\n\n\n\n\n\n相比于函数组件来说，不利于代码压缩和优化，也不利于 TS 的类型推导\n\n正是由于 React 原来存在的这些问题，才有了 Hooks 来解决这些问题\n13.1.4hooks的优势由于原来 React 中存在的问题，促使 React 需要一个更好的自带机制来实现组件状态逻辑复用。\n\nHooks 只能在函数组件中使用，避免使用class 组件的问题\n复用组件状态逻辑，而无需更改组件层次结构\n根据功能而不是基于生命周期方法强制进行代码分割\n抛开 React 赋予的概念来说，Hooks 就是一些普通的函数\n具有更好的 TS  类型推导\ntree- - shaking  友 好，打包时去掉未引用的代码\n更好的压缩\n\n项目开发中，Hooks 的采用策略：\n\n不推荐直接使用 Hooks 大规模重构现有组件\n推荐：新功能用 Hooks，复杂功能实现不了的，也可以继续用 class\n找一个功能简单、非核心功能的组件开始使用 hooks\n\n13.1.5前面的 React 知识是有用的class 组件相关的 API 不用了，比如：\n\nclass Hello extends Component\ncomponentDidMount、componentDidUpdate、componentWillUnmount\nthis 相关的用法\n\n原来学习的内容还是要用的，比如：\n\nJSX：&#123;&#125;、onClick=&#123;handleClick&#125;、条件渲染、列表渲染、样式处理等\n组件：函数组件、组件通讯\n路由\nReact 开发理念：单向数据流、状态提升 等\n解决问题的思路、技巧、常见错误的分析等上\n\n13.2useState Hook13.2.1useState Hook 的基本使用\n使用场景：当你想要在函数组件中，使用组件状态时，就要使用 useState Hook 了\n作用：为函数组件提供状态（state）\n使用步骤：\n导入 useState 函数\n调用 useState 函数，并传入状态的初始值\n从 useState 函数的返回值中，拿到状态和修改状态的函数\n在 JSX 中展示状态\n在按钮的点击事件中调用修改状态的函数，来更新状态\n\n\n\n//1.导入 `useState` 函数import React ,&#123;useState&#125;from &#x27;react&#x27;import ReactDOM from &#x27;react-dom&#x27;function App ()&#123;//2.调用 `useState` 函数，并传入状态的初始值    //useState()参数，意思是初始值    //返回值：是一个数组，长度为2    //下标0：就是这个状态    //下标1：修改这个状态的函数//3.从 `useState` 函数的返回值中，拿到状态和修改状态的函数    const [count,setCount] = useState(0)    return(        &lt;div&gt;            &lt;h3&gt;我是根组件&lt;/h3&gt;            &lt;div&gt;我点击了&#123;count&#125;次&lt;/div&gt;//4.在按钮的点击事件中调用修改状态的函数，来更新状态            &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;&lt;/button&gt;        &lt;/div&gt;    )&#125;ReactDOM.render(&lt;App&gt;&lt;/App&gt;,document.getElementById(&#x27;root&#x27;))\n\n\n参数：状态初始值。比如，传入 0 表示该状态的初始值为 0\n\n注意：此处的状态可以是任意值（比如，数值、字符串等），而 class 组件中的 state 必须是对象\n\n\n返回值：数组，包含两个值：1 状态值（state） 2 修改该状态的函数（setState）\n\n使用数组解构简化 useState 的使用\n\n约定：修改状态的函数名称以 set 开头，后面跟上状态的名称\n\n\n\n// 解构出来的名称可以是任意名称const [state, setState] = useState(0)const [age, setAge] = useState(0)const [count, setCount] = useState(0)\n\n13.2.2状态的读取和修改状态的使用：1 读取状态 2 修改状态\n\n读取状态：该方式提供的状态，是函数内部的局部变量，可以在函数内的任意位置使用\n修改状态：\n\n\nsetCount(newValue) 是一个函数，参数表示：新的状态值\n调用该函数后，将使用新的状态值替换旧值\n修改状态后，因为状态发生了改变，所以，该组件会重新渲染\n\n13.2.3组件的更新过程函数组件使用 useState hook 后的执行过程，以及状态值的变化： \n\n组件第一次渲染：\n从头开始执行该组件中的代码逻辑\n调用 useState(0) 将传入的参数作为状态初始值，即：0\n渲染组件，此时，获取到的状态 count 值为： 0\n\n\n组件第二次渲染：\n点击按钮，调用 setCount(count + 1) 修改状态，因为状态发生改变，所以，该组件会重新渲染\n组件重新渲染时，会再次执行该组件中的代码逻辑\n再次调用 useState(0)，此时 React 内部会拿到最新的状态值而非初始值，比如，该案例中最新的状态值为 1\n再次渲染组件，此时，获取到的状态 count 值为：1\n\n\n\n注意：useState 的初始值(参数)只会在组件第一次渲染时生效。 \n也就是说，以后的每次渲染，useState 获取到都是最新的状态值。React 组件会记住每次最新的状态值!\n12.3.4为函数组件添加多个状态问题：如果一个函数组件需要多个状态，该如何处理?回答：调用 useState Hook 多次即可，每调用一次 useState Hook 可以提供一个状态。注意：useState Hook 多次调用返回的 [state, setState] 相互之间，互不影响。\n12.3.5hooks 的使用规则注意：React Hooks 只能直接出现在 函数组件 中，不能嵌套在 if&#x2F;for&#x2F;其他函数中！\n否则就会报错：React Hook “useState” is called conditionally. React Hooks must be called in the exact same order in every component render\nReact 的 useState 这个 Hook 被条件性（放在一个条件判断中）的调用了。\nReact Hooks 必须要每次组件渲染时，按照相同的顺序来调用所有的 Hooks。\n\n为什么会有这样的规则？ 因为 React 是按照 Hooks 的调用顺序来识别每一个 Hook，如果每次调用的顺序不同，导致 React 无法知道是哪一个 Hook\n\n13.3useEffect Hook13.3.1side effect - 副作用使用场景：当你想要在函数组件中，处理副作用（side effect）时，就要使用 useEffect Hook 了作用：处理函数组件中的副作用（side effect）\n问题：副作用（side effect）是什么?回答：在计算机科学中，如果一个函数或其他操作修改了其局部环境之外的状态变量值，那么它就被称为有副作用。副作用是相对于主作用来说的，一个功能（比如，函数）除了主作用，其他的作用就是副作用对于 React 组件来说，主作用就是根据数据（state&#x2F;props）渲染 UI，除此之外都是副作用（比如，手动修改 DOM）**\n常见的副作用（side effect）\n\n数据（Ajax）请求、手动修改 DOM、localStorage 操作等\n\n// 不带副作用的情况：// 该函数的（主）作用：计算两个数的和function fn(a, b) &#123;  return a + b&#125;// 带副作用的情况：let c = 1function fn(a, b) &#123;  // 因为此处修改函数外部的变量值，而这一点不是该函数的主作用，因此，就是：side effect（副作用）  c = 2  return a + b&#125;// 带副作用的情况：function fn(a, b) &#123;  // 因为 console.log 会导致控制台打印内容，所以，也是对外部产生影响，所以，也是：副作用  console.log(a)  return a + b&#125;// 没有副作用：function fn(obj) &#123;  return obj.name&#125;// 有副作用：function fn(obj) &#123;  // 此处直接修改了参数的值，也是一个副作用  obj.name = &#x27;啊&#x27;  return obj.name&#125;const o = &#123; name: &#x27;啊&#x27; &#125;fn(o)\n\n13.3.2useEffect 的基本使用import &#123; useEffect &#125; from &#x27;react&#x27;//useEffect的参数是一个函数，//这个函数会在组件渲染好的时候执行(componentDidMount + componentDidUpdate)//就是在这个函数中写副作用的代码useEffect(function effect() &#123;  document.title = `当前已点击 $&#123;count&#125; 次`&#125;)useEffect(() =&gt; &#123;  document.title = `当前已点击 $&#123;count&#125; 次`&#125;)\n\n解释：\n\n参数：回调函数（称为 effect），就是在该函数中写副作用代码\n执行时机：该 effect 会在每次组件更新（DOM更新）后执行，等价于两个钩子函数(componentDidMount + componentDidUpdate)\n\n13.3.3useEffect 的依赖\n问题：如果组件中有另外一个状态，另一个状态更新时，刚刚的 effect 回调，也会执行 \n性能优化：跳过不必要的执行，只在 count 变化时，才执行相应的 effect\n\nuseEffect(() =&gt; &#123;  document.title = `当前已点击 $&#123;count&#125; 次`&#125;, [count])\n\n解释：\n\n第二个参数：可选的，可省略；也可以传一个数组，数组中的元素可以成为依赖项（deps） \n该示例中表示：只有当 count 改变时，才会重新执行该 effect\n\n当useEffect 的依赖是一个空数组时，表示只在组件第一次渲染后执行 effect，因为空数组是不会发生变化的。使用场景：1 事件绑定 2 发送请求获取数据 等\nuseEffect(() =&gt; &#123;  const handleResize = () =&gt; &#123;&#125;  window.addEventListener(&#x27;resize&#x27;, handleResize)&#125;, [])\n\n解释：\n\n该 effect 只会在组件第一次渲染后执行，因此，可以执行像事件绑定等只需要执行一次的操作\n此时，相当于 class 组件的 componentDidMount 钩子函数的作用\n\n\n跟 useState Hook 一样，一个组件中也可以调用 useEffect Hook 多次 \n推荐：一个 useEffect  只处理一个功能，有多个功能时，使用多次 useEffect\n\n注意：如果useEffect的函数使用到了某个依赖项，必须要在第二个参数中填写该依赖\n总结： useEffect 的使用\n// 触发时机：1 第一次渲染会执行 2 每次组件重新渲染都会再次执行useEffect(() =&gt; &#123;&#125;)// 触发时机：只在组件第一次渲染时执行useEffect(() =&gt; &#123;&#125;, [])// 触发时机：1 第一次渲染会执行 2 当 count or money 变化时会再次执行useEffect(() =&gt; &#123;&#125;, [count，money])\n\n13.3.4useEffect 清理组件副作用问题：如何在组件卸载时，解绑事件？此时，就用到 effect 的返回值了\nuseEffect(() =&gt; &#123;  const handleResize = () =&gt; &#123;&#125;  window.addEventListener(&#x27;resize&#x27;, handleResize)  return () =&gt; window.removeEventListener(&#x27;resize&#x27;, handleResize)&#125;, [])\n\n解释：\n\neffect 的返回值也是可选的，可省略。也可以返回一个清理函数，用来执行事件解绑等清理操作\n清理函数的执行时机：1【空数组没有依赖】组件卸载时 2 【有依赖项】effect 重新执行前（暂时知道即可） \n此时，相当于 class 组件的 componentWillUnmount 钩子函数的作用\n\n\n推荐：一个 useEffect 只处理一个功能，有多个功能时，使用多次 useEffect \n优势：根据业务逻辑来拆分，相同功能的业务逻辑放在一起，而不是根据生命周期方法名称来拆分代码\n\n13.3.5useEffect 发送请求在组件中，使用 useEffect Hook 发送请求获取数据（side effect）：\nfunction App()&#123;    const [list,setList] = useState([])    useEffect(() =&gt; &#123;        const getList = async () =&gt; &#123;            const res = await axios.get(&#x27;http://....&#x27;)            setList(res.data.channels)        &#125;        getList()    &#125;,[])&#125;\n\n解释：\n\n注意：effect 只能是一个同步函数，不能使用 async\n因为 effect 的返回值应该是一个清理函数，React 会在组件卸载或者 effect 的依赖项变化时重新执行 \n但如果 effect 是 async 的，此时返回值是 Promise 对象。这样的话，就无法保证清理函数被立即调用\n如果延迟调用清理函数，也就没有机会忽略过时的请求结果或取消请求\n为了使用 async&#x2F;await 语法，可以在 effect 内部创建 async 函数，并调用\n\n// 错误演示：// 不要给 effect 添加 asyncuseEffect(async () =&gt; &#123;&#125;, [])\n\n13.4函数组件的特性、问题函数组件的特性说明：\n\n对于函数组件来说，每次状态更新后，组件都会重新渲染。并且，每次组件更新都像是在给组件拍照。每张照片就代表组件在某个特定时刻的状态。或者说：组件的每次特定渲染，都有自己的 props/state/事件处理程序 等。这些照片记录的状态，从代码层面来说，是通过 JS 中函数的闭包机制来实现的。\n\n问题：\n\n组件每次重新渲染时，组件内部的事件处理程序等函数都会重新创建，导致子组件每次都会接收到不同的 props，从而重复进行不必要的渲染（性能问题）。我们使用 React.memo 配合 useCallback/useMemo  来解决\n组件内的事件处理程序等函数中，只能获取到那一次特定渲染时的数据，这是合理的（闭包的原因）。使用 useRef Hook 来解决\n\n13.5React.memo高阶组件13.5.1React.memo 高阶组件的使用场景说明：React 组件更新机制：只要父组件状态更新，子组件就会无条件的一起更新。\n\n子组件 props 变化时更新过程：组件代码执行 -&gt; JSX Diff（配合虚拟 DOM）-&gt; 渲染（变化后的内容）【 DOM 操作】。\n子组件 props 无变化更新过程：组件代码执行 -&gt; JSX Diff（配合虚拟 DOM）【无 DOM 操作】。\n\n注意：此处更新指的是组件代码执行、JSX 进行 Diff 操作（纯 JS 的操作，速度非常快，不会对性能产生太多影响）。\n\n如果组件 props 改变了，那么，该组件就必须要更新，才能接收到最新的 props。\n但是，如果组件 props 没有改变时，组件也要进行一次更新。实际上，这一次更新是没有必要的。\n\n如果要避免组件 props 没有变化而进行的不必要更新（Diff），这种情况下，就要使用 React.memo 高阶组件。\n13.5.2语法使用场景：当你想要避免函数组件 props 没有变化而产生的不必要更新时，就要用到 React.memo 了。\n作用：记忆组件上一次的渲染结果，在 props 没有变化时复用该结果，避免函数组件不必要的更新。\n解释：\n\nReact.memo 是一个高阶组件，用来记忆（memorize）组件。\n参数（Child）：需要被记忆的组件，或者说是需要避免不必要更新的组件。\n返回值（MemoChild）：React 记住的 Child 组件。\n\n原理：通过对比检查更新前后 props 是否相同，来决定是否复用上一次的渲染结果，\n\n如果相同，复用上一次的渲染结果；\n如果不同，重新渲染组件。\n\n并不是所有的组件都适合使用memo，比如child2组件，每次都需要重新渲染，使用memo反而会使性能变得更低，逻辑也变得更复杂\n13.5.3浅层对比默认情况下，React.memo 只会对更新前后的 props 进行浅对比（shallow compare）与 PureComponent 相同。\n也就是说，对于对象类型的 prop 来说，只会比较引用\n\n如果更新前后的引用相同，复用上一次的渲染结果（不会重新渲染该组件）。\n如果更新前后的引用不同，重新渲染该组件。\n\n如果你要手动控制比较过程，可以使用 React.memo 的第二个参数\n解释：\n\n第二个参数：用来比较更新前后 props 的函数。\n返回值：如果返回 true，表示记住（不重新渲染）该组件；如果返回 false，表示重新渲染该组件。\n\n13.6useCallback13.6.1使用场景在使用 React.memo 时，对于对象类型的 props，只会比较引用（浅对比）。\n但是，因为组件每次更新都会创建新的 props 值，比如，新的对象、事件处理程序等（函数组件的特性）。\n这就导致：React.memo 在处理对象类型的 props 时，会失效（每次的 props 都是新对象）。\n但是，我们还是想让 React.memo 在处理对象类型的 props 时，也有效。\n为了让 React.memo 处理对象类型的 props 有效，只要在组件更新期间保持对象类型引用相等，就可以了。\n这时候，就要用到以下两个 Hooks：\n\nuseCallback Hook：记住函数的引用，在组件每次更新时返回相同引用的函数。\nuseMemo Hook：记住任意数据（数值、对象、函数等），在组件每次更新时返回相同引用的数据【功能之一】\n\n13.6.2基本使用使用场景：在使用 React.memo 时，为了组件每次更新时都能获取到相同引用的函数，就要用到 useCallback Hook\n注意：需要配合 React.memo 高阶函数一起使用。\n作用：记忆传入的回调函数，这个被记住的回调函数会一直生效，直到依赖项发生改变\n解释：\n\n第一个参数：必选，需要被记忆的回调函数。\n第二个参数：必选，依赖项数组，用于指定回调函数中依赖（用到）的数据（类似于 useEffect 的第二个参数）。\n即使没有依赖，也得传入空数组（[]），此时，useCallback 记住的回调函数就会一直生效。\n返回值：useCallback 记住的回调函数。\nuseCallback 记住的回调函数会一直生效（或者说会一直返回同一个回调函数），直到依赖项发生改变。\n\n","categories":["前端"],"tags":["React"]},{"title":"12.和小达一起学Git","url":"/2022/08/11/13.%E5%92%8C%E5%B0%8F%E8%BE%BE%E4%B8%80%E8%B5%B7%E5%AD%A6Git/","content":"1.版本控制1.1手动修改文件版本名字缺点：\n\n操作麻烦：每次都要重命名版本名字\n命名不规范：无法通过文件名知道在当前版本中做了哪些修改\n容易丢失：硬盘故障、失误删除等\n协作困难：需要手动合并每个人对文件项目的修改，合并时及其容易出错\n\n1.2版本控制系统(软件)1.2.1概念​\t记录文件变化，以便将来查阅特定版本的修订情况的系统。负责管理文件版本\n1.2.2优势\n操作简便：只需机组简单的终端命令就可以快速上手常见的版本控制软件\n易于对比：方便比较文件的变化细节\n易于回溯：可以将选定的文件回溯到之前的状态，甚至将整个项目都回溯到之前的状态\n不易丢失：误删的文件可以轻松的恢复\n协作方便：基于版本控制软件的分支功能，可以实现多人协作开发时的代码合并\n\n1.2.3本地版本控制系统​\t特点：\t使用软件记录文件的不同版本，降低手动维护版本的出错率\n​\t缺点：\t1.单机运行不支持多人协作开发\n​\t\t\t\t\t2.版本数据库故障后，所有的历史更新记录会丢失\n1.2.4集中化的版本控制系统（SVN）​\t特点：\t基于服务器、客户端的运行模式。\n​\t\t\t\t\t1.服务器保存文件的所有更新记录\n​\t\t\t\t\t2.客户端只保留最新的文件版本\n​\t优点：\t\n​\t\t\t\t\t联网运行，支持多人开发\n​\t缺点：\t\n​\t\t\t\t\t1.不支持离线提交版本更新\n​\t\t\t\t\t2.中心服务器崩溃后，所有人无法正常工作\n​\t\t\t\t\t3.版本数据库故障后，所有历史记录会丢失。\n1.2.5分布式版本控制系统（Git）​\t特点：\t基于服务器、客户端的运行模式。\n​\t\t\t\t\t1.服务器保存文件的所有更新版本\n​\t\t\t\t\t2.客户端是服务器的完整备份\n​\t优点：\t\n​\t\t\t\t\t1.联网运行，支持多人协作开发\n​\t\t\t\t\t2.支持离线本地提交版本更新\n​\t\t\t\t\t3.服务器故障后，可使用任何一个客户端的备份进行恢复\n​\t\t\t\t\t\n2.Git基础2.1概念​\tGit 是一个开源的分布式版本控制系统，是目前世界上最先进、最流行的版本控制系统。可以快速高效地处理 \n从很小到非常大的项目版本管理。 \n特点\t项目越大越复杂，协同开发者越多，越能体现出 Git 的高性能和高可用性\n2.2Git的特性​\tGit 之所以快速和高效，主要依赖于它的如下两个特性： \n​\t\t① 直接记录快照，而非**差异比较 **\n​\t\t② 近乎所有操作都是本地执行\n2.2.1 SVN的差异比较​\t传统的版本控制系统（例如 SVN）是基于差异的版本控制，它们存储的是一组基本文件和每个文件随时间逐步 累积的差异。 \n\n​\t\n优势\t节省磁盘空间\n缺点\t在每次切换版本的时候，都需要在基本文件的基础上，应用每个差异，从而生成目标版本对应的文件，耗时，效率低\n2.2.2 Git 的记录快照​\tGit 快照是在原有文件版本的基础上重新生成一份新的文件，类似于备份。为了效率，如果文件没有修改，Git \n不再重新存储该文件，而是只保留一个链接指向之前存储的文件。\n优势\t版本切换时非常快，因为每个版本都是完整的文件快照，切换版本时直接恢复目标版本的快照即可。\n缺点\t占用磁盘空间较大\n2.2.3本地执行​\t在Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。\n​\t断网后依旧可以在本地对项目进行版本管理，联网后，把本地修改的记录同步到云端服务器。\n2.3Git的三个区域工作区\t处理工作的区域\n暂存区\t已完成的工作的临时存放区域，等待被提交\nGit仓库\t最终的存放区域\n2.4Git的三种状态已修改Modified\t表示修改了文件，但是还没有将修改的结果放到暂存区，就是已修改状态\n已暂存staged\t表示对已修改文件的当前版本做了标记，使之包含在下次提交的列表中。如果文件已修改并放入暂存区就是已暂存状态\n已提交committed\t表示文件已经安全的保存在本地的Git仓库中，如果Git仓库中保存着特定版本的文件，就是已提交状态\n2.5Git的工作流程​\t1.在工作区修改文件\n​\t2.将你想要下次提交的更改进行暂存\n​\t3.找到暂存区的文件，将快照永久性存储到Git仓库\n\n3.安装、配置Git3.1Git下载​\thttps://git-scm.com/downloads\n3.2配置用户信息​\t设置自己的用户名和邮件地址。因为通过 Git 对项目进行版本管理的时候，Git 需要使用这些基本信息，来记录是谁对项目进行了操作。\ngit confit --global user.name &quot;xxx&quot;\t    //用户名git confir --global user.email &quot;xxx&quot;\t//邮箱地址\n\n​\t全局配置文件\t可以在C：&#x2F;users&#x2F;xxx&#x2F;.gitconfig文件中找到，记录了自己对Git做的全局性的配置。\n3.3查看全局配置信息git config --list --global\t\t//查看所有的全局配置项git config user.name\t\t\t//查看指定的全局配置项git config user.email\n\n3.4帮助信息git help &lt;verb&gt;\t\t//无需联网即可打开帮助手册git help configgit config -h\t\t//在终端打印更简明的help输出\n\n4.Git操作4.1获取Git仓库4.1.1将尚未进行版本控制的本地目录转换为Git仓库​\t1.在项目的目录右键打开Git Bash\n​\t2.执行git init命令将当前目录转化为Git仓库\n​\t（git init 命令会创建一个名为 .git 的隐藏目录，这个 .git 目录就是当前项目的 Git 仓库，里面包含了初始的必要文件，这些文件是 Git 仓库的必要组成部分。）\n4.1.2从其他服务器克隆已存在的Git仓库4.2工作区中文件的两大类和四种状态​\t1.未被Git管理(未跟踪Untracked)\n​\t\t\t未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围，除非手动设置。\n​\t2.已被Git管理\n​\t\t2.1未修改(Unmodified)：工作区文件的内容和Git仓库中的文件内容保持一致\n​\t\t2.2已修改(Modified)：工作区文件的内容和Git仓库文件的内容不一致\n​\t\t2.3已暂存(Staged)：工作区中被修改的文件已放到暂存区，准备保存到Git仓库中\n4.3检查文件状态git statusgit statusgit status -s   //精简的显示文件状态，-s是--short的简写//\t\t\t\t??表示未跟踪的文件//\t\t\t\tA 表示新添加到暂存区的文件\n\n4.4跟踪新文件，暂存文件git addgit add index.htmlgit add .   //一次性将所有新增和修改过的文件加入暂存区\n\n4.5提交更新git commit​\t使用git commit命令提交到Git仓库进行保存，同时可以使用-m 选项对提交的内容进行描述\ngit commit -m &quot;新建了index.html文件&quot;\n\n\n4.6对以提交的文件修改并暂存git add git commit​\t目前index.html已经被Git跟踪，且工作区和Git仓库中的index。html文件内容一致。当我们修改工作区的index.html之后，再次运行git status，会出现Changes not staged for commit，表示已跟踪的文件内容发生变化，但是还没有放到暂存区，这时需要再次运行git add将已跟踪的，已修改的文件放到暂存区\n//修改文件后执行git add index.html//此时会把文件放到暂存区git commit -m &quot;初始化&quot;  //此时会提交到仓库\n\n\n4.7撤销对文件的修改git checkout​\t将工作区中对应文件的修改还原成Git仓库保存的版本，操作后所有修改丢失且无法恢复，谨慎！！！！！（用 Git 仓库中保存的文件，覆盖工作区中指定的文件。）\ngit checkout -- index.html\n\n\n4.8取消暂存的文件git reset HEADgit reset HEAD index.html//从暂存区移除git reset HEAD .//从暂存区移除所有文件\n\n4.9跳过使用暂存区域​\tGit 标准的工作流程是工作区 → 暂存区 → Git 仓库，但有时候这么做略显繁琐，此时可以跳过暂存区，直接将 工作区中的修改提交到 Git 仓库，这时候 Git 工作的流程简化为了工作区 → Git 仓库\ngit commit -a -m &quot;描述&quot;\n\n4.10删除文件git rm//从 Git仓库和工作区中同时移除对应的文件git rm -f index.js//只从 Git仓库中移除指定的文件，但保留工作区中对应的文件git rm --cached index.js\n\n4.11忽略文件一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 在这种情况下，我们可 以创建一个名为 .gitignore 的配置文件，列出要忽略的文件的匹配模式。 \n文件 .gitignore 的格式规范如下： \n​\t1.以 # 开头的是注释 \n​\t2.以 &#x2F; 结尾的是目录 \n​\t3.以 &#x2F; 开头防止递归 \n​\t4.以 ! 开头表示取反 \n​\t5.可以使用 glob 模式进行文件和文件夹的匹配（glob 指简化了的正则表达式）\n​\t\t① 星号 * 匹配零个或多个任意字符 \n​\t\t② [abc] 匹配任何一个列在方括号中的字符 （此案例匹配一个 a 或匹配一个 b 或匹配一个 c） \n​\t\t③ 问号 ? 只匹配一个任意字符 \n​\t\t④ 在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配（比如 [0-\t\t9] 表示匹配所有 0 到 9 的数字） \n​\t\t⑤ 两个星号 ** 表示匹配任意中间目录（比如 a&#x2F;**&#x2F;z 可以匹配 a&#x2F;z 、 a&#x2F;b&#x2F;z 或 a&#x2F;b&#x2F;c&#x2F;z 等）\n4.12查看提交历史git log​\t返回包括了作者和邮箱，提交时间，提交描述\n//按照时间顺序列出所有的提交历史，最近的在最上git log//仅显示最近的3条提交历史git log -3//在一行上展示最近的3条提交历史git log -3 --pretty=oneline//在一行上展示最近的3条提交历史，并自定义输出的格式git log -2 --pretty=format:&quot; %h | %an | %ar | %s &quot;//%h提交的简写哈希值\t%an作者\t%ar时间\t%s提交描述\n\n4.13回退到指定的版本////在一行上展示所有提交历史git log --pretty=oneline//根据指定ID退回指定版本git reset --hard &lt;CommitID&gt;//退回旧版本后，使用git reflog查看命令操作历史git reflog --pretty=oneline//根据最新提交的ID，跳转到最新的版本git reset --hard &lt;CommitID&gt;\n\n\n\n5. Github配置5.1远程仓库的两种访问模式5.1.1.HTTPS​\t\t零配置；但是每次访问仓库时，需要重复输入 Github 的账号和密码\n5.1.2SSH​\t\t需要进行额外的配置；但是配置成功后，每次访问仓库时，不需重复输入 Github 的账号和密码\n5.2基于HTTP将本地仓库上传到Github//如果本地没有仓库echo &quot;# &quot; &gt;&gt; README.mdgit initgit add README.mdgit commit -m &quot;first commit&quot;git branch -M maingit remote add origin https://github.com/...git push -u origin maingit push//将本地仓库最新的代码推送到仓库里\n\n5.2基于SSH将本地仓库上传到Github5.2.1 SSH key​\tSSH Key 的作用：\t实现本地仓库和Github之间免登录的加密传输\n​\t① id_rsa（私钥文件，存放于客户端的电脑中即可） \n​\t② id_rsa.pub（公钥文件，需要配置到 Github 中）\n5.2.2生成SSH key​\t1.打开Git Bash\n​\t2.\nssh-keygen -t rsa -b 4096 -C &quot;注册Github帐号的邮箱&quot;\n\n​\t3.三次回车，在C:\\Users\\用户名.ssh生成id_rsa和id_rsa.pub两个文件\n5.2.3配置SSH key​\t1.打开id_rsa.pub，复制文本里的内容\n​\t2.Github\tSettings\tSSH and GPG Keys\tNew SSH key\n​\t3.将 id_rsa.pub 文件中的内容，粘贴到 Key 对应的文本框中\n5.2.4检测SSH key是否配置成功//Git Bashssh -T git@github.com\n\n5.2.5将远程仓库地址克隆到本地git clone 远程仓库地址//SSH或Https\n\n\n\n//如果本地有仓库git remote add origin https://github.com/...git branch -M maingit push -u origin maingit push//将本地仓库最新的代码推送到仓库里\n\n6. Github分支6.1分支​\t协同开发时，为了防止互相干扰，提高协同开发体验，每个开发者都基于分支进行项目开发，待每个人的功能开发测试完毕后，合并到master主分支\n6.2 master主分支​\t初始化本地仓库时**(git init)，Git默认创建一个master分支，通常把master分支叫主分支，用来保存和记录整个项目已完成的功能代码**，实际开发中不允许直接在master分支修改代码，容易导致项目崩溃\n6.3 功能分支​\t用以开发新功能的分支，是临时从master主分支上分叉出来的，当新功能开发且测试完成后，最终合并到master主分支上\n6.4命令集合//1.查看分支列表git branch//*master，*号代表当前所处的分支//2.创建新分支//是基于当前分支进行创建的，新分支的代码等于当前分支的代码。创建分支后，仍在原分支，不会进行切换。git branch new_branch_name//3.切换分支，切换到指定的分支上进行开发git checkout new_branch_name//switched to branch new_branch_name//4.快速创建和切换分支，创建新分支，立即切换到新分支上git checkout -b new_branch_name//5.合并分支git checkout mastergit merge new_branch_name//先切换到主分支，然后将新分支的代码合并到主分支上//6.删除分支git branch -d new_branch_name//删除分支时，保证自己不处于被删除的分支上//7.将本地分支推送到远程仓库,第一次推送需要-u参数//git push -u 远程仓库名称 本地分支名称:远程分支名称git push -u origin payment:pay//8.查看远程仓库中所有的分支列表//git remote show 远程仓库名称git remote show origin//9.跟踪分支，从远程仓库中，把远程分支下载到本地仓库//git checkout 远程分支名称 //git checkout -b 重命名本地分支名称 远程仓库名称/远程分支名称git checkout -b payment origin/pay//10.拉取远程分支的最新代码,拉去当前分支最新的代码，保持当前分支的代码和远程分支一致git pull//处于哪个分支，就更新哪个分支//11.删除远程分支//git push 远程仓库名称 --delete 远程分支名称git push origin --delete pay\n\n6.5遇到冲突时的合并​\t如果两个不同的分支，对同一个文件进行了不同的修改，Git无法干净的合并，此时需要打开包含冲突的文件然后手动解决冲突\n//解决冲突之后git add .git commit -m &quot;解决了分支合并冲突问题&quot;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["前端"],"tags":["Git"]},{"title":"5.和小达一起学WebAPI","url":"/2022/08/11/5.%E5%92%8C%E5%B0%8F%E8%BE%BE%E4%B8%80%E8%B5%B7%E5%AD%A6WebAPI/","content":"⭐Web APIs     DOM、BOM1.基本认识1.1作用与分类作用：   简而言之就是使用JavaScript去操作html和浏览器\n分类：   DOM（文档对象模型）BOM（浏览器对象模型）\n     &lt;img src=&quot;../pictures/WebAPIs分类.png&quot;  /&gt;\n\n1.2DOM(Document Object Model)文档对象模型，用于呈现以及HTML和XML文档交互的API\n\n**DOM树**  将HTML文档以树状结构表现出来，称之为DOM树，直观的体现了标签和标签的关系\n\n \n\n**DOM的核心是把内容当作对象类处理**\n\n2.DOM的基本操作2.1获取DOM元素//获取匹配的第一个元素    let div = document.querySelector(&#x27;css选择器&#x27;)\n\n返回值：\n\n    CSS选择器匹配的第一个元素,一个 HTMLElement对象，如果没有匹配到，则返回null\n\n//获取匹配的所有元素    let lis = document.querySelectorAll(&#x27;ul li&#x27;)\n\n返回值：\n\n    CSS选择器匹配的所有元素,返回的是伪数组(有长度索引号，但是不能使用数组方法)，只能通过遍历的方式获取里面的每一个DOM元素\n\n//根据ID获取一个元素  document.getElementById(&#x27;nav&#x27;)//根据标签获取一类元素  获取页面的所有divdocument.getElementByTagName(&#x27;div&#x27;)//根据类名获取元素    获取页面所有类名为aoteman的document.getElementByClassName(&#x27;aoteman&#x27;)\n\n注意     小括号里必须加引号’’，然后里面写css选择器\n2.2设置&#x2F;修改DOM元素的内容let box = document.querySelector(&#x27;div&#x27;)//对象.属性 = 值//innerText   添加文本内容box.innerText = &#x27;aotemanlalalalala&#x27;//innerHTMLbox.innerHTML = &#x27;&lt;strong&gt;aotemanlalalalala&lt;/strong&gt;&#x27;\n\n注意\tinnerText 不会解析标签\n        innerHTML会解析里面的标签\n\n2.3设置&#x2F;修改DOM元素的属性2.3.1修改常用属性let pic = document.querySelector(&#x27;img&#x27;)//对象.属性 = 值pic.src = &#x27;./images/img1.png&#x27;\n\n2.3.2修改元素的样式let box = document.querySelector(&#x27;div&#x27;)//对象.style.样式属性 = 值box.style.backgroundColor = &#x27;pink&#x27;box.style.width = &#x27;400px&#x27;\n\n2.3.3修改元素的类名let box = document.querySelector(&#x27;div&#x27;)//1. 修改box的类名   这种方式会覆盖原有的类名，想要不覆盖添加两个类名box.className = &#x27;one active&#x27;//2. 追加类名box.classList.add(&#x27;类名&#x27;)//3. 删除类名box.classList.remove(&#x27;类名&#x27;)//4. 切换类名box.classList.toggle(&#x27;类名&#x27;)\n\n2.3.4修改表单元素属性let input = document.querySelector(&#x27;input&#x27;)let btn = document.querySelector(&#x27;button&#x27;)let checkbox = document.querySelector(&#x27;.checkbox&#x27;)//1.   取值:对象.属性名    赋值：对象.属性名 = &#x27;新值&#x27;input.value = &#x27;aoteman&#x27;input.type = &#x27;password&#x27;//2.   修改表单元素属性btn.disabled = false//禁用按钮checkbox.checked = false//复选框\n\n3.定时器 和 延时器3.1定时器作用  每隔一段时间调用一次函数\n/*语法let 变量名 = setInterval(函数，间隔时间ms)*///开启定时器    function kungfu()&#123;    console.log(&#x27;激光biubiubiu&#x27;)&#125;let timer = setInterval(kungfu, 1000)//清除定时器  clearInterval(变量名)clearInterval(timer)\n函数每隔一段时间重复执行\n3.2延时器作用  让代码延迟执行\n/*语法let 变量名 = setTimeout(函数，间隔时间ms)*///开启定时器 let timer = setTimeout(function () &#123;            console.log(biubiubiu)        &#125;, 3000)//清除延时器  clearTimeout(变量名)clearTimeout(timer)\n\n函数只执行一次\n4.事件4.1事件监听让程序检测是否有事件产生，一旦有事件触发，就立即调用一个函数做出响应，也称为 注册事件\n\n/*语法元素.addEventListener(&#x27;事件&#x27;，要执行的函数)*/let btn = document.querySelector(&#x27;button&#x27;)btn.addEventListener(&#x27;click&#x27;,function()&#123;    alert(&#x27;激光biubiubiu&#x27;)&#125;)\n\n事件监听三要素\n1.事件源：哪个元素被触发了\n\n2.事件：用什么方式触发，比如说click或者mouseenter mouseleave\n\n3.事件调用的函数：事件触发之后要做什么事情\n\n4.2事件类型**鼠标事件：**\n\n\n\n\n时间名\n说明\n\n\n\nclick\n鼠标点击\n\n\nmouseenter\n鼠标经过\n\n\nmouseleave\n鼠标离开\n\n\n焦点事件：\n\n\n\n时间名\n说明\n\n\n\nfocus\n获得焦点\n\n\nblur\n失去焦点\n\n\n键盘事件：\n\n\n\n时间名\n说明\n\n\n\nkeydown\n键盘按下触发\n\n\nkeyup\n键盘抬起触发\n\n\n文本事件：\n\n\n\n时间名\n说明\n\n\n\ninput\n用户输入触发\n\n\nresize :\n窗口发生变化触发的事件\nwindow.addEventListener(&#x27;resize&#x27;,function()&#123;    //检测屏幕宽度    let w = document.ducumentElement.clientWidth    console.log(w)&#125;)\n\n\n\n4.3事件对象4.3.1介绍事件对象也是个对象，这个对象里保存了触发事件时的相关信息\n\n在事件绑定的回调函数的第一个参数就是事件对象，一般命名为**e**或**event**或**ev**\n\n元素.addEventListener(&#x27;click&#x27;.function(e)&#123;&#125;)\n\n4.3.2常用属性\n\n\n属性名\n说明\n\n\n\ntype\n获取当前的事件类型\n\n\nclientX&#x2F;clientY\n获取光标相对于浏览器可见窗口左上角的位置\n\n\noffsetX&#x2F;offsetY\n获取光标相对于当前DOM元素左上角的位置\n\n\nkey\n用户按下的键盘键的值\n\n\npageX&#x2F;pageY\n获取光标相对于文档左上角的位置\n\n\n4.4事件流4.4.1事件流指的是事件完整执行过程中的流动路径，有两个阶段，包括事件捕获和事件冒泡\n4.4.2事件冒泡当一个元素触发事件后，会依次向上调用所有父级元素的同名事件+\n\n4.4.3事件捕获从DOM的根元素开始去执行对应的事件 (从外到里) \n\nDOM.addEventListener(事件类型，函数，是否使用捕获机制)\n\naddEventListener第三个参数传入true代表是捕获阶段触发，若传入false代表冒泡阶段触发，默认就是false\n4.4.4阻止事件流因为默认就有冒泡模式的存在，所以容易导致事件影响到父级元素，想把事件就限制在当前元素内，就需要阻止事件流动。在冒泡和捕获阶段都有效\ne.stoppropagation()\n\n4.4.5阻止默认行为阻止默认行为，比如链接点击不跳转\n\ne.preventDefult()\n\n4.5事件委托1.事件委托是利用事件冒泡，通过给父元素添加事件，让子元素实现对应的效果，这样就不用给子元素一个一个添加事件。\n2.利用   e.target获得触发事件的元素\n\nlet ul = document.querySelector(&#x27;ul&#x27;)ul.addEventListener(&#x27;click&#x27;,function()&#123;    e.target.style.color = &#x27;red&#x27;&#125;)\n\n4.6滚动事件scroll4.6.1监听页面的滚动window.addEventListener(&#x27;scroll&#x27;,function()&#123;    &#125;)\n\n需要监听某个元素内部的滚动，给元素添加滚动事件即可。\n4.6.2scroll获取宽高    scrollWidth  scrollHeight\nlet div = document.querySelector(&#x27;div&#x27;)console.log(div.scrollWidth)   //返回的是不带单位的console.log(div.scrollHeight)  \n\nscroll返回的是**元素内容**的宽高（不含滚动条），返回值不带单位。\n\n获取位置    scrollLeft  scrollTop\nwindow.addEventListener(&#x27;scroll&#x27;,function()&#123;    console.log(document.documentElement.scrollTop)    //document.documentElement HTML 文档返回对象为HTML元素&#125;)\n\nscroll获取元素内容往左往上滚出去看不到的距离\n这两个属性是可以修改的\n\n4.6.3offset获取宽高    offsetWidth  offsetHeight\nlet div = document.querySelector(&#x27;div&#x27;)console.log(div.offsetWidth)   //返回的是不带单位的console.log(div.offsetHeight)  \n\n获取**元素自身**的宽高、包含盒子自身的宽高、padding、border\n\n获取位置    scrollLeft  scrollTop\nlet sk = document.querySelector(&#x27;.sk&#x27;)       window.addEventListener(&#x27;scroll&#x27;,function()&#123;    console.log(sk.offsetTop)&#125;)\n\noffsetLeft offsetTop获取元素**距离自己定位父级元素**的左、上距离\n\n只读属性不可被修改\n\n4.6.3client获取宽高    clientWidth  clientHeight\nlet div = document.querySelector(&#x27;div&#x27;)console.log(div.clientWidth)   //返回的是不带单位的console.log(div.clientHeight)  \n\n获取**元素可见部分**的宽高，不包含边框滚动条，包含padding\n\n获取位置    clientLeft  clientTop\nclientLeft clientTop获取左边框和上边框的宽度\n\n只读属性不可被修改\n\n5.高阶函数高阶函数  javaScript 中函数可以被当成【值】来对待，基于这个特性实现函数的高级应用\n5.1函数表达式//函数表达式必须先声明再调用let counter = function(x,y)&#123;return x+y&#125;//调用let result = counter(5,10)\n\n5.2回调函数//函数表达式必须先声明再调用let counter = function(x,y)&#123;return x+y&#125;//调用let result = counter(5,10)\n\n\n\n6.节点6.1节点说明**DOM节点：**DOM树里的每一个内容成为节点\n\n**类型**：\n\n    1.元素节点：所有的标签      如body   div\n\n    2.属性节点\n\n    3.文本节点\n\n    4.其他\n\n6.2查找节点6.2.1查找父元素节点//语法  ：子元素.parentNodelet son = document.querySelector(&#x27;.son&#x27;)son.parentNode.style.display = &#x27;none&#x27;\n\n返回最近一级的父元素节点，如果找不到返回为null\n\n6.2.2查找子元素节点//语法  ：父元素.children       仅获得元素节点**常用**//       父元素.childNodes     获得所有子节点、包括文本节点（空格、换行）、注释节点等ul.children[i].style.color = &#x27;red&#x27;\n\n返回的是一个**伪数组**\n\n6.2.3查找兄弟节点//语法  ： 元素.nextElementSibling       下一个兄弟节点//\t\t  元素.previousElementSibling   上一个兄弟节点\n\n6.3增加、删除、克隆节点6.3.1创建节点//语法   document.creatElement(&#x27;标签名&#x27;)let div = document.createElement(&#x27;div&#x27;)div.className = &#x27;current&#x27;\n\n6.3.2追加节点//语法   父元素.appendChild(要插入的子元素)\t\t加到父元素的最后//\t\t父元素.insertBefore(要插入的子元素，在哪个元素前)\t\t加到父元素的某个子元素前面let ul = document.querySelector(&#x27;ul&#x27;)let li = document.createElement(&#x27;li&#x27;)ul.appendChild(li)ul.insertBefore(li, ul.children[0])\n\n6.3.3克隆节点//语法\t元素.cloneNode(布尔值)//若布尔值为false(默认值)，不克隆后代节点；true克隆后代节点let ul = document.querySelector(&#x27;ul&#x27;)//一般先克隆节点，然后把复制的节点放到指定元素的内部let newUl = ul.cloneNode(true)document.body.appendChild(newUl)\n\n6.3.4删除节点//语法\t父元素.removeChild(要删除的元素)ul.removeChild(ul.children[0])\n\n在 JavaScript 原生DOM操作中，要删除元素必须通过父元素删除\n\n删除节点和隐藏节点（display:none） 有区别的： 隐藏节点还是存在的，但是删除，则从html中删除节点\n\n7.时间对象1.时间对象方法//获得当前时间let date = new Date()//获得指定时间let date = new Date(&#x27;1949-10-01&#x27;)\n\n\n\n\n方法\n作用\n说明\n\n\n\ngetFullYear()\n获得年份\n获取四位年份\n\n\ngetMonth()\n获得月份\n取值为 0 ~ 11\n\n\ngetDate()\n获取月份中的每一天\n不同月份取值也不相同\n\n\ngetDay()\n获取星期\n取值为 0 ~ 6\n\n\ngetHours()\n获取小时\n取值为 0 ~ 23\n\n\ngetMinutes()\n获取分钟\n取值为 0 ~ 59\n\n\ngetSeconds()\n获取秒\n取值为 0 ~ 59\n\n\n2.时间戳指的是1970年01月01日00时00分00秒起至现在的毫秒数，通常用**两个**时间戳计算**时间差**\n\n方法1：getTime()\n//getTime//1.首先实例化let date = new Date()//2.获得时间戳date.getTime()\n\n方法2：+new Date\nconsole.log(+new Date())  //获得当前的时间戳consele.log(+new Date(&#x27;2022-1-1 12:00:00&#x27;))  //获得指定时间的时间戳\n\n方法3: Date().now()\nconsole.log(Date.now())  //只能得到当前时间的时间戳\n\n注意： 方法1和方法2可以返回指定时间的时间戳，方法三只能得到当前时间的时间戳\n        方法1在使用getTime之前需要实例化\n\n8.BOM的基本操作8.1BOM介绍BOM(Browser Object Model ) 是浏览器对象模型\n\n\n\nwindow 是浏览器内置中的全局对象， Web APIs 的知识内容都是基于 window 对象实现的\nwindow 对象下包含了 navigator、location、document、history、screen 5个属性，即所谓的 BOM （浏览器对象模型） \ndocument 是实现 DOM 的基础，它其实是依附于 window 的属性。\n依附于 window 对象的所有属性和方法，使用时可以省略 window\n\n8.1.1location对象location 的数据类型是对象，它拆分并保存了 URL 地址的各个组成部分\n\n\n\n\n属性和方法\n作用\n\n\n\nhref\n获取完整的 URL 地址，对其赋值时用于地址的跳转\n\n\nsearch\n获取地址中携带的参数，符号 ？后面部分\n\n\nhash\n获取地址中的哈希值，符号 # 后面部分\n\n\nreload()\n法用来刷新当前页面，传入参数 true 时表示强制刷新\n\n\nlocation.href = &#x27;www.baidu.com&#x27;\n\n8.1.2navigator对象navigator的数据类型是对象，该对象下记录了浏览器自身的相关信息\n\n可以通过userAgent属性来检测浏览器的版本或者平台\n!(function()&#123;    const userAgent = navigator.userAgent    //验证是否为android或者iphone    const android = userAgent.match(/(Android);?[\\s\\/]+([\\d.]+)?/)\tconst iphone = userAgent.match(/(iPhone\\sOS)\\s([\\d_]+)/)&#125;)()\n\n8.1.3history对象history 的数据类型是对象，该对象与浏览器地址栏的操作相对应，如前进、后退、历史记录等\n\n\n\n\n方法或属性\n作用\n\n\n\nback()\n后退一页\n\n\nforward()\n前进一页\n\n\ngo(参数）\n前进或后退，参数为1前进一个页面，-1后退一个页面\n\n\n8.2本地存储8.2.1介绍网页经常需要在本地存储大量的数据，HTML5提出了规范的相关解决方案\n\n\n数据存储在用户的浏览器中\n设置和读取方便，刷新页面不丢失数据\n容量大，sessionStorage和localStorage大约5M左右\n\n8.2.2 localStorage\n生命周期永久生效，除非手动删除，否则关闭页面也会存在\n可以多页面共享（同一浏览器可以共享）\n以键值对的方法存储使用\n\n//存储数据localStorage.setItem(key,value)//获取数据localStorage.getItem(key)//删除数据localStorage.removeItem(key)\n\n注意：   本地存储只能存储字符串，无法存储复杂数据类型，需要将复杂数据类型转换成JSON字符串再存储\n//将复杂数据转换成JSON字符串   存储时使用JSON.stringify(复杂数据类型)//将JSON字符串转换成对象      取出时使用JSON.parse(JSON字符串)\n\n8.2.3 sessionStorage\n生命周期生命周期为关闭浏览器窗口\n在同一个窗口(页面)下数据可以共享\n以键值对的方法存储使用\n\n//使用方法同上\n\n9.自定义属性9.1介绍**固有属性:**  标签天生自带的属性 比如class id title等, 可以直接使用点语法操作\n\n**自定义属性:**  由程序员自己添加的属性,在DOM对象中找不到, 无法使用点语法操作,必须使用专门的API \n\n在html5中推出来了专门的data-自定义属性 在 标签上一律以data-开头,\n在DOM对象上一律以dataset对象方式获取\n\n10.正则表达式10.1介绍正则表达式（Regular Expression）是用于匹配字符串中字符组合的模式。正则表达式也是对象\n\n作用：表单验证（匹配），过滤敏感词（替换），提取字符串中想要的部分（提取）\n\n10.2语法//1.定义正则表达式   let 变量名 = /表达式/let reg = /huahua///2.用test()方法检测正则表达式与指定字符串是否匹配，返回布尔值  let str = /huahuahahahakahfa/console.log(reg.test(str))//3.用exec()方法再之歌指定字符串中执行一个搜索匹配，返回一个数组console.log(reg.exec(str))\n\n10.3元字符10.3.1边界符表示位置，开头和结尾，必须用什么开头，用什么结尾\n\n\n\n\n边界符\n说明\n\n\n\n^\n表示匹配行首的文本\n\n\n$\n表示匹配行尾的文本\n\n\n^$\n两个一起用表示精准匹配\n\n\nconsole.log(/^哈/.test(&#x27;哈&#x27;))  // trueconsole.log(/^哈/.test(&#x27;我哈哈大笑&#x27;))  // false console.log(/^哈$/.test(&#x27;哈哈&#x27;))  // false console.log(/^哈$/.test(&#x27;哈&#x27;))  // true \n\n10.3.2量词用来设定 **某个模式出现的次数**\n\n\n\n\n量词\n说明\n\n\n\n*\n0-多\n\n\n+\n1-多\n\n\n?\no或1\n\n\n{n}\nn\n\n\n{n,}\nn-多\n\n\n{n,m}\nn-m\n\n\n10.3.3字符类\n\n\n字符\n说明\n\n\n\n[abcdefg]\n后面的字符串只要包含[]内的任一字符都返回true\n\n\n[a-zA-Z0-9]\n表示a到z，A到Z，0到9都可\n\n\n[^a-z]\n括号里面加上^表示取反，除了小写字母以外的字符\n\n\n\\d\n[0-9]\n\n\n\\D\n[^0-9]\n\n\n\\w\n[A-Za-z0-9]\n\n\n\\W\n[^A-Za-z0-9]\n\n\n\\s\n[\\t\\r\\n\\v\\f]\n\n\n\\S\n[^\\t\\r\\n\\v\\f]\n\n\n10.4修饰符/*语法/表达式/修饰符*///i  表示不区分大小写console.log(/a/i.test(&#x27;a&#x27;))//true//g  表示匹配所有满足正则表达式的结果//replace替换//  字符串.replace(/正则表达式/，&#x27;替换的文本&#x27;)","categories":["前端"],"tags":["WebAPI"]},{"title":"4.和小达一起学JavaScript","url":"/2022/08/11/4.%E5%92%8C%E5%B0%8F%E8%BE%BE%E4%B8%80%E8%B5%B7%E5%AD%A6JavaScript/","content":"⭐JavaScript 基础1.引用js脚本JavaScript 程序不能独立运行，它需要被嵌入 HTML 中，然后浏览器才能执行 JavaScript 代码。通过 `script` 标签将 JavaScript 代码引入到 HTML 中，有两种方式：\n\n1.1内部直接写在html文件里，用&lt;script&gt;标签包裹\n\n&lt;body&gt;    &lt;script&gt;       alert(&#x27;你好， js&#x27;)    &lt;/script&gt;&lt;/body&gt;\n\n2.2外部写在.js文件里，然后引入\n\n&lt;script src=&quot;./my.js&quot;&gt;\n\n2.注释//单行注释/*块注释*/\n\n3.变量3.1声明和赋值let hero = &#x27;aoteman&#x27;var hero = &#x27;ironman&#x27;\n\n3.2var和let的区别由于变量提升（自动将声明放在使用前），var可以在初始化后声明，但这种设计令人困惑。\nlet不会变量提升，必须先声明再使用。\n3.3变量的命名规则\n只能是字母、数字、下划线、$，且不能数字开头\n字母区分大小写\nJavaScript 内部已占用于单词（关键字或保留字）不允许使用\n尽量保证变量具有一定的语义，见字知义\n\n4. 数据类型4.1基本数据类型基本数据类型是指存放在栈中的简单数据段，数据大小确定，内存空间大小可以分配，它们是直接按值存放的，所以可以直接按值访问\n\n\n\n类型\n说明\n\n\n\nNumber\n数字\n\n\nString\n字符串，可以拼接，单双引号可以互相嵌套\n\n\nBoolean\n布尔（False True）\n\n\nnull\n赋值了但是内容为空\n\n\nundefined\n未赋值\n\n\nSymbol\n\n\n\n4.1.1检测数据类型   typeof\ntypeof：返回一个小写字母的类型字符串\ninstanceof：判断类型。左边必须是引用类型，右边必须是函数\n\nconsole.log(typeof true)\n\n4.1.2NumberNumber类型包含整数和浮点数（浮点数数值必须包含一个小数点，且小数点后面至少有一个数字）两种值\nIEEE745标准规定使用64位双精度\n计算小数加和结果：parseFloat( (0.1+0.2).toFixed(5) )\n数值类型的转换：Number()：可以用于任何的数据类型parseInt(string, number)：提取整数数值，第二个参数为进制paseFloat(string)：提取浮点数值\nNaN：非数字类型，属于Number类型。非法运算符返回NaN，NaN不等于自身。isNaN判断是否为数字。\nconsole.log(&#x27;ab&#x27;/10); // NaNconsole.log(NaN == NaN);// false;console.log(NaN == false);// false;Boolean(Nan) // false\n\n**Infinity**：无穷大，属于Number类型\nInfinity + -Infinity = NaNInfinity + Infinity = Infinity-Infinity + -Infinity = -Infinity\n\n数字的属性\n\n\n\n属性\n描述\n\n\n\nNumber.MAX_VALUE\n可表示的最大值\n\n\nNumber.MIN_VALUE\n可表示的最小值\n\n\nNumber.NaN\n特指”非数字“\n\n\nNumber.NEGATIVE_INFINITY\n特指“负无穷”;在溢出时返回\n\n\nNumber.POSITIVE_INFINITY\n特指“正无穷”;在溢出时返回\n\n\nNumber.EPSILON\n表示1和比最接近1且大于1的最小Number之间的差别\n\n\nNumber.MIN_SAFE_INTEGER\nJavaScript最小安全整数.\n\n\nNumber.MAX_SAFE_INTEGER\nJavaScript最大安全整数.\n\n\n数字的方法\n\n\n\n方法\n描述\n\n\n\nNumber.parseFloat()\n把字符串参数解析成浮点数，     和全局方法 parseFloat() 作用一致.\n\n\nNumber.parseInt()\n把字符串解析成特定基数对应的整型数字，和全局方法 parseInt() 作用一致.\n\n\nNumber.isFinite()\n判断传递的值是否为有限数字。\n\n\nNumber.isInteger()\n判断传递的值是否为整数。\n\n\nNumber.isNaN()\n判断传递的值是否为 NaN. More robust version of the original global isNaN().\n\n\nNumber.isSafeInteger()\n判断传递的值是否为安全整数。\n\n\n4.1.3String字符串的值是不可变的，所以很多的字符串的api不会改变原字符串值其他转字符串：\nlet my = 123;// let my = [&#x27;Chris&#x27;, &#x27;Bob&#x27;, &#x27;Jim&#x27;];let myString = my.toString();\n\n字符串转其他：\nlet my = &quot;true&quot;;console.log(Boolean(my));let my = &quot;123&quot;;console.log(Number(my));\n\n\n\n方法\n说明\n\n\n\nlength\n长度\n\n\nindexOf(‘zilla’)\n子串起始位置\n\n\nslice(0,3)\n提取子串\n\n\ntoLowerCase &#x2F; toUpperCase()\n转换大小写\n\n\nreplace(‘moz’,’van’)\n替换\n\n\n数字前添0：需要添n个0，在前面添n-1个，再截取后n个\n(&#x27;0000&#x27;+num).slice(-3)\n字符串与数字相加：从左到右；加号左右如果有字符串，结果为字符串\n&#x27;10&#x27; + 10.10 = &#x27;1010.1&#x27;1 + 2 + 3 + &#x27;4&#x27; = &#x27;64&#x27;&#x27;1&#x27; + &#123;a:1&#125; = &#x27;1[object Object]&#x27;\n模板字符串：可以使用语法糖让功能的实现代码更具可读性:\nconst five = 5;const ten = 10;console.log(`Fifteen is $&#123;five + ten&#125; and not $&#123;2 * five + ten&#125;.`);// &quot;Fifteen is 15 and not 20.&quot;\n\n4.1.4Boolean其他转boolean：\n【null，undefined，NaN，0，空字符串，只包含空格的字符串】转换为false\n【非空对象，非0，非空字符串】转换为true\nboolean转其他：\nNumber(true): 1 　　　　|| 　　Number(false) : 0String(true):&#x27;true&#x27; 　 || 　　String(false):&#x27;false&#x27;\n\n4.1.5Null空对象指针类型\nNull转其他：\nBooleam(null)  falseNumber(num)    0String(null)  &#x27;null&#x27;\n\n4.1.6Undefined申明了变量但是没有初始化，默认为undefined\nUndefined转其他：\nBoolean(undefined):　 falseNumber(undefined):　  NaNString(undefined):　　&#x27;undefined&#x27;\n\n4.1.7SymbolES6新增的一个基本数据类型，代表独一无二的值，最大的用法是用来定义对象的唯一属性名\nlet id1 = Symbol(&#x27;id&#x27;);let id2 = Symbol(&#x27;id&#x27;);console.log(id1 == id2);  //false\nSymbol属性类型不支持 for…in 和 Object.keys()\n但是也能有方法去访问：Object.getOwnPropertySymbols，方法会返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。\nconsole.log(Object.getOwnPropertySymbols(obj)) // [ Symbol(c) ]\n\n\n\n4.2引用数据类型引用数据类型也叫对象数据类型，包括function,object,array,date,RegExp等可以可以使用new创建的数据，又叫对象类型，他们是存放在堆内存中的数据\n\n\n\n类型\n说明\n\n\n\nArray\n[‘Chris’, ‘Bob’, ‘Jim’]\n\n\nObject\n{ name : ‘Spot’, breed : ‘Dalmatian’ }\n\n\nFunction\n函数\n\n\n5.运算符5.1算数运算符加+     减-   乘*    除&#x2F;   取余%\n5.2赋值运算符&#x3D;\n+&#x3D;  \n-&#x3D;  \n*&#x3D;  \n&#x2F;&#x3D;  \n%&#x3D;\n5.3一元运算符自增：++\n自减： –\n//后置自增：先使用再自增num++num--//前置自增：先自增再使用++num--num\n\n5.4比较运算符\n\n\n符号\n描述\n\n\n\n&gt;\n左边是否大于右边\n\n\n&lt;\n左边是否小于右边\n\n\n&gt;&#x3D;\n左边是否大于或等于右边\n\n\n&lt;&#x3D;\n左边是否小于或等于右边\n\n\n&#x3D;&#x3D;\n左右两边是否相等\n\n\n&#x3D;&#x3D;&#x3D;\n左右两边是否类型和值都相等\n\n\n!&#x3D;&#x3D;\n左右两边是否不全等\n\n\n比较结果为boolean类型，即只会得到true或false\n5.5逻辑运算符\n\n\n符号\n描述\n\n\n\n&amp;&amp;\n与\n\n\n||\n或\n\n\n!\n非（取反）\n\n\n6.语句6.1分支语句6.1.1if语句if(条件)&#123;    内容&#125;else if(条件)&#123;    内容&#125;else&#123;    内容&#125;\n\n6.1.2三元表达式条件 ? 满足条件执行的代码 ： 不满足执行的代码\n\n6.1.3switch语句switch (2) &#123;    case 1:        alert(1)        break    case 2:        alert(2)        break    case 3:        alert(3)        break    default:        alert(&#x27;没有数据&#x27;)&#125;\n\n找到跟小括号里数据全等的case值，并执行里面对应的代码,若没有全等 &#x3D;&#x3D;&#x3D; 的则执行default里的代码\n般需要配合break关键字使用 没有break会造成case穿透\n6.2循环语句6.2.1while语句while(循环条件)&#123;    重复执行的代码&#125;\n\ncontinue：结束本次循环，继续下次循环 \nbreak：跳出所在的循环\n6.2.2for循环for(声明记录循环次数的变量; 循环条件; 变化值)&#123;    循环体&#125;\n\n7.数组Array声明\nlet arr = [&#x27;data1&#x27;,&#x27;data2&#x27;,&#x27;data3&#x27;]\n\n取值\narr[0]\n\n长度\narr.length\n\n增删改查\n//增arr.push(元素1,元素2)//将一个或多个元素添加到数组的*末尾*，*并返回该数组的新长度*arr.unshift(元素1,元素2)//将一个或多个元素添加到数组的*开头*，*并返回该数组的新长度*//删arr.shift()//从数组中删除*第一个*元素，并*返回该元素的值*arr.pop()//从数组中删除*最后一个*元素，并*返回该元素的值*arr.splice(起始位置,删除个数)//从数组中删除*指定*元素//改arr[i] = 新值//查arr[i]\n\n\n\n8.对象Object可以理解为是无序的数据的集合\n声明\nlet 对象名 = &#123;    属性名:属性值;    方法名:函数&#125;\n\n访问属性   调用方法\n// 声明人对象let person = &#123;    name: &#x27;奥特曼&#x27;,    age: 18000,    gender: &#x27;男&#x27;,    jiguang: function () &#123;        console.log(&#x27;biubiubiu&#x27;)    &#125;&#125;// 1. 访问属性    对象.属性名 or  对象[&#x27;属性名&#x27;]console.log(person.uname)console.log(person[&#x27;gender&#x27;])// 2. 调用方法    对象.方法名()person.jiguang()\n\n增删改查\n//增对象.新属性名 = 新值对象.新方法名 = 新函数//删delete 对象名.属性名//改  重新赋值即可对象名.属性名 = 新值对象名.方法名 = 新函数//查对象名.属性名    对象名[&#x27;属性名&#x27;]    对象名.方法名()\n\n遍历对象\nfor (let k in obj) &#123;    console.log(k)  // 打印属性名    console.log(obj[k])  // 打印属性值 \n\nMath\n\n\n\ncode\n描述\n\n\n\nMath.random()\n生成0-1之间的随机数\n\n\nMath.ceil()\n向上取整\n\n\nMath.floor()\n向下取整\n\n\nMath.max()\n取最大值\n\n\nMath.min()\n取最小值\n\n\nMath.pow()\n幂运算\n\n\nMath.abs()\n绝对值\n\n\nMath.round\n就近取整\n\n\n生成n-m的随机数\nMath.floor(Math.random() * (max - min + 1)) + min\n\n\n\n9.函数function可以理解为是无序的数据的集合\n9.1基本使用语法\n//声明function 函数名(形参1,形参2)&#123;  函数体  return  &#125;//调用函数名(实参1,实参2)//关于return/*\t1.使用return关键字能将内部的执行结果交给函数外部使用\t2.函数内部只能出现 1 次 return，并且 return 后面代码不会再被执行,return会立即结束当前函数\t3.函数可以没有 return，这种情况函数默认返回值为 undefined*/\n\n匿名函数\n//可以将匿名函数赋值给一个变量，然后通过变量名调用let fn = functin()&#123;&#125;fn()\n\n立即执行函数\n(function()&#123;console.log(1)&#125;)()\n\n9.2参数9.2.1参数默认值// 设置参数默认值function sayHi(name=&quot;aoteman&quot;, age=20000) &#123;  document.write(`&lt;p&gt;大家好，我叫$&#123;name&#125;，我今年$&#123;age&#125;岁了。&lt;/p&gt;`);&#125;// 调用函数sayHi();sayHi(&#x27;杰克&#x27;);sayHi(&#x27;赛文&#x27;, 30000);\n\n参数的默认值就是在声明参数时为形参赋值\n当没有实参传入时，参数的默认值被当作实参传入\n当有实参传入时，覆盖默认值\n9.2.2arguments// 求和函数  function sum() &#123;    let s = 0;    for(let i = 0; i &lt; arguments.length; i++) &#123;      s += arguments[i];    &#125;    console.log(s);  &#125;  // 调用求和函数  sum(5, 10); // 两个参数  sum(1, 2, 4); // 三个参数\n\n当不确定有多少参数传入时，使用arguments \narguments 是一个伪数组(可以遍历，但是不能使用数组的方法),动态获取函数的实参\n9.2.3剩余参数function config(a,b,...other) &#123;      &#125;config(1, 2, 3, 4, 5, 6);//此时a = 1   b = 2  other = [3,4,5,6]\n\n... 是语法符号，置于最末函数形参之前，用于获取多余的实参\n9.3箭头函数箭头函数是一种声明函数的简洁语法，差异性体现在语法格式上。\nlet fn = (a, b) =&gt; &#123;\treturn a + b;&#125;let re = fn(1, 2);console.log(re);\n\n注意\n\n箭头函数没有函数提升，属于表达式函数\n函数体只有一行代码时，可以省略 { }，并自动作为返回值返回\n只有一个参数值，可以省略 ( )\n箭头函数没有arguments，但可以使用剩余参数\n箭头函数不存在this\n\n10.作用域作用域（scope）规定了变量能够被访问的“范围”，离开了这个“范围”变量便不能被访问，作用域分为全局作用域和局部作用域。\n10.1全局作用域&lt;script&gt; 标签和 .js 文件的【最外层】就是全局作用域，全局作用域中声明的变量，任何其它作用域都可以被访问。\n注意\n\n函数中未使用任何关键字声明的变量为全局变量\n尽可能少的声明全局变量，防止全局变量被污染\n\n10.2函数作用域在函数内部声明的变量只能在函数内部被访问，外部无法直接访问。\n注意\n\n函数内部声明的变量，在函数外部无法被访问\n函数的参数也是函数内部的局部变量\n不同函数内部声明的变量无法互相访问\n函数执行完毕后，函数内部的变量实际被清空了\n\n10.3块级作用域在 JavaScript 中使用 &#123;&#125; 包裹的代码称为代码块，代码块内部声明的变量外部将【有可能】无法被访问。\n注意\n\nlet 声明的变量会产生块作用域，var 不会产生块作用域\nconst 声明的常量也会产生块作用域\n不同代码块之间的变量无法互相访问\n\n10.4作用域链作用域链本质上是底层的变量查找机制，在函数被执行时，会优先查找当前函数作用域中查找变量，如果当前作用域查找不到则会依次逐级查找父级作用域直到全局作用域。\n\n10.5变量&#x2F;函数提升变量提升\n        允许再声明变量前，即被访问。可以使用let定义变量，避免变量提升\n\n        **预解析**   在代码执行前先预解析，把**带有声明**的变量提前解析到**当前作用域**的最前面，**只声明不赋值**\n\n 函数提升\n        **预解析**   会把**具有名字**的函数提前解析到**当前作用域**的最前面，**只定义不调用**。函数表达式，立即执行函数，匿名函数不预解析\n\n10.6let var const变量提升指的是在变量声明之前即被访问。使用let可以避免变量提升。\n\n\n\n关键字\n块级作用域\n变量提升\n初始值\n更改值\n通过window调用\n\n\n\nlet\n√\n×√\n-\n允许\n不允许\n\n\nconst\n√\n×√\nYes\nNo\n不允许\n\n\nvar\n×\n√\n-\n不允许\n允许\n\n\n11.闭包1.闭包可以创建外部可访问的作用域，可以把一个变量的使用范围延伸，避免全局变量污染\n2.闭包的本质仍是函数，从代码的形式上来看是函数返回一个子函数，子函数访问父函数的局部变量\n3.但是过度使用闭包会造成内存泄漏的现象\n12.解构赋值解构赋值语法是一种 Javascript 表达式。通过解构赋值, 可以将属性&#x2F;值从对象&#x2F;数组中取出,赋值给其他变量。\nvar a, b, rest;[a, b] = [10, 20];console.log(a); // 10console.log(b); // 20[a, b, ...rest] = [10, 20, 30, 40, 50];console.log(a); // 10console.log(b); // 20console.log(rest); // [30, 40, 50](&#123; a, b &#125; = &#123; a: 10, b: 20 &#125;);console.log(a); // 10console.log(b); // 20let &#123; a1:b, a2:c &#125; = &#123; a1:1, a2:2 &#125;;console.log(b);console.log(c);// Stage 4（已完成）提案中的特性(&#123;a, b, ...rest&#125; = &#123;a: 10, b: 20, c: 30, d: 40&#125;);console.log(a); // 10console.log(b); // 20console.log(rest); // &#123;c: 30, d: 40&#125;\n\n总结：\n数组\n\n变量的数量大于单元值数量时，多余的变量将被赋值为  undefined\n变量的数量小于单元值数量时，可以通过 ... 获取剩余单元值，但只能置于最末位\n允许初始化变量的默认值，且只有单元值为 undefined 时默认值才会生效\n\n对象\n   1.对象属性的值将被赋值给与属性名相同的变量\n   2.对象中找不到与变量名一致的属性时变量值为 undefined\n   3.允许初始化变量的默认值，属性不存在或单元值为 undefined 时默认值才会生效\n13.面向对象13.1构造函数构造函数是专门用于创建对象的函数，如果一个函数使用 new 关键字调用，那么这个函数就是构造函数。\n// 定义构造函数 function foo() &#123;    &#125; // 调用函数 new foo();\n\n\n使用 new 关键字调用函数的行为被称为  实例化\n实例化构造函数时没有参数时可以省略 （）\n构造函数的返回值即为新创建的对象\n构造函数内部的 return 返回的值无效\n建议构造函数名称的首字母大写\n\n13.2实例成员实例成员只能由实例对象访问\n// 构造函数  function Person() &#123;    // 构造函数内部的 this 就是实例对象    // 实例对象中动态添加属性    this.name = &#x27;小明&#x27;;    // 实例对象动态添加方法    this.sayHi = function () &#123;    &#125;  &#125;  // 实例化，p1是实例对象  // p1 实际就是 构造函数内部的 this  let p1 = new Person();  console.log(p1);  console.log(p1.name); // 访问实例属性  p1.sayHi(); // 调用实例方法  p1 instanceof Person//判断对象p1是否是构造函数Person的实例对象  p1.constructor // 直接返回p1的构造函数\n\n\n构造函数内部 this 实际上就是实例对象，为其动态添加的属性和方法即为实例成员\n为构造函数传入参数，动态创建结构相同但值不同的对象\n实例对象的 constructor  属性指向了构造函数\ninstanceof 用于检测实例对象对应的构造函数\n构造函数创建的实例对象彼此独立互不影响。\n\n13.3静态成员静态成员只能由构造函数访问\nfunction Person(name, age) &#123;    // 省略实例成员  &#125;  // 静态属性  Person.eyes = 2;  Person.arms = 2;  // 静态方法  Person.walk = function () &#123;    // this 指向 Person    console.log(this.eyes);  &#125;\n\n\n静态成员指的是添加到构造函数本身的属性和方法\n一般公共特征的属性或方法静态成员设置为静态成员\n静态成员方法中的 this 指向构造函数本身\n\n13.4引用类型13.4.1Object\n\n\ncode\n解释\n\n\n\nObject.keys(obj)\n获取obj对象的所有键，以数组的形式返回\n\n\nObject.values(obj)\n获取obj对象的所有值，以数组的形式返回\n\n\n13.4.2Array//所有arr都相当于是Array构造的let arr = new Array(1,2,3)arr instanceof Array//1.concat数组拼接  let newarr = arr.concat(arr1,arr2)//2.sort数组排序    从小到大let newarr = arr.sort(function(a,b)&#123;return a-b&#125;)//3.join连接数组的每个元素成为字符串let str = arr.join(&#x27;-&#x27;)//4.reverse翻转数组顺序let newarr = arr.reverse()//5.from伪数组转真数组   伪数组中必须有length属性let newarr = Array.from(伪数组)//6.indexOf查找某个元素在数组中首次出现的索引值let num = arr.indexOf(&#x27;a&#x27;)//7.lastIndexOf查找某个元素在数组中最后出现的索引值let num = arr.lastIndexOf(&#x27;a&#x27;)//8.forEach遍历数组    第一个元素表示数组中的每一项，第二个表示每一项的下标，第三个表示数组本身arr.forEach(function(item,index,o)&#123;&#125;)//9.find用于查找首次出现的满足条件的值let re = arr.find(function(item,index,o)&#123;    return item &gt; 5&#125;)//10.findIndex用于查找首次出现的满足条件的值，返回找到的下标let re = arr.findIndex(function(item,index,o)&#123;    return item &gt; 5&#125;)//11.some用于查找，如果有一个满足，返回truearr.some(function(item,index,o)&#123;    return item &gt; 5&#125;)//12.every用于查找，全部满足，返回truearr.every(function(item,index,o)&#123;    return item &gt; 5&#125;)//13.filter筛选数组，把满足条件的元素放入新数组返回let newarr = arr.every(function(item,index,o)&#123;    return item &gt; 5&#125;)//14.map遍历数组，让每个元素都执行一遍回调函数，把所有结果放入新数组返回let newarr = [1,2,3,4].map(function(item,index,o)&#123;    return item * item&#125;)\n\n13.5包装类型在 JavaScript 中的字符串、数值、布尔具有对象的使用特征，之所以具有对象特征的原因是字符串、数值、布尔类型数据是 JavaScript 底层使用 Object 构造函数“包装”来的，被称为包装类型。\n13.4.1String//1. length 获取字符串长度str.length//2. trim 去除两端空白符let newstr = str.trim()//3.split 分割字符串，成数组let newstr = str.splic(&#x27;c&#x27;)//4. toLowerCase toUpperCase 字母转换大小写let newstr = str.toLowerCase(&#x27;c&#x27;)//5. indexOf lastIndexOf查找某个元素首次出现的索引值let num = str.indexOf(&#x27;c&#x27;)//6. slice 字符串截取  从start索引值截到end索引值 左闭右开let newstr = str.slice(start,end)//7. substring 字符串截取  会自动把小值放前面，大值放后面let newstr = str.substring(start,end)//8. substr 字符串截取 从start索引位置开始截取length个let newstr = str.substr(start,length)\n\n13.4.2Number//1. toFixed  保留几位有效数字price = prince.toFixed(2)Number.parseInt()Number.parseFloat()\n\n13.6封装封装的本质是将具有关联的代码组合在一起，其优势是能够保证代码复用且易于维护，函数是最典型也是最基础的代码封装形式，面向对象思想中的封装仍以函数为基础，但提供了更高级的封装形式。\n\n13.6.1构造函数构造函数相当于一个&quot;模子&quot;，能够像字面量那样创建出对象来，所不同的是借助构造函数创建出来的实例对象之间是**彼此不影响**的。\n\n13.6.2原型对象实际上每一个构造函数都有一个名为 `prototype` 的属性，译成中文是原型的意思，`prototype` 的是对象类据类型，称为构造函数的原型对象，每个原型对象都具有 `constructor` 属性代表了该原型对象对应的构造函数。\t\n\n每次new会产生一块内存空间保存相同的函数，会造成内存浪费，所以可以把相同的方法保存到原型对象中去。\n\nfunction Person() &#123;     &#125;  // 每个函数都有 prototype 属性console.log(Person.prototype);\n\n当访问对象的属性或方法时，先在当前实例对象是查找，然后再去原型对象查找，并且原型对象被所有实例共享。\n13.6.3原型链\n//构造函数   放公共属性function Person(name,age)&#123;    this.name = name    this.age = age&#125;//原型对象   放公共方法Person.prototype.eat = function()&#123;&#125;//实例对象let obj = new Person(&#x27;aoteman&#x27;,30000)//特殊属性额外加obj.skin = &#x27;yellow&#x27;\n\n\n\n13.7继承继承是面向对象编程的另一个特征，通过继承进一步提升代码封装的程度，JavaScript 中大多是借助原型对象实现继承的特性。\n//第一步:创建公共构造函数function People()&#123;    this.head = 1    this.eat = function()&#123;&#125;&#125;//第二步：创建需要继承的函数function Star()&#123;    this.money = &#x27;a lot&#x27;&#125;//第三步：公共构造函数的实例对象赋值给继承函数的原型对象Star.prototype = new People()//第四步：指回构造函数本身Star.prototype.constructor = Star\n\n14. this指向14.1this指向\n\n\n\n指向\n\n\n\n普通函数\nwindow\n\n\n方法\n调用者对象\n\n\n定时器\n调用者\n\n\n立即执行函数\nwindow,调用者\n\n\n构造函数\n实例化对象\n\n\n事件处理函数\n事件源\n\n\n箭头函数\n没有this，this指向上级作用域的this\n\n\n14.2改变this指向\n//1.call     会立即执行函数名.call(this指向,参数,参数2)//2.apply    会立即执行函数名.apply(this指向,[参数1,参数2])//3.bind     不会立即执行，而是产生新函数函数名.bind(this指向,参数1,参数2)\n\n总结：\ncall\n\ncall 方法能够在调用函数的同时指定 this 的值\n使用 call 方法调用函数时，第1个参数为 this 指定的值\ncall 方法的其余参数会依次自动传入函数做为函数的参数\n\napply\n\napply方法能够在调用函数的同时指定this&#96; 的值\n使用 apply 方法调用函数时，第1个参数为 this 指定的值\napply 方法第2个参数为数组，数组的单元值依次自动传入函数做为函数的参数\n\nbind\n`bind` 方法并**不会调用函数**，而是创建一个指定了 `this` 值的新函数\n\n15.类Class15.1封装//创建类class Person&#123;    &#125;//实例化let p = new Person()\n\n15.2添加成员class Person&#123;    //静态成员    static language = &#x27;Chinese&#x27;\tstatic kungfu = function()&#123;&#125;&#125;//访问静态属性和静态方法console.log(Person.language)Person.kungfu()\n\n\nstatic 关键字用于声明静态属性和方法\n静态属性和方法直接通过类名进行访问\n静态成员只能由构造函数访问\n\nclass Person&#123;    //实例成员    name = &#x27;aoteman&#x27;\tjiguang()&#123;&#125;&#125;let p = new Person()//访问实例属性和实例方法console.log(p.name)p.jiguang()\n\n\n实例成员只能实例调用\n\n15.3继承class Father&#123;    //构造函数    //需要用constructor传入参数    constructor(name,age)&#123;        this.name = name        this.age = age    &#125;    houses = 2\tskill()&#123;&#125;&#125;//声明子类Son继承父类Fatherclass Son extends Father&#123;    //子类的构造函数    constructor(name,age,score)&#123;        //如果子类有自己的constructor，必须调用super才能调用父类        super(name,age)        this.score = score    &#125;    skill()&#123;super.skill()&#125;//如果依旧想调用父类的方法，也用super&#125;//实例化let son = new Son(&#x27;jack&#x27;,20,100)\n\nextends 是 ECMAScript 6 中实现继承的简洁语法\n子类构造函数中的 super 函数的作用是可以将子类实例化时获得的参数传入父类的构造函数之中。\nclass Person &#123;  constructor(first, last, age, gender, interests) &#123;    this.name = &#123;      first,      last    &#125;;    this.age = age;    this.gender = gender;    this.interests = interests;  &#125;  greeting() &#123;    console.log(`Hi! I&#x27;m $&#123;this.name.first&#125;`);  &#125;;  farewell() &#123;    console.log(`$&#123;this.name.first&#125; has left the building. Bye for now!`);  &#125;;      // 静态方法  static statciFunc() &#123;    console.log(&#x27;我是静态方法，this拿不到实例对象&#x27;);  &#125;      // get方法  get subject() &#123;   // person.subject    return this._subject;  &#125;  // set方法  set subject(newSubject) &#123; // person.subject = &quot;math&quot;    this._subject = newSubject;  &#125;&#125;// 继承// Teacher.__proto__ = Personclass Teacher extends Person &#123;  constructor(first, last, age, gender, interests, subject, grade) &#123;    super(first, last, age, gender, interests);    // subject and grade are specific to Teacher    this.subject = subject;    this.grade = grade;  &#125;&#125;\n\n相当于：\nfunction Person(first, last, age, gender, interests) &#123;    this.name = &#123;      first,      last    &#125;;    this.age = age;    this.gender = gender;    this.interests = interests;&#125;Person.prototype.greeting = () =&gt; &#123;&#125;Person.prototype.farewell = () =&gt; &#123;&#125;function Teacher(first, last, age, gender, interests, subject, grade) &#123;    Person.call(this, first, last, age, gender, interests); // 调用父原型构造函数  \tthis.subject = subject;    this.grade = grade;&#125;Teacher.__proto__ = Person.prototype;\n\n\n\n16.深浅拷贝16.1浅拷贝只拷贝最外层的拷贝方式\nlet obj = &#123;\t\t\tuname : &#x27;张三丰&#x27;,\t\t\tage : 22,\t\t\tsex : &#x27;男&#x27;,\t\t\tcolor : [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;yellow&#x27;, &#x27;pink&#x27;],\t\t\tmessage : &#123;\t\t\t\tindex : 1,\t\t\t\tscore : 99\t\t\t&#125;\t\t&#125;let newObj = &#123;&#125;Object.assign(newObj, obj)\n\n16.2深拷贝拷贝所有内容\nlet obj = &#123;\tuname : &#x27;张三丰&#x27;,\tage : 22,\tsex : &#x27;男&#x27;,\tcolor : [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;yellow&#x27;, &#x27;pink&#x27;],\tmessage : &#123;\t\tscore : 99,\t\tindex : 6,\t&#125;&#125;let newObj = &#123;&#125;// 遍历// 如果遇到obj[key]是复杂类型，再遍历操作function kaobei (newObj, obj) &#123;\tfor ( let key in obj ) &#123;\t\tif ( obj[key] instanceof Array ) &#123;// obj[key] 是数组\t\t\t// 保证newObj[key]是数组\t\t\tnewObj[key] = [];\t\t\tkaobei(newObj[key], obj[key]);\t\t&#125; else if ( obj[key] instanceof Object ) &#123;// obj[key] 是对象\t\t\t// 保证newObj[key]是对象\t\t\tnewObj[key] = &#123;&#125;;\t\t\tkaobei(newObj[key], obj[key])\t\t&#125; else &#123;\t\t\tnewObj[key] = obj[key];\t\t&#125;\t&#125;&#125;kaobei(newObj, obj);\n\n17.JS执行机制17.1 JS介绍JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。所有任务需要排队，前一个任务结束，才会执行后一个任务。这样所导致的问题是： 如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。\n\n17.2同步和异步同步和异步的本质区别是，各个流程的执行顺序不同\n17.2.1同步前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的\n\n同步任务都在主线程执行，形成一个**执行栈**\n\n17.2.2异步在做一件事的时候可以去处理其他事情\n\n异步任务是通过回调函数实现的，一般包括：1.普通事件（click,resize）2.资源加载事件（load.error）3.定时器（setInterval,setTimeout）\n\n异步任务添加到任务队列中\n\n17.3执行顺序\n先执行执行栈中的同步任务。\n当有异步任务时，提交给对应的异步进程处理，完毕后推入任务队列\n当主线程执行完毕，查询任务队列，取出一个任务，推入主线程处理。重复该动作。—事件循环\n\n18. 防抖和节流18.1防抖**防抖策略**(debounce)，当事件被触发之后，**延迟n秒**，再**执行回调**，如果在这n秒内事件**又被触发**，则**重新计时**。\n\n**应用场景**\t用户在输入框中连续输入一串字符时，可以通过防抖策略，只有输入完成之后，才执行查询请求，这样可以有效减少请求次数，节约请求资源。\n\nfunction debounce(fn, delay) &#123;//定义防抖动的函数  let timer = null;  //防抖动的timer  return function () &#123;    if (timer) clearTimeout(timer)    timer = setTimeout(() =&gt; &#123; // 箭头函数绑定闭包函数的this      fn.apply(this, arguments)    &#125;, delay)  &#125;&#125;// 测试function task() &#123;  console.log(&#x27;run task&#x27;)&#125;const debounceTask = debounce(task, 1000)window.addEventListener(&#x27;scroll&#x27;, debounceTask)\n\n18.2 节流**节流策略**（throttle），可以减少一段时间内事件的触发频率。**触发过一次后要等一定时间才能触发下一次**，关键是检测定时任务是否结束\n\n**应用场景**\t\n\n    鼠标连续不断地触发某事件（如点击），只在单位时间内只触发一次；\n\n    懒加载时要监听计算滚动条的位置，但不必每次滑动都触发，可以降低计算的频率，而不必去浪费 CPU 资源\n\n// 定时器实现function throttle(func, delay) &#123;  let timer;  return function () &#123;    if (!timer) &#123;      timer = setTimeout(() =&gt; &#123;        timer = null;        func.apply(this, arguments);      &#125;, delay);    &#125;  &#125;;&#125;// 使用时间戳function throttle(fn, delay) &#123;  let last = 0 // 上次触发时间  return (...args) =&gt; &#123;    const now = Date.now()    if (now - last &gt; delay) &#123;      last = now      fn.apply(this, args)    &#125;  &#125;&#125;\n\n防抖：如果事件被频繁触发，防抖能保证只有最有一次触发生效！前面 N 多次的触发都会被忽略！节流：如果事件被频繁触发，节流能够减少事件触发的频率，因此，节流是有选择性地执行一部分事件！\n脚本阻塞HTML 元素是按其在页面中出现的次序调用的，如果用 JavaScript 来管理页面上的元素（更精确的说法是使用 文档对象模型 DOM），若 JavaScript 加载于欲操作的 HTML 元素之前，则代码将出错。\n\nasync：不会阻塞页面渲染，而是直接下载然后运行。这样脚本的运行次序就无法控制，只是脚本不会阻止剩余页面的显示。当页面的脚本之间彼此独立，且不依赖于本页面的其它任何脚本时，async 是最理想的选择。\ndefer ：脚本异步下载，在html解析后再同步加载\n\nJavaScript，API和其他JavaScript工具之间的关系\nJavaScript：一种内置于浏览器的高级脚本语言，您可以用来实现Web页面&#x2F;应用中的功能。注意JavaScript也可用于其他象Node这样的的编程环境。\n客户端API ：内置于浏览器的结构程序，位于JavaScript语言顶部，使您可以更容易的实现功能。\n第三方API ：置于第三方普通的结构程序（例如Twitter，Facebook），使您可以在自己的Web页面中使用那些平台的某些功能（例如在您的Web页面显示最新的Tweets）。通常来说，这首先需要您通过一个 &lt;script&gt; 元素连接到第三方服务器所开放的JavaScript库。\nJavaScript库：通常是包含具有特定功能的一个或多个JavaScript文件，把这些文件关联到您的Web页以快速或授权编写常见的功能。例如包含jQuery和Mootools\nJavaScript框架：从库开始的下一步，JavaScript框架视图把HTML、CSS、JavaScript和其他安装的技术打包在一起，然后用来从头编写一个完整的Web应用。\n\nweb浏览器的重要部分\nnavigator：表示浏览器存在于web上的状态和标识（即用户代理）。在JavaScript中，用Navigator来表示。你可以用这个对象获取一些信息，比如来自用户摄像头的地理信息、用户偏爱的语言、多媒体流等等。\nwindow：载入浏览器的标签，在JavaScript中用Window对象来表示，使用这个对象的可用方法，你可以返回窗口的大小（参见Window.innerWidth和Window.innerHeight），操作载入窗口的文档，存储客户端上文档的特殊数据（例如使用本地数据库或其他存储设备），为当前窗口绑定event handler，等等。\ndocument（在浏览器中用DOM表示）：载入窗口的实际页面，在JavaScript中用Document 对象表示，你可以用这个对象来返回和操作文档中HTML和CSS上的信息。例如获取DOM中一个元素的引用，修改其文本内容，并应用新的样式，创建新的元素并添加为当前元素的子元素，甚至把他们一起删除。\n\n\n\n\n\n类型\n插入位置\n拼接方法\n覆盖问题\n\n\n\ndocument.write()\ndocument对象方法\n脚本元素script的位置\n多次调用\n文档解析完会覆盖；否则不会\n\n\ninnerHTML\nElement对象属性\n指定元素内\n+&#x3D;\n会覆盖\n\n\n内存管理标记-清除算法\n这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。\n从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进。\n严格模式严格模式对正常的 JavaScript语义做了一些更改。\n\n严格模式通过抛出错误来消除了一些原有静默错误。\n严格模式修复了一些导致 JavaScript引擎难以执行优化的缺陷：有时候，相同的代码，严格模式可以比非严格模式下运行得更快。\n严格模式禁用了在ECMAScript的未来版本中可能会定义的一些语法。\n\n// 整个脚本都开启严格模式的语法&quot;use strict&quot;;var v = &quot;Hi!  I&#x27;m a strict mode script!&quot;;\n\n合并均为严格模式的脚本或均为非严格模式的都没问题，只有在合并严格模式与非严格模式有可能有问题。建议按一个个函数去开启严格模式\nfunction strict() &#123;  // 函数级别严格模式语法  &#x27;use strict&#x27;;  function nested() &#123;    return &quot;And so am I!&quot;;  &#125;  return &quot;Hi!  I&#x27;m a strict mode function!  &quot; + nested();&#125;\n\nMaplet sayings = new Map();sayings.set(&#x27;dog&#x27;, &#x27;woof&#x27;);sayings.set(&#x27;cat&#x27;, &#x27;meow&#x27;);sayings.set(&#x27;elephant&#x27;, &#x27;toot&#x27;);sayings.size; // 3sayings.get(&#x27;fox&#x27;); // undefinedsayings.has(&#x27;bird&#x27;); // falsesayings.delete(&#x27;dog&#x27;);sayings.has(&#x27;dog&#x27;); // falsefor (let [key, value] of sayings) &#123;  console.log(key + &#x27; : &#x27; + value);&#125;sayings.clear();sayings.size; // 0\n\nObject和Map的比较\n一般地，objects会被用于将字符串类型映射到数值。Object允许设置键值对、根据键获取值、删除键、检测某个键是否存在。而Map具有更多的优势。\n\nObject的键均为String类型，在Map里键可以是任意类型。\n必须手动计算Object的尺寸，但是可以很容易地获取使用Map的尺寸。\nMap的遍历遵循元素的插入顺序。\nObject有原型，所以映射中有一些缺省的键。（可以用 map = Object.create(null) 回避）。\n\n这三条提示可以帮你决定用Map还是Object：\n\n如果键在运行时才能知道，或者所有的键类型相同，所有的值类型相同，那就使用Map。\n如果需要将原始值存储为键，则使用Map，因为Object将每个键视为字符串，不管它是一个数字值、布尔值还是任何其他原始值。\n如果需要对个别元素进行操作，使用Object。\n\nSetlet mySet = new Set();mySet.add(1);mySet.add(&quot;some text&quot;);mySet.add(&quot;foo&quot;);mySet.has(1); // truemySet.delete(&quot;foo&quot;);mySet.size; // 2for (let item of mySet) console.log(item);// 1// &quot;some text&quot;\n\n数组和集合的转换\n可以使用Array.from或展开操作符来完成集合到数组的转换。同样，Set的构造器接受数组作为参数，可以完成从Array到Set的转换。需要重申的是，Set对象中的值不重复，所以数组转换为集合时，所有重复值将会被删除。\nArray.from(mySet);[...mySet2];mySet2 = new Set([1,2,3,4]);\n\nArray和Set的对比\n一般情况下，在JavaScript中使用数组来存储一组元素，而新的集合对象有这些优势：\n\n数组中用于判断元素是否存在的indexOf 函数效率低下。\nSet对象允许根据值删除元素，而数组中必须使用基于下标的 splice 方法。\n数组的indexOf方法无法找到NaN值。\nSet对象存储不重复的值，所以不需要手动处理包含重复值的情况。\n\n模块js的模块文件后缀可以写成：.mjs\nmodule.exports &amp; exports\nexports：返回的是模块函数module.exports：返回的是模块对象本身，返回的是一个类\n\nexport / export default / import : 只有es6 支持的导出引入\nexport 和 export default\n\nexport与export default均可用于导出常量、函数、文件、模块等\n在一个文件或模块中，export、import可以有多个，export default仅有一个\n通过export方式导出，在导入时要加{ }，export default则不需要\nexport能直接导出变量表达式，export default不行。\n\nimport引入export导出的内容。\n\nmodule.exports / exports  : 只有 node 支持的导出\nNode里面的模块系统遵循的是CommonJS规范。\n\nCommonJS定义的模块分为: 模块标识(module)、模块定义(exports) 、模块引用(require)。\n\n在一个node执行一个文件时，会给这个文件内生成一个 exports 和 module 对象，而 module 又有一个 exports 属性。他们都指向一块内存区域：exports = module.exports = &#123;&#125;，也就是两个指针。真正被 require 出去的内容还是 module.exports 指向的内容。所以尽量都用 module.exports 导出，然后用require导入。\n\nrequire: node 和 es6 都支持的引入\n配合 module.exports 使用\n\n\n//主文件 app.jsimport count from &#x27;./count.j&#x27;//导入模块console.log(count.add(3,4));//取出对象console.log(count.pi);\n\n//模块文件 count.js,与主文件在同一目录下export var add=(a,b)=&gt;&#123;\treturn &#x27;the sum is &#x27;+(a+b);&#125;export var pi=3.14;// 默认导出// 很容易地使模块提供默认功能，并且还可以帮助JavaScript模块与现有的CommonJS和AMD模块系统进行互操作export default function(ctx) &#123;  ...&#125;  // 重命名export &#123;  function1 as newFunctionName,  function2 as anotherNewFunctionName&#125;;    // 导出模块对象import * as Module from &#x27;/modules/module.mjs&#x27;;\n\n模块与类\nclass Square &#123;  constructor(ctx, listId, length, x, y, color) &#123;    ...  &#125;  draw() &#123;    ...  &#125;  ...&#125;  export &#123; Square &#125;;import &#123; Square &#125; from &#x27;./modules/square.mjs&#x27;;      // 或默认导出export default class Square &#123;&#125;\n\n动态加载模块\nimport(&#x27;/modules/myModule.mjs&#x27;)    .then((module) =&gt; &#123;    // Do something with the module.&#125;);\n\n\n\n\n\n异步JavaScript 传统上是单线程的。即使有多个内核，也只能在单一线程上运行多个任务，此线程称为主线程（main thread）。\n通过 Web workers 可以把一些任务交给一个名为worker的单独的线程，这样就可以同时运行多个JavaScript代码块。一般来说，用一个worker来运行一个耗时的任务，主线程就可以处理用户的交互（避免了阻塞）\n事件循环有两个队列，分别存放宏任务和微任务，一次事件循环为：一个宏任务 + 清空微任务队列，直到宏任务清空为止\n宏任务：包括整体代码script，setTimeout，setInterval等\n微任务：Promise.then，process.nextTick，MutationObserver等\n\nPromises异步回调\n我们来谈谈订购披萨作为类比。为了使你的订单成功，你必须按顺序执行，不按顺序执行或上一步没完成就执行下一步是不会成功的：\n\n选择配料。如果你是优柔寡断，这可能需要一段时间，如果你无法下定决心或者决定换咖喱，可能会失败。\n下订单。返回比萨饼可能需要一段时间，如果餐厅没有烹饪所需的配料，可能会失败。\n然后你收集你的披萨吃。如果你忘记了自己的钱包，那么这可能会失败，所以无法支付比萨饼的费用！\n\n对于旧式callbacks，上述功能的伪代码表示可能如下所示：\nchooseToppings(function(toppings) &#123;  placeOrder(toppings, function(order) &#123;    collectOrder(order, function(pizza) &#123;      eatPizza(pizza);    &#125;, failureCallback);  &#125;, failureCallback);&#125;, failureCallback);\n\n异步回调的缺陷：\n\n嵌套回调可能很麻烦且难以阅读（即“回调地狱”）\n每层嵌套都需要故障回调，而使用promises，您只需使用一个.catch（）代码块来处理整个链的错误。\n异步回调不是很优雅。\nPromise回调总是按照它们放在事件队列中的严格顺序调用;异步回调不是。\n当传入到一个第三方库时，异步回调对函数如何执行失去完全控制。\n\nPromise \nPromises是一个对象，代表操作的中间状态。虽然 Promise 并不保证操作在何时完成并返回结果，但是它保证当结果可用时（fullfilled），你的代码能正确处理结果，当结果不可用时，你的代码同样会被执行，来优雅的处理错误。\nPromise 对象有以下几种状态：\n\npending：初始的状态，即正在执行，不处于 fulfilled 或 rejected 状态。\nfulfilled：成功的完成了操作。\nrejected：失败，没有完成操作。\nsettled：Promise 处于 fulfilled 或 rejected 二者中的任意一个状态, 不会是 pending。\n\nmyPromise.then(response =&gt; &#123;  doSomething(response);&#125;).catch(e =&gt; &#123;  returnError(e);&#125;).finally(() =&gt; &#123;  runFinalCode();&#125;);\n\nPromises使得上面的情况更容易编写，解析和运行。如果我们使用异步promises代表上面的伪代码，我们最终会得到这样的结果：\nchooseToppings().then(function(toppings) &#123;  return placeOrder(toppings);&#125;).then(function(order) &#123;  return collectOrder(order);&#125;).then(function(pizza) &#123;  eatPizza(pizza);&#125;).catch(failureCallback);\n\n只需要一个.catch()块来处理所有错误，它不会阻塞主线程，并保证每个操作在运行之前等待先前的操作完成。\n使用箭头函数，你可以进一步简化代码：\nchooseToppings().then(toppings =&gt; placeOrder(toppings)).then(order =&gt; collectOrder(order)).then(pizza =&gt; eatPizza(pizza)).catch(failureCallback);\n\n最基本的，promise与事件监听器类似，但有一些差异：\n\n一个promise只能成功或失败一次。它不能成功或失败两次，并且一旦操作完成，它就无法从成功切换到失败，反之亦然。\n如果promise成功或失败并且你稍后添加成功&#x2F;失败回调，则将调用正确的回调，即使事件发生在较早的时间。\n\n例：fetch用来下载一张图片，返回response对象；判断是否成功下载，成功下载返回blob对象；将blob对象解析放入image；catch失败的情况。\nfetch(&#x27;coffee.jpg&#x27;).then(response =&gt; &#123;  if (!response.ok) &#123;    throw new Error(`HTTP error! status: $&#123;response.status&#125;`);  &#125; else &#123;    return response.blob();  &#125;&#125;).then(myBlob =&gt; &#123;  let objectURL = URL.createObjectURL(myBlob);  let image = document.createElement(&#x27;img&#x27;);  image.src = objectURL;  document.body.appendChild(image);&#125;).catch(e =&gt; &#123;  console.log(&#x27;There has been a problem with your fetch operation: &#x27; + e.message);&#125;);\n\n\n\n响应多个Promises\n如果它们都实现，那么数组中的结果将作为参数传递给.then()块中的执行器函数。如果传递给Promise.all()的任何一个 promise 拒绝，整个块将拒绝。\nPromise.all([a, b, c]).then(values =&gt; &#123;  ...&#125;);\n\n\n\n自定义Promise\n成功resolve，失败reject。reject会被 catch 到\nfunction timeoutPromise(message, interval) &#123;    return new Promise((resolve, reject) =&gt; &#123;        if (message === &#x27;&#x27; || typeof message !== &#x27;string&#x27;) &#123;            reject(&#x27;Message is empty or not a string&#x27;);        &#125; else if (interval &lt; 0 || typeof interval !== &#x27;number&#x27;) &#123;            reject(&#x27;Interval is negative or not a number&#x27;);        &#125; else &#123;            setTimeout(function () &#123;                resolve(message);            &#125;, interval);        &#125;    &#125;);&#125;;\n\n\n\nasync和awaitES6里新增的基于promises的语法糖，使异步代码更易于编写和阅读。\n异步函数 async\n将函数变为promise\n// 定义异步函数的三种方法async function hello() &#123; return &quot;Hello&quot; &#125;; let hello = async function() &#123; return &quot;Hello&quot; &#125;;let hello = async () =&gt; &#123; return &quot;Hello&quot; &#125;;hello(); // 返回promisehello().then((value) =&gt; console.log(value)) // 使用promise\n\n异步promise await\nawait 只在异步函数里面才起作用。它可以放在任何异步的，基于 promise 的函数之前。它会阻塞其后的代码，直到promise完成，然后返回结果值。在暂停的同时，其他正在等待执行的代码就有机会执行了。await 相当于 Promise 的 then。\nasync function hello() &#123;  return greeting = await Promise.resolve(&quot;Hello&quot;);&#125;;hello().then(alert);\n\n\n\n例：fetch用来下载一张图片，返回response对象；判断是否成功下载，成功下载返回blob对象；将blob对象解析放入image；catch失败的情况。\nasync function myFetch(url) &#123;    let response = await fetch(url);    return await response.blob();&#125;myFetch(&#x27;https://img2.baidu.com/it/u=73016861,4243186123&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=499&amp;h=253&#x27;).then((blob) =&gt; &#123;    let objectURL = URL.createObjectURL(blob);    let image = document.createElement(&#x27;img&#x27;);    image.src = objectURL;    document.body.appendChild(image);&#125;).catch(e =&gt; &#123;    console.log(&#x27;There has been a problem with your fetch operation: &#x27; + e.message);&#125;);\n\n\n\nPromise.all()\nlet values = await Promise.all([coffee, tea, description]);\n\n\n\nasync&#x2F;await的缺陷\nawait 关键字会阻塞其后的代码，直到promise完成，就像执行同步操作一样。它确实可以允许其他任务在此期间继续运行，但您自己的代码被阻塞。\n这意味着您的代码可能会因为大量await的promises相继发生而变慢。每个await都会等待前一个完成，而你实际想要的是所有的这些promises同时开始处理（就像我们没有使用async/await时那样）。\n有一种模式可以缓解这个问题——通过将 Promise 对象存储在变量中来同时开始它们，然后等待它们全部执行完毕。\n// 改进前async function timeTest() &#123;  await timeoutPromise(3000);  await timeoutPromise(3000);  await timeoutPromise(3000);&#125;// 改进后async function timeTest() &#123;  const timeoutPromise1 = timeoutPromise(3000);  const timeoutPromise2 = timeoutPromise(3000);  const timeoutPromise3 = timeoutPromise(3000);  await timeoutPromise1;  await timeoutPromise2;  await timeoutPromise3;&#125;\n\n\n\nAsync&#x2F;await 的类方法\n最后值得一提的是，我们可以在类&#x2F;对象方法前面添加async，以使它们返回promises，并await它们内部的promises。\nclass Person &#123;  constructor(first, last, age, gender, interests) &#123;    this.name = &#123;      first,      last    &#125;;    this.age = age;    this.gender = gender;    this.interests = interests;  &#125;  async greeting() &#123;    return await Promise.resolve(`Hi! I&#x27;m $&#123;this.name.first&#125;`);  &#125;;  farewell() &#123;    console.log(`$&#123;this.name.first&#125; has left the building. Bye for now!`);  &#125;;&#125;let han = new Person(&#x27;Han&#x27;, &#x27;Solo&#x27;, 25, &#x27;male&#x27;, [&#x27;Smuggling&#x27;]);\n\n第一个实例方法可以使用如下：\nhan.greeting().then(console.log);\n\n","categories":["前端"],"tags":["JavaScript"]},{"title":"7.和小达一起学HTTP协议","url":"/2022/08/11/7.%E5%92%8C%E5%B0%8F%E8%BE%BE%E4%B8%80%E8%B5%B7%E5%AD%A6HTTP%E5%8D%8F%E8%AE%AE/","content":"1.About HTTP协议1.1通信​\t通信就是信息的传递和交换\n​\t通信的三要素：1.通信的主体\t2.通信的内容\t3.通信的方式\n​\t\t例如：服务器把关于M78星云的相关信息响应给客户端浏览器，通信的主体是服务器和客户端浏览器，通信的内容是M78星云的相关信息，通信的方式是响应。\n1.2通信协议​\t通信协议（Communication Protocol）是指通信的双方完成通信所必须遵守的规则和约定。\n​\t客户端和服务器之间要实现网页内容的传输，通信双方必须遵守网页内容的传输协议。因为网页的内容叫做超文本，因此网页内容的传输协议叫做超文本传输协议(Hyper Text Transfer Protocol),即HTTP协议，规定了客户端与服务器之间进行网页内容传输时必须遵守的传输格式。\n1.3交互模型​\tHTTP协议采用了请求&#x2F;响应的交互模型。\n2.HTTP请求消息2.1概念​\tHTTP协议是客户端浏览器和服务器之间的通信协议，所以客户端浏览器发起的请求叫HTTP请求，客户端发送到服务器的消息叫HTTP请求消息，又叫HTTP请求报文\n2.2HTTP请求消息的组成部分​\tHTTP请求消息由请求行(request line),请求头部(header),空行，请求体四部分组成。\n2.2.1请求行​\t\t请求行由请求方式、URL 和 HTTP 协议版本 3 个部分组成，他们之间使用空格隔开。\nGET /api/post HTTP/1.1\n\n2.2.2请求头部​\t请求头部用来描述客户端的基本信息，从而把客户端相关的信息告知服务器。比如：**User-Agent 用来说明当前是什么类型的浏览器；Content-Type 用来描述发送到服务器的数据格式；Accept 用来描述客户端能够接收什么类型的返回内容；Accept-Language 用来描述客户端期望接收哪种人类语言的文本内容。​\t请求头部由多行 键&#x2F;值对 **组成，每行的键和值之间用英文的冒号分隔。\n\n\n\n头部字段\n说明\n\n\n\nHost\n要请求的服务器域名\n\n\nConnection\n客户端与服务器的连接方式(close 或 keepalive)\n\n\nContent-Length\n用来描述请求体的大小\n\n\nAccept\n客户端可识别的响应内容类型列表\n\n\nUser-Agent\n产生请求的浏览器类型\n\n\nContent-Type\n客户端告诉服务器实际发送的数据类型\n\n\nAccept-Encoding\n客户端可接收的内容压缩编码形式\n\n\nAccept-Language\n用户期望获得的自然语言的优先顺序\n\n\n详细内容可以查看官方文档： https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers\n2.2.3空行最后一个请求头字段的后面是一个空行，通知服务器请求头部至此结束，用来分隔请求头部与请求体\n2.2.4请求体存放要通过POST方式提交到服务器的数据，GET没有请求体\n3.HTTP请求方法3.1概念HTTP 请求方法，属于 HTTP 协议中的一部分，请求方法的作用是：用来表明要对服务器上的资源执行的操作。最常用的请求方法是 GET 和 POST。\n3.2HTTP的请求方法\n\n\n序号\n方法\n\n\n\n\n1\nGET\n发送请求来获得服务器上的资源，请求体中不会包含请求数据，请求数据放在协议头中。\n\n\n2\nPOST\n向服务器提交资源（例如提交表单或上传文件）。数据被包含在请求体中提交给服务器。\n\n\n3\nPUT\n向服务器提交资源，并使用提交的新资源，替换掉服务器对应的旧资源。\n\n\n4\nDELETE\n请求服务器删除指定的资源。\n\n\n5\nHEAD\n\n\n\n6\nOPTIONS\n\n\n\n7\nCONNECT\n\n\n\n8\nTRACE\n\n\n\n9\nPATCH\n\n\n\n4.HTTP响应消息4.1概念响应消息就是服务器响应给客户端的消息内容，也叫作响应报文\n4.2HTTP请求消息的组成部分\n4.2.1状态行​\t状态行由 HTTP 协议版本、状态码和状态码的描述文本 3 个部分组成，他们之间使用空格隔开\nHTTP/1.1 200 OK\n\n4.2.2响应头部​\t响应头部用来描述服务器的基本信息。响应头部由多行 键&#x2F;值对 组成，每行的键和值之间用英文的冒号分隔\n\n4.2.3空行​\t在最后一个响应头部字段结束之后，会紧跟一个空行，用来通知客户端响应头部至此结束，分隔响应头部与响应体。\n4.2.4响应体​\t响应体中存放的，是服务器响应给客户端的资源内容。\n5.HTTP响应状态码5.1概念​\tHTTP 响应状态码（HTTP Status Code），也属于 HTTP 协议的一部分，用来标识响应的状态。​\t响应状态码会随着响应消息一起被发送至客户端浏览器，浏览器根据服务器返回的响应状态码，就能知道这次 HTTP 请求的结果是成功还是失败了。\n5.2HTTP响应状态码的组成和分类​\tHTTP 状态码由三位数组成，第一个数字定义了状态码的类型，后两个数字用来对状态码进行细分。\n\n\n\n分类\n描述\n\n\n\n1**\n信息响应，服务器收到请求，需要请求者继续执行操作\n\n\n2**\n成功响应，操作被成功接收并处理\n\n\n3**\n重定向消息，需要进一步的操作以完成请求\n\n\n4**\n客户端错误，请求包含语法错误或无法完成请求\n\n\n5**\n服务器错误，服务器在处理请求的过程中发生了错误\n\n\n5.2.2 \t\t2**表示服务器已成功接收到请求并进行处理。\n\n\n\n状态码\n英文名称\n中文描述\n\n\n\n200\nOK\n请求成功，一般用于GET与POST请求\n\n\n201\nCreated\n已创建，成功请求并创建了新的资源，通常用于POST&#x2F;PUT请求\n\n\n5.2.3 \t\t3**表示服务器要求客户端重定向，需要客户端进一步的操作以完成资源的请求。\n\n\n\n状态码\n英文名称\n中文描述\n\n\n\n301\nMoved Permanently\n永久移动，请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替\n\n\n302\nFound\n临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI\n\n\n304\nNot Modified\n未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源（响应消息中不包含响应体）。客户端通常会缓存访问过的资源。\n\n\n5.2.4 \t\t4**表示客户端的请求有非法内容，从而导致这次请求失败。\n\n\n\n状态码\n英文名称\n中文描述\n\n\n\n400\nBad Request\n1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。\n\n\n2、请求参数有误。\n\n\n\n\n401\nUnauthorized\n当前请求需要用户验证\n\n\n403\nForbidden\n服务器已经理解请求，但是拒绝执行它\n\n\n404\nNot Found\n服务器无法根据客户端的请求找到资源（网页）\n\n\n408\nRequest Timeout\n请求超时。服务器等待客户端发送的请求时间过长，超时\n\n\n5.2.5 \t\t5**表示服务器要求客户端重定向，需要客户端进一步的操作以完成资源的请求。\n\n\n\n状态码\n英文名称\n中文描述\n\n\n\n500\nInternal Server Error\n服务器内部错误，无法完成请求\n\n\n501\nNot Implemented\n服务器不支持该请求方法，无法完成请求。只有 GET 和 HEAD 请求方法是要求每个服务器必须支持的，其它请求方法在不支持的服务器上会返回501\n\n\n503\nService Unavailable\n由于超载或系统维护，服务器暂时的无法处理客户端的请求\n\n\n","categories":["前端"],"tags":["HTTP协议"]},{"title":"6.和小达一起学AJAX","url":"/2022/08/11/6.%E5%92%8C%E5%B0%8F%E8%BE%BE%E4%B8%80%E8%B5%B7%E5%AD%A6AJAX/","content":"1.初识客户端与服务器1.1客户端与服务器​\t上网：   通过互联网来获取和消费资源\n​\t服务器：负责存放和对外提供资源的电脑\n​\t客户端：负责获取和消费资源的电脑\n1.2URL地址1.2.1介绍URL(UniformResourceLocator)： 统一资源定位符，用于标识互联网上资源的唯一存放位置，浏览器通过URL地址确定资源的存放位置，访问到对应的资源。\n​\t如：http://www.baidu.com\n​\t\t\thttps://www.bilibili.com/video/BV1K7411W7So\n1.2.2URL地址的组成部分​\t1.客户端与服务器之间的**通信协议 **          \n​\t\thttps\n​\t2.存有该资源的服务器名称\n​\t\twww.bilibili.com\n​\t3.资源在服务器上的具体存放位置\n​\t\tvideo&#x2F;BV1K7411W7So\n​\t\t\n1.3客户端与服务器的通信过程客户端：\n​\t1.打开浏览器，输入网站地址，回车向服务器发起资源请求\n服务器：\n​\t1.服务器接收到客户端发来的资源请求，在内部处理这次请求找到相关资源，把相关资源响应(发送)给客户端\n总结：\n​\t1.客户端请求服务器    2.服务器处理这次请求\t3.服务器响应客户端\n1.4网页请求数据​\tXMLHttpRequest对象：简称xhr，是浏览器提供的js成员，可以请求服务器上的数据资源\nlet xhrObj = new XMLHttpRequest()\n\n1.5资源的请求方式​\t客户端请求服务器时，请求的方式有很多种，最常见的两种请求方式分别为 **get **和 **post **请求。\n1.5.1get 请求通常用于获取服务端资源（向服务器要资源）\n​      例如：根据 URL 地址，从服务器获取 HTML 文件、css 文件、js文件、图片文件、数据资源等\n1.5.2post请求通常用于向服务器提交数据（往服务器发送资源）\n​\t例如：登录时向服务器提交的登录信息、注册时向服务器提交的注册信息、等各种数据提交操作\n2.初识AJAX2.1 AJAX简介AJAX(Asynchronous Javascript And XML)---异步的JavaScript 和 XML\n\n​\t也就是说AJAX是在网页中利用XMLHttpRequest对象和服务器进行数据交互的方式\n​\tAJAX实现网页与服务器之间的数据交互： 比如检测用户名是否被占用，根据页码刷新表格的数据，加载搜索提示列表等等。\n🚩 AJAX 是一种用于创建快速动态网页的技术：\n\n通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。\n传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页。\n\n2.2 AJAX 工作原理AJAX是基于现有的Internet标准，并且联合使用它们：\n\nXMLHttpRequest 对象 (异步的与服务器交换数据)\nJavaScript&#x2F;DOM (信息显示&#x2F;交互)\nCSS (给数据定义样式)\nXML (作为转换数据的格式)\n\n💡 AJAX 应用程序与浏览器和平台无关\n\n2.2.1 使用xhr发起GET请求​\t1.创建xhr对象\nlet xhr = new XMLHttpRequest()\n\n​\t2.调用xhr的.open函数，指定请求方式与URL地址\nxhr.open(&#x27;GET&#x27;,&#x27;http://...?id=1&#x27;)//?表示这次请求是携带参数的，URL地址后面拼接的参数叫做查询字符串\n\n​\t3.调用send函数，发起AJAX请求\nxhr.send()\n\n​\t4.监听 onreadystatechange事件\nxhr.onreadystatechange = function()&#123;    //4.1监听xhr对象的请求状态readystate；服务器响应状态status    if(xhr.readyState === 4 &amp;&amp; xhr.status === 200)&#123;        //4.2打印服务器响应回来的数据        console.log(xhr.responseText)    &#125;&#125;\n\n2.2.2readyState属性​\tXMLHttpRequest 对象的 readyState 属性，用来表示当前 Ajax 请求所处的状态。每个 Ajax 请求必然处于以下状态中的一个：\n\n\n\n值\n状态\n描述\n\n\n\n0\nUNSENT\nXMLHttpRequest 对象已被创建，但尚未调用 open方法\n\n\n1\nOPENED\nopen() 方法已经被调用。\n\n\n2\nHEADERS_RECEIVED\nsend() 方法已经被调用，响应头也已经被接收。\n\n\n3\nLOADING\n数据接收中，此时 response 属性中已经包含部分数据。\n\n\n4\nDONE\nAjax 请求完成，这意味着数据传输已经彻底完成或失败。\n\n\n2.2.3查询字符串​\t查询字符串（URL 参数）是指在 URL 的末尾加上用于向服务器发送信息的字符串（变量）。\n​\t格式：将**英文的 ?  放在URL 的末尾，然后再加上参数＝值 **，想加上多个参数的话，使用 &amp; 符号进行分隔。以这个形式，可以将想要发送给服务器的数据添加到 URL 中。\n​\t本质：直接将参数以查询字符串的形式，追加到 URL 地址的后面，发送到服务器\nhttp://...?id=1&amp;bookname=西游记\n\n2.2.4URL编码​\tURL 地址中，只允许出现英文相关的字母、标点符号、数字，因此，在 URL 地址中不允许出现中文字符。如果 URL 中需要包含中文这样的字符，则必须对中文字符进行编码（转义）。\n​\tURL编码的原则：使用安全的字符（没有特殊用途或者特殊意义的可打印字符）去表示那些不安全的字符。\n​\t浏览器会自动对URL地址进行编码操作，所以大多数情况下，不需要关心\n//URL编码   encodeURI(&#x27;你好&#x27;)let str1 = &#x27;奥特曼&#x27;let str2 = encodeURI(str1)console.log(str2)//%E5%A5%A5%E7%89%B9%E6%9B%BC//URL解码   decodeURI(&#x27;%E5%A5%A5%E7%89%B9%E6%9B%BC&#x27;)let str3 = decodeURI(str2)console.log(str3)//奥特曼\n\n2.2.5使用xhr发起POST请求​\t1.创建xhr对象\nlet xhr = new XMLHttpRequest() \n\n​\t2.调用xhr的.open函数，指定请求方式与URL地址\nxhr.open(&#x27;POST&#x27;,&#x27;http://...&#x27;)\n\n​\t3.设置 Content-Type属性（固定写法）\nxhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;)\n\n​\t4.调用 send()，同时将数据以查询字符串的形式，提交给服务器\nxhr.send(&#x27;bookname=高级程序设计&amp;author=Matt&amp;publisher=人民邮电出版社&#x27;)\n\n​\t5.监听 onreadystatechange 事件\nxhr.onreadystatechange = function() &#123;    if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123;        console.log(xhr.responseText)    &#125;&#125;\n\n\n\n2.3  jQuery 中的AJAX​\t浏览器中提供的XMLHttpRequest 用法复杂，所以 jQuery 对XMLHttpRequest进行了封装，提供了一系列 Ajax 相关的函数。\n2.2.1 $.get​\t发起get请求，将服务器上的资源请求到客户端是使用（拿资源）\n//语法$.get(url,[data],[callback])\n\n\n\n\n参数名\n参数类型\n必选\n说明\n\n\n\nurl\nstring\n是\n要请求的资源地址\n\n\ndata\nobject\n否\n请求资源期间要携带的参数\n\n\ncallback\nfunction\n否\n请求成功时的回调函数\n\n\n​\t1.不带参数的请求\n&lt;body&gt;      &lt;button id=&quot;btnGET&quot;&gt;发起不带参数的GET请求&lt;/button&gt;      &lt;script&gt;    $(function()&#123;      $(&#x27;#btnGET&#x27;).on(&#x27;click&#x27;,function()&#123;        $.get(&#x27;http://...&#x27;,function(res)&#123;          console.log(res)        &#125;)      &#125;)    &#125;)  &lt;/script&gt;&lt;/body&gt;\n\n2.带参数的请求\n&lt;body&gt;  &lt;button id=&quot;btnGETINFO&quot;&gt;发起单参数的GET请求&lt;/button&gt;  &lt;script&gt;    $(function () &#123;      $(&#x27;#btnGETINFO&#x27;).on(&#x27;click&#x27;, function () &#123;        $.get(&#x27;http://...&#x27;, &#123; id: 1 &#125;, function (res) &#123;          console.log(res)        &#125;)      &#125;)    &#125;)  &lt;/script&gt;&lt;/body&gt;\n\n2.2.2 $.post​\t发起post请求，向服务器提交数据（送资源）\n//语法$.url(url,[data],[callback])\n\n\n\n\n参数名\n参数类型\n必选\n说明\n\n\n\nurl\nstring\n是\n提交数据的地址\n\n\ndata\nobject\n否\n要提交的数据\n\n\ncallback\nfunction\n否\n数据提交成功时的回调函数\n\n\n&lt;body&gt;  &lt;button id=&quot;btnPOST&quot;&gt;发起POST请求&lt;/button&gt;  &lt;script&gt;    $(function () &#123;      $(&#x27;#btnPOST&#x27;).on(&#x27;click&#x27;, function () &#123;        $.post(&#x27;http://...&#x27;, &#123; bookname: &#x27;高级程序涉及&#x27;, author: &#x27;Matt&#x27;, publisher: &#x27;人民邮电出版社&#x27; &#125;, function (res) &#123;          console.log(res)        &#125;)      &#125;)    &#125;)  &lt;/script&gt;&lt;/body&gt;\n\n2.2.3 $.ajax//语法$.ajax(&#123;  type: &#x27;GET&#x27;,//请求方式  url: &#x27;http://...&#x27;,//请求地址  data: &#123;    id: 1  &#125;,//请求携带的数据  success: function (res) &#123;    console.log(res)  &#125;//请求成功之后的回调函数&#125;)\n\n\n\n\n属性\n说明\n\n\n\ntype\n请求的方式，例如 GET 或 POST\n\n\nurl\n请求的 URL 地址\n\n\ndata\n这次请求要携带的数据\n\n\nsuccess\nfunction(res) { }  请求成功之后的回调函数\n\n\n​\t1.get请求\n&lt;body&gt;  &lt;button id=&quot;btnGET&quot;&gt;发起GET请求&lt;/button&gt;  &lt;script&gt;    $(function () &#123;      $(&#x27;#btnGET&#x27;).on(&#x27;click&#x27;, function () &#123;        $.ajax(&#123;          type: &#x27;GET&#x27;,//大小写都行，建议大写          url: &#x27;http://...&#x27;,          data: &#123;            id: 1          &#125;,          success: function (res) &#123;            console.log(res)          &#125;        &#125;)      &#125;)    &#125;)  &lt;/script&gt;&lt;/body&gt;\n\n2.post请求\n&lt;body&gt;  &lt;button id=&quot;btnPOST&quot;&gt;发起POST请求&lt;/button&gt;  &lt;script&gt;    $(function () &#123;      $(&#x27;#btnPOST&#x27;).on(&#x27;click&#x27;, function () &#123;        $.ajax(&#123;          type: &#x27;POST&#x27;,          url: &#x27;http://...&#x27;,          data: &#123;            bookname: &#x27;Python&#x27;,            author: &#x27;Eric&#x27;,            publisher: &#x27;人民邮电出版社&#x27;          &#125;,          success: function (res) &#123;            console.log(res)          &#125;        &#125;)      &#125;)    &#125;)  &lt;/script&gt;&lt;/body&gt;\n\n\n\n3.接口3.1接口的概念​\t使用AJAX请求数据时，被请求的URL地址就叫数据接口（简称接口），每个接口必须有请求方式(get post)。\n3.2接口的请求过程​\t1.用户与网页的交互(希望向服务器提交&#x2F;获取数据)\n​\t2.网页向服务器发起POST&#x2F;GET数据请求\n​\t3.服务器处理请求，向网页响应POST&#x2F;GET请求 \n3.3接口测试工具 PostMan​\t在不写任何代码的情况下，对接口进行调用和测试，验证接口是否能被正常访问。\n3.3.1 接口文档​\t\t\t接口的说明文档，它是我们调用接口的依据。好的接口文档包含了对接口URL，参数以及输出内容的说明，我们参照接口文档就能方便的知道接口的作用，以及接口如何进行调用。\n\n接口名称：用来标识各个接口的简单说明，如登录接口，获取图书列表接口等。\n接口URL：接口的调用地址。\n调用方式：接口的调用方式，如 GET 或 POST。\n参数格式：接口需要传递的参数，每个参数必须包含参数名称、参数类型、是否必选、参数说明这4项内容。\n响应格式：接口的返回值的详细描述，一般包含数据名称、数据类型、说明3项内容。\n返回示例（可选）：通过对象的形式，例举服务器返回数据的结构。\n\n3.4测试请求的根路径\n\nhttp://www.xxx.top:8000\n\n图书列表\n\n接口URL：  &#x2F;api&#x2F;getbooks\n调用方式： GET\n参数格式：\n\n\n\n\n参数名称\n参数类型\n是否必选\n参数说明\n\n\n\nid\nNumber\n否\n图书Id\n\n\nbookname\nString\n否\n图书名称\n\n\nauthor\nString\n否\n作者\n\n\npublisher\nString\n否\n出版社\n\n\n\n响应格式：\n\n\n\n\n数据名称\n数据类型\n说明\n\n\n\nstatus\nNumber\n200 成功；500 失败；\n\n\nmsg\nString\n对 status 字段的详细说明\n\n\ndata\nArray\n图书列表\n\n\n+id\nNumber\n图书Id\n\n\n+bookname\nString\n图书名称\n\n\n+author\nString\n作者\n\n\n+publisher\nString\n出版社\n\n\n\n返回示例：\n\n&#123;  &quot;status&quot;: 200,  &quot;msg&quot;: &quot;获取图书列表成功&quot;,  &quot;data&quot;: [    &#123; &quot;id&quot;: 1, &quot;bookname&quot;: &quot;西游记&quot;, &quot;author&quot;: &quot;吴承恩&quot;, &quot;publisher&quot;: &quot;北京图书出版社&quot; &#125;,    &#123; &quot;id&quot;: 2, &quot;bookname&quot;: &quot;红楼梦&quot;, &quot;author&quot;: &quot;曹雪芹&quot;, &quot;publisher&quot;: &quot;上海图书出版社&quot; &#125;,    &#123; &quot;id&quot;: 3, &quot;bookname&quot;: &quot;三国演义&quot;, &quot;author&quot;: &quot;罗贯中&quot;, &quot;publisher&quot;: &quot;北京图书出版社&quot; &#125;  ]&#125;\n\n添加图书\n\n接口URL：  &#x2F;api&#x2F;addbook\n调用方式： POST\n参数格式：\n\n\n\n\n参数名称\n参数类型\n是否必选\n参数说明\n\n\n\nbookname\nString\n是\n图书名称\n\n\nauthor\nString\n是\n作者\n\n\npublisher\nString\n是\n出版社\n\n\n\n响应格式：\n\n\n\n\n数据名称\n数据类型\n说明\n\n\n\nstatus\nNumber\n201 添加成功；500 添加失败；\n\n\nmsg\nString\n对 status 字段的详细说明\n\n\n\n返回示例：\n\n&#123;    &quot;status&quot;: 201,    &quot;msg&quot;: &quot;添加图书成功&quot;&#125;\n\n删除图书\n\n接口URL：  &#x2F;api&#x2F;delbook\n调用方式： GET\n参数格式：\n\n\n\n\n参数名称\n参数类型\n是否必选\n参数说明\n\n\n\nid\nNumber\n是\n图书Id\n\n\n\n响应格式：\n\n\n\n\n数据名称\n数据类型\n说明\n\n\n\nstatus\nNumber\n200 删除成功；500 未指定要删除的图书Id；501 执行Sql报错；502 要删除的图书不存在；\n\n\nmsg\nString\n对 status 字段的详细说明\n\n\n\n返回示例：\n\n&#123;    &quot;status&quot;: 200,    &quot;msg&quot;: &quot;删除图书成功！&quot;&#125;\n\n4.form表单4.1表单的介绍​\t表单在网页中主要负责数据采集功能。HTML中的标签，就是用于采集用户输入的信息，并通过标签的提交操作，把采集到的信息提交到服务器端进行处理。\n&lt;form&gt;    &lt;input type=&quot;text&quot; name=&quot;email_or_mobile&quot; /&gt;    &lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;    &lt;input type=&quot;checkbox&quot; name=&quot;remember_me&quot; checked /&gt;    &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;&lt;/form&gt;\n\n​\t\t表单的组成部分：  \n​\t\t\t1.表单标签；\n​\t\t\t2.表单域(文本框、密码框。隐藏域、复选框、单选框、下拉菜单等)\n​\t\t\t3.表单按钮\n4.2 form标签的属性​\tform标签负责数据采集功能。form标签的属性规定了如何把采集到的数据发送到服务器\n\n\n\n属性\n值\n描述\n\n\n\naction\nURL地址\n规定当提交表单时，向何处发送表单数据，默认值为当前页面的URL地址，当提交表单后，页面会立即跳转到action属性指定的地址。\n\n\nmethod\nget&#x2F;post\n规定以何种方式把表单数据提交到 action URL\n\n\n| enctype | application&#x2F;x-www-form-urlencodedmultipart&#x2F;form-datatext&#x2F;plain |            规定在发送表单数据之前如何对其进行编码            || target  |               _blank_self_parent_topframename                |                  规定在何处打开 action URL                   |\naction\n​\taction 属性用来规定当提交表单时，向何处发送表单数据\n​\taction 属性的值是后端提供的一 URL 地址，这个地址专门负责接收表单提交过来的数据。\n​\taction 的默认值为当前页面的 URL 地址\n​\t当提交表单后，页面会立即跳转到 action 属性指定的 URL 地址\nmethod\n​\tmethod 属性用来规定以何种方式把表单数据提交到 action URL\n​\t它的可选值有两个，分别是 get 和 post.默认情况下，method 的值为 get，表示通过URL地址的形式，把表单数据提交到 action URL。\n​\tget 方式适合用来提交少量的、简单的数据。​\tpost 方式适合用来提交大量的、复杂的、或包含文件上传的数据，比较安全(常用)\nenctype\n\n\n\n值\n属性\n\n\n\napplication&#x2F;x-www-form-urlencoded\n在发送前编码所有字符（默认）\n\n\n| multipart&#x2F;form-data               | 不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。 || text&#x2F;plain                            | 空格转换为 “+” 加号，但不对特殊字符编码。（很少用）          |\n​\t在涉及到文件上传的操作时，必须将 enctype 的值设置为 multipart&#x2F;form-data\n​\t**如果表单的提交不涉及到文件上传操作，则直接将 enctype 的值设置为 application&#x2F;x-www-form-urlencoded **\ntarget\n\n\n\ntarget 值\n描述\n\n\n\n_blank\n在新窗口中打开\n\n\n_self\n默认。在相同的框架中打开\n\n\n_parent\n在父框架集中打开\n\n\n_top\n在整个窗口中打开\n\n\nframename\n在指定的框架中打开\n\n\n4.3表单同步提交​\t\t通过点击提交按钮，触发表单提交操作，使页面跳转到action URL的行为成为表单的同步提交\n​\t\t缺点\tform表单同步提交后页面会跳转到URL地址，体验差\n​\t\t\t\t\tform表单同步提交之后，页面之前的数据和状态会丢失\n​\t\t解决方案\t由表单来负责采集数据，由Ajax来负责将数据提交到服务器\n1.监听表单提交事件\n//监听表单的提交事件$(&#x27;#form1&#x27;).submit(function()&#123;    alert(&#x27;监听到了&#x27;)&#125;)//监听表单提交事件2$(&#x27;#form2&#x27;).on(&#x27;submit&#x27;,function()&#123;    alert(&#x27;监听到了表单的提交事件&#x27;)&#125;)\n\n2.阻止表单的默认提交行为\n$(&#x27;#form1&#x27;).submit(function(e)&#123;    alert(&#x27;监听到了&#x27;)    //阻止表单的默认提交行为    e.preventDefult()&#125;)$(&#x27;#form2&#x27;).on(&#x27;submit&#x27;,function()&#123;    alert(&#x27;监听到了表单的提交事件&#x27;)    //阻止表单的默认提交行为    e.preventDefult()&#125;)\n\n3.快速获取表单中的数据\n//serialize()HANSHU,可以一次性获取到表单中的所有数据$(&#x27;#idname&#x27;).serialize()\n\n注意：\t在使用serialize方法快速获取表单数据时，必须为每个表单元素添加name属性\n&lt;body&gt;  &lt;form action=&quot;/login&quot; id=&quot;f1&quot;&gt;    &lt;input type=&quot;text&quot; name=&quot;user_name&quot; /&gt;    &lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;    &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;  &lt;/form&gt;  &lt;script&gt;    $(function () &#123;      // 第一种方式      $(&#x27;#f1&#x27;).submit(function (e) &#123;        e.preventDefault()        let data = $(this).serialize()        console.log(data)      &#125;) */      // 第二种方式      $(&#x27;#f1&#x27;).on(&#x27;submit&#x27;, function (e) &#123;        e.preventDefault()        let data = $(&#x27;#f1&#x27;).serialize()        console.log(data)      &#125;)    &#125;)  &lt;/script&gt;&lt;/body&gt;\n\n4.4模板引擎​\t可以根据程序员指定的模板结构和数据，自动生成一个完整的HTML页面。\n​\t优势：\t减少了字符串的拼接操作    代码结构更加清晰\n4.4.1 art-template模板引擎​\t\t 官网： http://aui.github.io/art-template/zh-cn/index.html\n​\t\t操作步骤：\n​\t\t1.导入art-template\n​\t\t2.定义数据\n​\t\t3.定义模板\n​\t\t4.调用template函数(‘模板id’，要渲染的数据)\n​\t\t5.渲染HTML结构\n4.4.2 art-template标准语法​\tart-template 提供了&#123;&#123; &#125;&#125;这种语法格式，在&#123;&#123; &#125;&#125;内可以进行变量输出，或循环数组等操作\n​\t**输出 **  \n&#123;&#123;value&#125;&#125;\n\n​\t\t在 &#123;&#123; &#125;&#125; 语法中，可以进行变量的输出、对象属性的输出、三元表达式输出、逻辑或输出、加减乘除等表达式输出。\n​\t原文输出\t\n&#123;&#123;@ value &#125;&#125;\n\n​\t\t如果要输出的 value 值中，包含了 HTML 标签结构，则需要使用原文输出语法，才能保证 HTML 标签被正常渲染。 \n​\t条件输出\t\n&#123;&#123;if value&#125;&#125; 按需输出的内容 &#123;&#123;/if&#125;&#125;&#123;&#123;if v1&#125;&#125; 按需输出的内容 &#123;&#123;else if v2&#125;&#125; 按需输出的内容 &#123;&#123;/if&#125;&#125;\n\n​\t\t如果要实现条件输出，则可以在 &#123;&#123; &#125;&#125; 中使用 if … else if … &#x2F;if 的方式，进行按需输出。\n​\t循环输出\n&#123;&#123;each arr&#125;&#125;    &#123;&#123;$index&#125;&#125; &#123;&#123;$value&#125;&#125;&#123;&#123;/each&#125;&#125;\n\n​\t过滤器\n​\t\t需要处理的值，通过参数送入过滤器函数，输出新值，过滤器的本质是function处理函数\n​\t\t过滤器语法类似管道操作符，它的上一个输出作为下一个输入。\n&#123;&#123;value | filterName&#125;&#125;//定义过滤器的基本语法template.defaults.imports.filterName = function(value)&#123;return  //处理的结果&#125;\n\n4.4.3 正则与字符串​\texec()函数用于检索字符串中的正则表达式匹配，如果有匹配的值返回匹配值，否则返回Null\nlet str = &#x27;hello&#x27;let pattern = /o/console.log(pattern.exec(str))// [&#x27;o&#x27;,index:4,input:&#x27;hello&#x27;,groups:undefined]\n\n​\t分组.\n​\t\t正则表达式中 ( ) 包起来的内容表示一个分组，可以通过分组来提取自己想要的内容\nlet str = &#x27;&lt;div&gt;我是&#123;&#123;name&#125;&#125;&lt;/div&gt;&#x27;let pattern = /&#123;&#123;([a-zA-Z]+)&#125;&#125;/let patternResult = pattern.exec(str)console.log(patternResult) // 得到 name 相关的分组信息 // [&quot;&#123;&#123;name&#125;&#125;&quot;, &quot;name&quot;, index: 7, input: &quot;&lt;div&gt;我是&#123;&#123;name&#125;&#125;&lt;/div&gt;&quot;, groups: undefined]\n\n​\treplace函数\nlet result = &#x27;123456&#x27;.replace(&#x27;123&#x27;,&#x27;abc&#x27;)  //   &#x27;abc456&#x27;//replace循环let str = &#x27;&lt;div&gt;&#123;&#123;name&#125;&#125;今年&#123;&#123; age &#125;&#125;岁了&lt;/div&gt;&#x27;let pattern = /&#123;&#123;\\s*([a-zA-Z]+)\\s*&#125;&#125;/let patternResult = nullwhile(patternResult = pattern.exec(str)) &#123;   str = str.replace(patternResult[0], data[patternResult[1]])&#125;console.log(str) // 输出 &lt;div&gt;name今年age岁了&lt;/div&gt;\n\n\n\n5. 数据交换格式XML JSON服务器端与客户端之间进行数据传输与交换的格式，就是数据交换格式。前端领域，经常提及的两种数据交换格式分别是XML 和 JSON\n5.1XML(Extensible Markup Language):​\t可扩展标记语言。和HTML类似，也是一种标记语言,但是和HTML没有任何关系。HTML是网页内容的载体，XML是用来传输和存储数据，是数据的载体。\n&lt;note&gt;  &lt;to&gt;aaaaa&lt;/to&gt;  &lt;from&gt;bbbbbbb&lt;/from&gt;  &lt;heading&gt;ccccc&lt;/heading&gt;  &lt;body&gt;ddddd&lt;/body&gt;&lt;/note&gt;\n\n​\t缺点：XML格式臃肿，体积大传输效率低，在JS解析XML比较麻烦\n5.2JSON（JavaScript Object Notation）：​\tJavaScript 对象表示法。是一种轻量级的文本数据交换格式，专门用于存储和传输数据，JSON 比 XML 更小、更快、更易解析。它使用文本表示一个 JS 对象或数组的信息，因此，JSON 的本质是字符串。\n5.2.1JSON的对象结构：​\t\t对象结构在 JSON 中表示为 { } 括起来的内容。数据结构为 { key: value, key: value, … } 的键值对结构。其中，key 必须是使用英文的“双引号”包裹的字符串，value 的数据类型可以是数字、字符串、布尔值、null、数组、对象6种类型。\t字符串必须为双引号包裹\n&#123;    name: &quot;zs&quot;,  //name要双引号包裹    &#x27;age&#x27;: 20,\t//age要双引号包裹    &quot;gender&quot;: &#x27;男&#x27;,//男要双引号包裹    &quot;address&quot;: undefined,//undefined不属于六种类型的任意一种，改成Null    &quot;hobby&quot;: [&quot;吃饭&quot;, &quot;睡觉&quot;, &#x27;打豆豆&#x27;]//打豆豆要双引号包裹    say: function() &#123;&#125;//say要双引号包裹，function也不属于六种属性的一种&#125;//改成&#123;    &quot;name&quot;: &quot;zs&quot;,    &quot;age&quot;: 20,    &quot;gender&quot;: &quot;男&quot;,    &quot;address&quot;: null,    &quot;hobby&quot;: [&quot;吃饭&quot;, &quot;睡觉&quot;, &quot;打豆豆&quot;]&#125;\n\n5.2.2JSON的数组结构：​\t\t数组结构在 JSON 中表示为**[ ] 括起来的内容。数据结构为 [ “java”, “javascript”, 30, true … ] 。数组中数据的类型可以是数字、字符串、布尔值、null、数组、对象6种类型**。\t字符串必须为双引号包裹\n[ &quot;java&quot;, &quot;python&quot;, &quot;php&quot; ][ 100, 200, 300.5 ][ true, false, null ][ &#123; &quot;name&quot;: &quot;zs&quot;, &quot;age&quot;: 20&#125;, &#123; &quot;name&quot;: &quot;ls&quot;, &quot;age&quot;: 30&#125; ][ [ &quot;苹果&quot;, &quot;榴莲&quot;, &quot;椰子&quot; ], [ 4, 50, 5 ] ]\n\n5.2.3JSON的注意事项\n属性名必须使用双引号包裹\n字符串类型的值必须使用双引号包裹\nJSON 中不允许使用单引号表示字符串\nJSON 中不能写注释\nJSON 的最外层必须是对象或数组格式\n不能使用 undefined 或函数作为 JSON 的值\n\n5.2.4JSON和JS对象//对象let obj = &#123;a:&#x27;jieke&#x27;,b:&#x27;zuofei&#x27;&#125;//JSON，本质是字符串let json = &#x27;&#123;&quot;a&quot;:&quot;jieke&quot;,&quot;b&quot;:&quot;zuofei&quot;&#125;&#x27;\n\n5.2.5 JSON和JS对象互转把数据对象转换为字符串的过程，叫做序列化，例如：调用 JSON.stringify() 函数的操作，叫做 JSON 序列化。把字符串转换为数据对象的过程，叫做反序列化，例如：调用 JSON.parse() 函数的操作，叫做 JSON 反序列化。\n//JSON字符串转换为js对象  JSON.parse()  反序列化let obj = JSON.parse(&#x27;&#123;&quot;a&quot;:&quot;jieke&quot;,&quot;b&quot;:&quot;zuofei&quot;&#125;&#x27;) //&#123;a:&#x27;jieke&#x27;,b:&#x27;zuofei&#x27;&#125;//js对象转换为JSON字符串  JSON.stringify()   序列化var json = JSON.stringify(&#123;a:&#x27;jieke&#x27;,b:&#x27;zuofei&#x27;&#125;)//&#x27;&#123;&quot;a&quot;:&quot;jieke&quot;,&quot;b&quot;:&quot;zuofei&quot;&#125;&#x27;\n\n6. 封装自己的AJAX函数//无论是GET或者POST请求，所有的参数都是以查询字符串的形式提交给字符串的，所以需要把data对象转化成查询字符串的形式function resolveData(data)&#123;    let arr = []    for(let k in data)&#123;        let str = k + &#x27;=&#x27; + data[k]        arr.push(str)    &#125;    return arr.join(&#x27;&amp;&#x27;)&#125;/*let res = resolveData(&#123;name:&#x27;jack&#x27;,age:18&#125;)*///定义自己的函数function jieke(options)&#123;    //首先new一个xhr的对象    let xhr = new XMLHttpRequest()    //把外界传递过来的参数对象转化为查询字符串    let qs = resovleData(options.data)    //做一个判断是get请求还是POST请求    if(options.method.toUpperCase() === &#x27;GET&#x27;)&#123;        xhr.open(&#x27;GET&#x27;,options.url + &#x27;?&#x27; + qs)        xhr.send()    &#125;else if(options.method.toUpperCase() === &#x27;POST&#x27;)&#123;        xhr.open(&#x27;POST&#x27;,options.url)        xhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;)        xhr.send(qs)    &#125;    xhr.onreadystatechange = function()&#123;        if(xhr.readyState === 4 &amp;&amp; xhr.status === 200)&#123;            let result = JSON.parse(xhr.responseText)            //成功后调用这个函数            options.success(result)        &#125;    &#125;&#125;\n\n7. XMLHttpRequest Level2的新特性7.1旧版本的缺点\n只支持文本数据的传输，无法用来读取和上传文件\n传送和接收数据时，没有进度信息，只能提示是否完成\n\n7.2新功能\n可以设置http请求的时限\n可以使用FormData对象管理表单数据\n可以上传文件\n可以获得传输数据时的进度信息\n\n7.3设置HTTP请求实现​\t有时，Ajax 操作很耗时，而且无法预知要花多少时间。如果网速很慢，用户可能要等很久。新版本的 XMLHttpRequest 对象，增加了 timeout 属性，可以设置 HTTP 请求的时限\n//将最长等待时间设为 3000 毫秒xhr.timeout = 3000//过了这个时限，就自动停止HTTP请求。与之配套的还有一个 timeout 事件，用来指定回调函数：xhr.ontimeout = function(e)&#123;    alert(&#x27;请求超时&#x27;)&#125;\n\n7.4使用FormData对象管理表单数据​\tAjax 操作往往用来提交表单数据。为了方便表单处理，HTML5 新增了一个 FormData 对象，可以模拟表单操作\n//1.新建FormData对象let fd = new FormData()//2.为FormData添加表单项fd.append(&#x27;uname&#x27;, &#x27;zs&#x27;)fd.append(&#x27;upwd&#x27;, &#x27;123456&#x27;)//3.创建xhr对象let xhr = new XMLHttpRequest()//4.指定请求类型和URL地址xhr.open(&#x27;POST&#x27;, &#x27;http://www.xxx.top:8000/api/formdata&#x27;)//5. 直接提交 FormData 对象，这与提交网页表单的效果，完全一样xhr.send(fd)\n\n​\tFormData对象也可以用来获取网页表单的值\n//获取表单元素let form = document.querySelector(&#x27;#form1&#x27;)//监听表单的submit事件form.addEventListener(&#x27;submit&#x27;,function(e)&#123;    e.preventDefault()    //根据form表单创建FormData对象，会自动将表单数据填充到FormData对象中    let fd = new FormData(form)    let xhr = new XMLHttpRequest()    xhr.open(&#x27;POST&#x27;, &#x27;http://www.xxx.top:8000/api/formdata&#x27;)    xhr.send(fd)    xhr.onreadystatechange = function()&#123;            &#125;&#125;)\n\n7.5上传文件/*1.定义 UI 结构2.验证是否选择了文件3.向 FormData 中追加文件4.使用 xhr 发起上传文件的请求5.监听 onreadystatechange 事件*/\n\n1.定义UI结构\n&lt;!-- 1. 文件选择框 --&gt;&lt;input type=&quot;file&quot; id=&quot;file1&quot; /&gt;&lt;!-- 2. 上传文件的按钮 --&gt;&lt;button id=&quot;btnUpload&quot;&gt;上传文件&lt;/button&gt;&lt;br /&gt;&lt;!-- 3. img 标签，来显示上传成功以后的图片 --&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; id=&quot;img&quot; width=&quot;800&quot; /&gt;\n\n2.验证是否选择了文件\n//1.获取上传文件的按钮let btnUpload = document.querySelector(&#x27;#btnUpload&#x27;)//2.为按钮添加click事件监听btnUpload.addEventListener(&#x27;click&#x27;,function()&#123;    //3.获取到选择的文件列表    let files = document.querySelector(&#x27;#file1&#x27;).files    if(files.length &lt;= 0)&#123;        return alert(&#x27;请选择需要上传的文件&#x27;)    &#125;&#125;)\n\n3.向FormData中追加文件\n//1.创建FormData对象let fd = new FormData()//2.向FormData中追加文件fd.append(&#x27;avatar&#x27;,files[0])\n\n4.使用xhr发起上传文件的请求\n//1.创建xhr对象let xhr = new XMLHttpRequest()//2.调用open函数，指定请求类型和url地址，请求类型必须是POSTxhr.open(&#x27;POST&#x27;,&#x27;http://....&#x27;)//3.发起请求xhr.send(fd)\n\n5.监听onreadystatechange事件\nxhr.onreadystatechange = function()&#123;    if(xhr.readyState ===4 &amp;&amp; xhr.status === 200)&#123;        let data = JSON.parse(xhr.responseText)        if(data.status === 200)&#123;            //上传文件成功，将服务器返回的图片地址，设置为 &lt;img&gt; 标签的 src 属性            document.querySelector(&#x27;#img&#x27;).src = &#x27;http://...&#x27;+data.url        &#125;else&#123;            //上传失败的话            console.log(&#x27;图片上传失败&#x27; + data.message)        &#125;    &#125;&#125;\n\n7.6显示文件上传进度​\t新版本的 XMLHttpRequest 对象中，可以通过监听 xhr.upload.onprogress 事件，来获取到文件的上传进度。\n1.需要导入的库\n&lt;link rel=&quot;stylesheet&quot; href=&quot;./lib/bootstrap.css&quot; /&gt;&lt;script src=&quot;./lib/jquery.js&quot;&gt;&lt;/script&gt;\n\n2.基于bootstrap渲染进度条\n&lt;!-- 进度条 --&gt;  &lt;div class=&quot;progress&quot; style=&quot;width: 500px; margin: 10px 0;&quot;&gt;    &lt;div class=&quot;progress-bar progress-bar-info progress-bar-striped active&quot; id=&quot;percent&quot; style=&quot;width: 0%&quot;&gt;      0%    &lt;/div&gt;  &lt;/div&gt;\n\n3.监听上传进度的事件\n//创建XHR对象let xhr = new XMLHttpRequest()//监听xhr.upload 的 onprogress事件xhr.upload.onprogress = function(e)&#123;    //e.lengthComputable 是一个布尔值，表示当前上传的资源是否具有可计算的长度    if(e.lengthComputable)&#123;        //e.loaded已传输的字节        //e.total需传输的总字节        let percentComplete = Math.ceil((e.loaded / e.total) * 100)        $(&#x27;#percent&#x27;).attr(&#x27;style&#x27;,&#x27;width:&#x27; + procentComplete + &#x27;%&#x27;).html(procentComplete + &#x27;%&#x27;)    &#125;&#125;\n\n4.监听上传完成事件\nxhr.upload.onload = function () &#123;    //移除上传中的类样式，添加上传完成的类样式  $(&#x27;#percent&#x27;).removeClass().addClass(&#x27;progress-bar progress-bar-success&#x27;)&#125;\n\n7.7jQuery中的新功能7.7.1文件上传&lt;!-- 定义UI结构 --&gt;&lt;!-- 导入 jQuery --&gt;&lt;script src=&quot;./lib/jquery.js&quot;&gt;&lt;/script&gt;&lt;!-- 文件选择框 --&gt;&lt;input type=&quot;file&quot; id=&quot;file1&quot; /&gt;&lt;!-- 上传文件按钮 --&gt;&lt;button id=&quot;btnUpload&quot;&gt;上传&lt;/button&gt;&lt;script&gt;   \t//验证是否选择了文件\t$(&#x27;#btnUpload&#x27;).on(&#x27;click&#x27;,function()&#123;        //1.将 jQuery 对象转化为 DOM 对象，并获取选中的文件列表        let files = $(&#x27;#file1&#x27;)[0].files        //2.判断是否选择了文件        if(files.length &lt;= 0)&#123;            return alert(&#x27;请选择图片后再上传&#x27;)        &#125;                //向FormData中追加文件        let fd = new FormData()        fd.append(&#x27;avatar&#x27;,files[0])                $.ajax(&#123;            method:&#x27;POST&#x27;,            url:&#x27;http://&#x27;            data:fd,            //不修改 Content-Type 属性，使用 FormData 默认的 Content-Type 值            contentType:false            //不对 FormData 中的数据进行 url 编码，而是将 FormData 数据原样发送到服务器            processData:false            success:function(res)&#123;            console.log(res)        &#125;        &#125;)    &#125;)&lt;/script&gt;\n\n7.7.2loading效果//Ajax 请求开始时，执行 ajaxStart 函数。可以在 ajaxStart 的 callback 中显示 loading 效果$(document).ajaxStart(function() &#123;     $(&#x27;#loading&#x27;).show() &#125;)//Ajax 请求结束时，执行 ajaxStop 函数。可以在 ajaxStop 的 callback 中隐藏 loading 效果$(document).ajaxStop(function() &#123;     $(&#x27;#loading&#x27;).hide() &#125;)\n\n​\t**注意： **\t$(document).ajaxStart() 函数会监听当前文档内所有的 Ajax 请求。\n8. axios​\tAxios 是专注于网络数据请求的库。\n​\t相比于原生的 XMLHttpRequest 对象，axios 简单易用。\n​\t相比于 jQuery，axios 更加轻量化，只专注于网络数据请求。\n8.1axios发起GET请求/*axios.get(&#x27;url&#x27;, &#123; params: &#123; 参数 &#125; &#125;).then(callback)*///请求的URL地址let url = &#x27;http://.....&#x27;//请求的参数对象let paramsObj = &#123;name:&#x27;aoteman&#x27;,age:2000&#125;//使用axious.get()发起get请求axios.get(url,&#123;params:paramsObj&#125;).then(function(res))&#123;\t//res.data是服务器返回的数据\tlet result = res.data    console.log(result)&#125;\n\n8.2axios发起POST请求/*axios.post(&#x27;url&#x27;, &#123; 参数 &#125;).then(callback)*/ // 请求的 URL 地址 let url = &#x27;http://www.liulongbin.top:3006/api/post&#x27; // 要提交到服务器的数据 var dataObj = &#123; location: &#x27;北京&#x27;, address: &#x27;顺义&#x27; &#125; // 调用 axios.post() 发起 POST 请求 axios.post(url, dataObj).then(function(res) &#123;     // res.data 是服务器返回的数据     let result = res.data     console.log(result) &#125;)\n\n8.3直接使用axios发起请求/*axios(&#123;     method: &#x27;请求类型&#x27;,     url: &#x27;请求的URL地址&#x27;,     data: &#123;  POST数据  &#125;,     params: &#123; GET参数  &#125; &#125;) .then(callback)*///GETaxios(&#123;     method: &#x27;GET&#x27;,     url: &#x27;http://...&#x27;,     params: &#123; // GET 参数要通过 params 属性提供         name: &#x27;atm&#x27;,         age: 30000     &#125; &#125;).then(function(res) &#123;     console.log(res.data) &#125;)//POSTaxios(&#123;     method: &#x27;POST&#x27;,     url: &#x27;http://...&#x27;,     data: &#123; // POST 数据要通过 data 属性提供         bookname: &#x27;程序员的自我修养&#x27;,         price: 30     &#125; &#125;).then(function(res) &#123;     console.log(res.data) &#125;)\n\n9. 同源策略和跨域9.1同源​\t\t概念\t如果两个页面的协议、 域名 、端口都相同，那么两个页面具有相同的源。\nhttp://www.test.com/index.html  \t\thttp://www.test.com/other.html\t\t\t同源，协议、域名、端口都相同（端口没写默认为80）https://www.test.com/about.html\t\t\t不同源，协议不同http://blog.test.com/movie.html\t\t\t不同源，域名不同http://www.test.com:7001/home.html\t\t不同源，端口不同（7001和80）http://www.test.com:80/main.html\t\t同源，协议、域名和端口都相同\n\n9.2同源策略​\t同源策略（ Same origin policy）是浏览器提供的一个安全功能。同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。\n​\t通俗的说就是：浏览器规定，不同源的两个网站无法进行资源交互，例如：\n\n无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB\n无法接触非同源网页的 DOM\n无法向非同源地址发送 Ajax 请求\n\n9.3跨域9.3.1同源​\t\t指的是两个 URL 的协议、域名、端口一致，反之，则是跨域。\n9.3.2原因​\t\t出现跨域的根本原因是：\t浏览器的同源策略不允许非同源的URL之间进行资源的交互。\n9.3.3跨域请求的拦截​\t\t1.AJAX正常发起跨域请求到服务器\n​\t\t2.服务器正常处理请求，并响应回数据\n​\t\t3.浏览器正常接收跨域响应的数据，但是由于同源策略，会拦截这些数据，无法被页面获取。\n9.3.4如何实现跨域数据的请求​\t\t两种解决方案：\tJSONP \t和\tCORS\n​\t\tJSONP:\t出现的早，兼容性好（兼容低版本IE），缺点是只支持 GET 请求，不支持 POST 请求。\n​\t\tCORS：\t出现的较晚，它是 W3C 标准，属于跨域 Ajax 请求的根本解决方案。支持 GET 和 POST 请求。缺点是不兼容某些低版本的浏览器。\n9.3.5 JSONP​\t\tJSONP(JSON with Padding),是JSON的一种使用模式，可用于解决主流浏览器的跨域数据访问问题。\n​\t\t实现原理：\t由于浏览器的同源策略的限制，网页中无法通过AJAX请求非同源的接口数据，但是标签不受同源策略的影响，可以通过src属性，请求跨域的数据接口，并通过函数调用的形式，接收跨域接口响应回来的数据(通过callback指定回调函数的名称)。\n//发起跨域的AJAX数据请求$.ajax(&#123;  method: &#x27;GET&#x27;,  url: &#x27;http://ajax.frontend.itheima.net:3006/api/jsonp&#x27;,  data: &#123;    name: &#x27;zs&#x27;,    age: 20  &#125;,  success: function (res) &#123;    console.log(res)  &#125;&#125;)//报错， Access-Control-Allow-Origin\n\n&lt;!--定义一个success回调函数--&gt;&lt;script&gt;\tfunction success(data)&#123;        console.log(&#x27;获取到了data数据&#x27;)        console.log(data)    &#125;&lt;/script&gt;&lt;!--通过script标签请求接口数据--&gt;&lt;script src=&quot;http://ajax.front.aaa.net:3000/api/jsonp?callback=success&amp;name=zs&amp;age=20&quot;&gt;//通过callback来指定回调函数为success，且传入了数据name为atm，age为20000&lt;/script&gt;\n\n由于JSONP是通过script标签的src属性来请求跨域的数据接口，所以只能发起GET请求\n9.3.6jQuery中的JSONP​\t默认情况下，使用 jQuery 发起 JSONP 请求，会自动携带一个 callback=jQueryxxx 的参数，jQueryxxx 是随机生成的一个回调函数名称。\n$.ajax(&#123;    url:&#x27;http://xxx?name=atm&amp;age=20&#x27;,    // 如果要使用 $.ajax() 发起 JSONP 请求，必须指定 datatype 为 jsonp    dataType:&#x27;jsonp&#x27;    success:function(res)&#123;\t&#125;&#125;)\n\n​\t在使用 jQuery 发起 JSONP 请求时，如果想要自定义 JSONP 的参数以及回调函数名称，可以通过如下两个参数来指定\n$.ajax(&#123;    url: &#x27;http://ajax.frontend.itheima.net:3006/api/jsonp?name=zs&amp;age=20&#x27;,    dataType: &#x27;jsonp&#x27;,    // 发送到服务端的参数名称，默认值为 callback    jsonp: &#x27;callback&#x27;,    // 自定义的回调函数名称，默认值为 jQueryxxx 格式    jsonpCallback: &#x27;abc&#x27;,    success: function(res) &#123;       console.log(res)    &#125; &#125;)\n\n\n\n注：\t\n​\tjQuery 中的 JSONP，也是通过  标签的 src 属性实现跨域数据访问的，只不过，jQuery 采用的是动态创建和移除  标签的方式，来发起 JSONP 数据请求。​\t在发起 JSONP 请求的时候，动态向  中 append 一个  标签；​\t在 JSONP 请求成功以后，动态从  中移除刚才 append 进去的  标签；\n9.3.7CORS​\tCORS （Cross-Origin Resource Sharing，跨域资源共享）由一系列 HTTP 响应头组成，这些 HTTP 响应头决定浏览器是否阻止前端 JS 代码跨域获取资源。 \n​\t浏览器的同源安全策略默认会阻止网页“跨域”获取资源。但如果接口服务器配置了CORS 相关的 HTTP 响应头， \n就可以解除浏览器端的跨域访问限制\n\nCORS 主要在服务器端进行配置。客户端浏览器无须做任何额外的配置，即可请求开启了 CORS 的接口。\n\nCORS 在浏览器中有兼容性。只有支持 XMLHttpRequest Level2 的浏览器，才能正常访问开启了 CORS 的服 \n务端接口（例如：IE10+、Chrome4+、FireFox3.5+）\n\n\n","categories":["前端"],"tags":["AJAX"]},{"title":"8.和小达一起学JSON","url":"/2022/08/11/8.%E5%92%8C%E5%B0%8F%E8%BE%BE%E4%B8%80%E8%B5%B7%E5%AD%A6JSON/","content":"🍭 JSON 详解\n1. 什么是 JSON\nJSON 指的是 JavaScript 对象表示法（JavaScript Object Notation）\nJSON 是轻量级的文本数据交换格式\nJSON 独立于语言：JSON 使用 Javascript 语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。 目前非常多的动态（PHP，JSP，.NET）编程语言都支持 JSON\nJSON 具有自我描述性，更易理解\n\n2. JSON 与 JavaScript📜 JSON 文本格式在语法上与创建 JavaScript 对象的代码相同。由于这种相似性，无需解析器，JavaScript 程序能够使用内建的 eval() 函数，用 JSON 数据来生成原生的 JavaScript 对象。\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;CS-Wiki&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;JavaScript 创建 JSON 对象&lt;/h2&gt;&lt;p&gt;网站名称: &lt;span id=&quot;jname&quot;&gt;&lt;/span&gt;&lt;br /&gt; 网站地址: &lt;span id=&quot;jurl&quot;&gt;&lt;/span&gt;&lt;br /&gt; 网站 slogan: &lt;span id=&quot;jslogan&quot;&gt;&lt;/span&gt;&lt;br /&gt; &lt;/p&gt;&lt;script&gt;var JSONObject= &#123;\t&quot;name&quot;:&quot;CS-Wiki&quot;,\t&quot;url&quot;:&quot;https://gitee.com/veal98/CS-Wiki&quot;, \t&quot;slogan&quot;:&quot;🎉 用清晰的脉络总结 Java 和 AI 相关的知识点，便于构建完善的知识体系&quot;&#125;;document.getElementById(&quot;jname&quot;).innerHTML=JSONObject.name document.getElementById(&quot;jurl&quot;).innerHTML=JSONObject.url document.getElementById(&quot;jslogan&quot;).innerHTML=JSONObject.slogan &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\n3. JSON 语法规则JSON 语法是 JavaScript 对象表示语法的子集：\n\n数据在名称&#x2F;值对中\n数据由逗号分隔\n大括号保存对象\n中括号保存数组\n\n① JSON 名称&#x2F;值对JSON 数据的书写格式是：名称&#x2F;值对。\n名称&#x2F;值对包括字段名称（在双引号中），后面写一个冒号，然后是值：\n&quot;name&quot; : &quot;菜鸟教程&quot;\n\n这很容易理解，等价于这条 JavaScript 语句：\nname = &quot;菜鸟教程&quot;\n\n② JSON 值JSON 值可以是：\n\n数字（整数或浮点数）\n字符串（在双引号中）\n逻辑值（true 或 false）\n数组（在中括号中）\n对象（在大括号中）\nnull\n\n③ JSON 数字JSON 数字可以是整型或者浮点型：\n&#123; &quot;age&quot;:30 &#125;\n\n④ JSON 对象JSON 对象在大括号（&#123;&#125;）中书写：\n对象可以包含多个名称&#x2F;值对：\n&#123;     &quot;name&quot;:&quot;hello&quot; ,     &quot;url&quot;:&quot;www.baidu.com&quot; &#125;\n\n这一点也容易理解，与这条 JavaScript 语句等价：\n&#123; &quot;name&quot;:&quot;hello&quot; , &quot;url&quot;:&quot;www.baidu.com&quot; &#125;\n\n⑤ JSON 数组JSON 数组在中括号中书写：\n数组可包含多个对象：\n&#123;     &quot;sites&quot;: [         &#123;             &quot;name&quot;:&quot;hello&quot; ,             &quot;url&quot;:&quot;www.baidu.com&quot;         &#125;,          &#123;             &quot;name&quot;:&quot;google&quot; ,          \t&quot;url&quot;:&quot;www.google.com&quot;         &#125;,          &#123;             &quot;name&quot;:&quot;微博&quot; ,          \t&quot;url&quot;:&quot;www.weibo.com&quot;         &#125;     ]&#125;\n\n在上面的例子中，对象 “sites“ 是包含三个对象的数组。\n⑥ JSON 布尔值JSON 布尔值可以是 true 或者 false：\n&#123; &quot;flag&quot;:true &#125;\n\n⑦ JSON nullJSON 可以设置 null 值：\n&#123; &quot;runoob&quot;:null &#125;\n\n⑧ JSON 使用 JavaScript 语法因为 JSON 使用 JavaScript 语法，所以无需额外的软件就能处理 JavaScript 中的 JSON。\n通过 JavaScript，您可以创建一个对象数组，并像这样进行赋值：\nvar sites = [        &#123;         &quot;name&quot;:&quot;hello&quot; ,      \t&quot;url&quot;:&quot;www.baidu.com&quot;     &#125;,         &#123;         &quot;name&quot;:&quot;google&quot; ,         &quot;url&quot;:&quot;www.google.com&quot;     &#125;,         &#123;         &quot;name&quot;:&quot;微博&quot; ,         &quot;url&quot;:&quot;www.weibo.com&quot;     &#125; ];\n\n可以像这样访问 JavaScript 对象数组中的第一项（索引从 0 开始）：\nsites[0].name;\n\n返回的内容是：baidu\n可以像这样修改数据：\nsites[0].name=&quot;hello&quot;;\n\n\n\n4. JSON 和 XMLxml：\n&lt;sites&gt;  &lt;site&gt;    &lt;name&gt;菜鸟教程&lt;/name&gt; &lt;url&gt;www.runoob.com&lt;/url&gt;  &lt;/site&gt;  &lt;site&gt;    &lt;name&gt;google&lt;/name&gt; &lt;url&gt;www.google.com&lt;/url&gt;  &lt;/site&gt;  &lt;site&gt;    &lt;name&gt;微博&lt;/name&gt; &lt;url&gt;www.weibo.com&lt;/url&gt;  &lt;/site&gt;&lt;/sites&gt;\n\njson:\n&#123;    &quot;sites&quot;: [        &#123; &quot;name&quot;:&quot;菜鸟教程&quot; , &quot;url&quot;:&quot;www.runoob.com&quot; &#125;,         &#123; &quot;name&quot;:&quot;google&quot; , &quot;url&quot;:&quot;www.google.com&quot; &#125;,         &#123; &quot;name&quot;:&quot;微博&quot; , &quot;url&quot;:&quot;www.weibo.com&quot; &#125;    ]&#125;\n\n与 XML 相同之处：\n\nJSON 是纯文本\nJSON 具有”自我描述性”（人类可读）\nJSON 具有层级结构（值中存在值）\nJSON 可通过 JavaScript 进行解析\nJSON 数据可使用 AJAX 进行传输\n\n与 XML 不同之处：\n\n没有结束标签\n更短\n读写的速度更快\n能够使用内建的 JavaScript eval() 方法进行解析\n使用数组\n不使用保留字\n\n⭐ 最大的不同是：XML 需要使用 XML 解析器来解析，JSON 可以使用标准的 JavaScript 函数来解析。\n\nJSON.parse(): 将一个 JSON 字符串转换为 JavaScript 对象。\nJSON.stringify(): 将 JavaScript 值转换为 JSON 字符串。\n\n❓ 为什么使用 JSON？\n对于 AJAX 应用程序来说，JSON 比 XML 更快更易使用：\n\n使用 XML：\n\n读取 XML 文档\n使用 XML DOM 来循环遍历文档\n读取值并存储在变量中\n\n\n使用 JSON：\n\n读取 JSON 字符串\n用 eval() 处理 JSON 字符串\n\n\n\n5. JSON 对象详解① 对象语法&#123;     &quot;name&quot;:&quot;hello&quot; ,     &quot;url&quot;:&quot;www.baidu.com&quot; &#125;\n\nJSON 对象使用在大括号({})中书写。\n对象可以包含多个 key&#x2F;value（键&#x2F;值）对。\nkey 必须是字符串，value 可以是合法的 JSON 数据类型（字符串, 数字, 对象, 数组, 布尔值或 null）。\n\nkey 和 value 中使用冒号(:)分割。\n\n每个 key&#x2F;value 对使用逗号(,)分割。\n\n\n② 访问对象值使用点号（.）来访问对象的值：\nvar myObj, x;myObj = &#123;     &quot;name&quot;:&quot;hello&quot; ,     &quot;url&quot;:&quot;www.baidu.com&quot; &#125;;x = myObj.name;\n\n也可以使用中括号（[]）来访问对象的值：\nvar myObj, x;myObj = &#123;     &quot;name&quot;:&quot;hello&quot; ,     &quot;url&quot;:&quot;www.baidu.com&quot; &#125;;x = myObj[&quot;name&quot;];\n\n③ 循环对象使用 for-in 来循环对象的属性：\n&lt;p&gt;使用 for-in 来循环对象的属性:&lt;/p&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;var myObj = &#123;     &quot;name&quot;:&quot;hello&quot; ,     &quot;url&quot;:&quot;www.baidu.com&quot; &#125;;for (x in myObj) &#123;    document.getElementById(&quot;demo&quot;).innerHTML += x + &quot;&lt;br&gt;&quot;;&#125;&lt;/script&gt;\n\n\n\n在 for-in 循环对象的属性时，使用中括号（[]）来访问属性的值：\nfor (x in myObj) &#123;    document.getElementById(&quot;demo&quot;).innerHTML += myObj[x] + &quot;&lt;br&gt;&quot;;&#125;\n\n\n\n④ 嵌套 JSON 对象JSON 对象中可以包含另外一个 JSON 对象：\nmyObj = &#123;    &quot;name&quot;:&quot;baidu&quot;,    &quot;alexa&quot;:10000,    &quot;sites&quot;: &#123;        &quot;site1&quot;:&quot;www.baidu.com&quot;,        &quot;site2&quot;:&quot;m.baidu.com&quot;,        &quot;site3&quot;:&quot;c.baidu.com&quot;    &#125;&#125;\n\n你可以使用点号(.)或者中括号([])来访问嵌套的 JSON 对象：\nx = myObj.sites.site1;// 或者x = myObj.sites[&quot;site1&quot;];\n\n⑤ 修改以下两种写法都是修改属性的值：\nmyObj.sites.site1 = &quot;www.google.com&quot;; // 修改属性的值myObj.sites[&quot;site1&quot;] = &quot;www.google.com&quot;; // 修改属性的值\n\n⑥ 删除以下两种写法效果相同：\ndelete myObj.sites.site1;delete myObj.sites[&quot;site1&quot;]\n\n6. JSON 数组详解① 数组语法JSON 数组在中括号中书写：\n[ &quot;Google&quot;, &quot;Baidu&quot;, &quot;Taobao&quot; ]\n\nJSON 中数组值必须是合法的 JSON 数据类型（字符串, 数字, 对象, 数组, 布尔值或 null）。\nJavaScript 中，数组值可以是以上的 JSON 数据类型，也可以是 JavaScript 的表达式，包括函数，日期，及 undefined。\n② JSON 对象中的数组对象属性的值可以是一个数组：\nmyObj = &#123;\t&quot;name&quot;:&quot;网站&quot;,\t&quot;num&quot;:3,\t&quot;sites&quot;:[ &quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot; ]&#125;\n\n使用索引值来访问数组：\nx = myObj.sites[0];\n\n③ 循环数组使用 for-in 来访问数组：\nfor (i in myObj.sites) &#123;    x += myObj.sites[i];&#125;\n\n也可以使用 for 循环：\nfor (i = 0; i &lt; myObj.sites.length; i++) &#123;    x += myObj.sites[i];&#125;\n\n④ 嵌套 JSON  对象中的数组JSON 对象中数组可以包含另外一个数组，或者另外一个 JSON 对象：\nmyObj = &#123;    &quot;name&quot;:&quot;网站&quot;,    &quot;num&quot;:3,    &quot;sites&quot;: [        &#123;             &quot;name&quot;:&quot;Google&quot;,             &quot;info&quot;: [                 &quot;Android&quot;,                 &quot;Google 搜索&quot;,                 &quot;Google 翻译&quot;             ]         &#125;,        &#123;             &quot;name&quot;:&quot;num&quot;,             &quot;info&quot;:[                 &quot;1&quot;,                 &quot;2&quot;,                 &quot;3&quot;             ]         &#125;,        &#123;             &quot;name&quot;:&quot;Taobao&quot;,             &quot;info&quot;:[                 &quot;淘宝&quot;,                 &quot;网购&quot;             ]         &#125;    ]&#125;\n\n使用 for-in 来循环访问每个数组：\nfor (i in myObj.sites) &#123;    x += myObj.sites[i].name;    for (j in myObj.sites[i].info) &#123;        x += myObj.sites[i].info[j] + &quot;&lt;br&gt;&quot;;    &#125;&#125;\n\n⑤ 修改myObj.sites[1] = &quot;Github&quot;;\n\n⑥ 删除delete myObj.sites[1];\n\n7. JSON.parse()JSON 通常用于与服务端交换数据。\n在接收服务器数据时一般是字符串。\n我们可以使用 JSON.parse() 方法将数据转换为 JavaScript 对象。\n① 语法JSON.parse(text[, reviver])\n\n参数说明：\n\ntext:必需， 一个有效的 JSON 字符串。\nreviver: 可选，一个转换结果的函数， 将为对象的每个成员调用此函数。\n\n② 示例例如我们从服务器接收了以下数据：\n&#123; &quot;name&quot;:&quot;hello&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:&quot;www.hello.com&quot; &#125;\n\n使用 JSON.parse() 方法处理以上数据，将其转换为 JavaScript 对象：\nvar obj = JSON.parse(&#x27;&#123; &quot;name&quot;:&quot;hello&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:&quot;www.hello.com&quot; &#125;&#x27;);\n\n🚨 注意：解析前要确保你的数据是标准的 JSON 格式，否则会解析出错。\n8. JSON.stringify()JSON 通常用于与服务端交换数据。\n在向服务器发送数据时一般是字符串。\n我们可以使用 JSON.stringify() 方法将 JavaScript 对象转换为字符串。\n① 语法JSON.stringify(value[, replacer[, space]])\n\n参数说明：\n\nvalue:\n必需， 要转换的 JavaScript 值（通常为对象或数组）。\n\nreplacer:\n可选。用于转换结果的函数或数组。\n如果 replacer 为函数，则 JSON.stringify 将调用该函数，并传入每个成员的键和值。使用返回值而不是原始值。如果此函数返回 undefined，则排除成员。根对象的键是一个空字符串：””。\n如果 replacer 是一个数组，则仅转换该数组中具有键值的成员。成员的转换顺序与键在数组中的顺序一样。当 value 参数也为数组时，将忽略 replacer 数组。\n\nspace:\n可选，文本添加缩进、空格和换行符，如果 space 是一个数字，则返回值文本在每个级别缩进指定数目的空格，如果 space 大于 10，则文本缩进 10 个空格。space 也可以使用非数字，如：\\t。\n\n\n② 示例例如我们向服务器发送以下数据：\nvar obj = &#123; &quot;name&quot;:&quot;hello&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:&quot;www.hello.com&quot;&#125;;\n\n我们使用 JSON.stringify() 方法处理以上数据，将其转换为字符串：\nvar myJSON = JSON.stringify(obj);\n\n📚 References\nJSON教程 — 菜鸟教程\n\n","categories":["前端"],"tags":["JSON"]},{"title":"和小达一起学Mongodb","url":"/2022/08/11/MongoDB/","content":"MongoDB教程    API    csdnAPI\n启动MongoDB服务mongod -dbpath  创建&#x2F;进入指定文件夹下的mongodb数据库\nmongod 还能接收一个配置文件： &#x3D; \nMongoDB shellmongo 链接当前开启的MongoDB服务\n基础命令\nhelp ：获取帮助\n\nuse  ：修改当前数据库句柄\n\nshow  ：显示 dbs:数据库，collections:集合，users：用户列表\n\nexit：退出\n\n\n执行js脚本\nMongoDB shell中：load(“.&#x2F;test.js”)\n命令行中：mongo test.js\n\n数据库//数据库参数db.stats()//删除数据库db.dropDatabase()\n\n\n\n集合//创建集合db.createCollection(&quot;test&quot;) //更改集合名db.renameCollection(&quot;test&quot;)//删除集合db.test.drop()\n\n文档——crud增——cdb.test.insert(json)\n\n查——r//文档数量db.test.count()//查找文档db.test.find()db.test.findOne()//查找某字段所有值集合db.test.distinct()\n\nfind参数//按字段查询db.test.find(&#123; &quot;&quot;:&quot;&quot; &#125;)//$gte大于等于，$gt大于，$lte小于等于，$lte小于，$eq等于，$ne不等于db.test.find(&#123; &quot;&quot;:&#123;$gte:4&#125; &#125;)//正则表达式：/k/含k,/^k/以k开头db.test.find(&#123; &quot;&quot;:/k/ &#125;)//$or或db.test.find(&#123; $or:[&#123; &quot;&quot;:4 &#125;,&#123; &quot;&quot;:&quot;a&quot; &#125;] &#125;)//$in包含某些值，$nin不包含某些值db.test.find(&#123; &quot;&quot;:&#123; $in:[3,4] &#125; &#125;)//$exists是否存在某字段db.test.find(&#123; &quot;&quot;:&#123; $exists:true &#125; &#125;)//指定抽出字段db.test.find(&#123;&#125;, &#123; title:true, rank:1 , _id:0&#125;)//sort()排序,1升序，-1降序db.test.find().sort(&#123;rank:1&#125;)//limit()限制输出文档数量db.test.find().limit(3)//skip()跳过前几条文档再开始输出db.test.find().skip(3)\nsort，limit，skip配合使用可以实现换页显示\n\n改——udb.test.update(&lt;filter&gt;,&lt;update&gt;,&lt;options&gt;)db.test.update(&#123;&#125;, &#123; &quot;&quot;:10 &#125;)//$set:只更新指定字段（！不加时会把所有其他字段删除！）,新增or修改db.test.update(&#123;&#125;, &#123; $set:&#123;&quot;&quot;:10&#125; &#125;)//$inc：加，$mul：乘，$rename：重命名查询到的文档的某字段，$unset：删除某字段db.test.update(&#123;&#125;, &#123; $inc:&#123;&quot;&quot;:10&#125; &#125;)db.test.update(&#123;&#125;, &#123; $mul:&#123;&quot;&quot;:10&#125; &#125;)db.test.update(&#123;&#125;, &#123; $rename:&#123;&quot;&quot;:&quot;&quot;&#125; &#125;)db.test.update(&#123;&#125;, &#123; $unset:&#123;&quot;&quot;:true&#125; &#125;)//multi:需要更新所有文档db.test.update(&#123;&#125;, &#123; &quot;&quot;:10 &#125;, &#123; multi:true &#125;)//upsert：有则更新，无则追加db.test.update(&#123;&#125;, &#123; &quot;&quot;:10 &#125;, &#123; upsert:true &#125;)\n删——ddb.test.remove(&#123;&#125;)\n\n索引//获取集合所有索引db.test.getIndexes()//建立索引，unique：不能重复db.test.createIndex(&#123;&quot;&quot;:1&#125;)db.test.createIndex(&#123;&quot;&quot;:1&#125;,&#123;unique:true&#125;)//删除索引db.test.dropIndex(&#123;&#125;)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n备份mongodump -d test：备份指定数据库\nmongorestore –drop：恢复数据库\nNode.js中使用MongoDBMongoClientvar MongoClient = require(&quot;mongodb&quot;).MongoClient;var MongoServer = require(&quot;mongodb&quot;).Server;//var mongo = new MongoClient();//创建实例//var mongo = new MongoClient(new MongoServer(&quot;localhost&quot;,27017));MongoClient.connect(&quot;mongodb://localhost/&quot;,(err,db)=&gt;&#123;\tconsole.log(&#x27;连接成功&#x27;);    var myDB = db.db(&quot;test&quot;)//获取Database对象&#125;)；\n\n\n链接url：mongodb://username:password@host:port/database?options\n当读写数据库并执行其他操作时，必须在回调函数中进行\n\nMongoClient对象\n\n\nMongoClient对象的方法\n描述\ncallback第二个参数\n\n\n\nclose()\n关闭连接\n\n\n\nconnect(url,callback)\n根据指定的连接字符串打开链接\nMongoClient对象\n\n\nopen(callback)\n根据创建MongoClient对象时使用的Server对象的设置打开连接\nMongoClient对象\n\n\ndb(name)\n返回一个Database对象\n\n\n\nDatabase对象\n\n\nDatabase对象的方法\n描述\ncallback第二个参数\n\n\n\naddUser(username,password,callback)\n在当前数据库中添加用户账户\n\n\n\ncreateCollection(name,[options],callback)\n创建集合\n\n\n\ncollections(callback)\n\n所有集合的数组\n\n\ncollection(name,callback)\n获取集合\nCollection对象\n\n\ndropCollection(name,callback)\n删除集合\n\n\n\nremoveUser(username)\n从当前数据库中删除用户账户\n\n\n\nCollection对象\n\n\nCollection对象的方法\n描述\ncallback第二个参数\n\n\n\ninsert(documents,[options],callback)\n插入文档\n新文档\n\n\nfind([query],[options],callback)\n查找文档并返回一个Cursor对象\nCursor对象\n\n\nupdate(query,update,[options],callback)\n更新文档\n\n\n\nremove([query],[options],callback)\n删除文档\n\n\n\nrename(newName,callback)\n重命名文档\n\n\n\ncount([query],[options],callback)\n文档计数\n数量\n\n\ndrop(callback)\n\n\n\n\n","categories":["数据库"],"tags":["Mongodb"]},{"title":"9.和小达一起学Node.js","url":"/2022/08/11/9.%E5%92%8C%E5%B0%8F%E8%BE%BE%E4%B8%80%E8%B5%B7%E5%AD%A6Nodejs/","content":"1.初识Node.jsNode.js官网\n1.1什么是Node.jsNode.js是基于Chrome V8 引擎的JavaScript运行环境\n\n浏览器是js的前端运行环境\nNode是js的后端运行环境\nNode.js中无法调用DOM、BOM等浏览器内置的API\n\n1.2Node.js可以做什么\n基于Express框架——快速构建Web应用\n基于Electron框架—–构建跨平台桌面应用\n基于restify应用——–快速构建API接口项目\n读写和操作数据库、创建使用的命令行辅助前端开发等等\n\n1.3Node.js学习路径浏览器中的JS学习路径：\n\nJS基础语法—–浏览器内置的API(DOM、BOM)—–第三方库(jQuery等)\n\nNode.js学习路径：\n\nJS基础语法—–Node.js内置API(fs、path、http等)—–第三方API模块(express、mysql等)\n\n1.4Node.js环境安装安装包直接在官网首页下载，https://nodejs,org/en/，LTS(长期运行版本)，Current(新版本)\n1.5查看已安装的Node版本号1.打开终端 windows+R，cmd2.输入命令  node -v\n\n1.6终端tab\t快速补全路径esc 清空当前命令cls 清空终端\n\n2.fs文件系统模块2.1什么是文件系统模块fs模块是nodejs官方提供的，用于操作文件的模块。它提供了一系列的方法和属性，用来满足用户对文件操作的需求。\n2.2导入fs模块在使用fs模块操作文件之前，需要使用如下的方式先导入它\nconst fs = require(&#x27;fs&#x27;)\n\n2.3读取指定文件中的内容fs.readFile()fs.readFile(path[,options],callback)\n\n\n参数1：必选参数，字符串，表示文件的路径\n参数2：可选参数，字符串，以什么编码格式读取文件\n参数3：必选参数，文件读取结束后，通过回调函数拿到读取结果\n\nconst fs = require(&#x27;fs&#x27;)fs.readFile(&#x27;./files/1.txt&#x27;,&#x27;utf8&#x27;,function(err,dataStr)&#123;    console.log(err)    console.log(dataStr)&#125;)\n\n\nerr：读取失败的结果\ndataStr：读取成功的结果\n如果读取成功，则err的值为Null\n如果读取失败，则err的值为错误对象，dataStr的值为undefined\n\n//判断文件是否读取成功const fs = require(&#x27;fs&#x27;)fs.readFile(&#x27;./files/1.txt&#x27;,&#x27;utf8&#x27;,function(err,dataStr)&#123;    if(err) return console.log(&#x27;文件读取失败&#x27; + err.message)    console.log(&#x27;文件读取成功，内容是：&#x27; + dataStr)&#125;)\n\n2.4向指定文件写入内容fs.writeFile()fs.writeFile(path,data[,options],callback)\n\n\n参数1：必选参数，字符串，文件的存放路径\n参数2：必选参数，写入文件的内容\n参数3：可选参数，以什么格式写入，默认utf8\n参数4：必选参数，文件写入完成后的回调函数\n\nconst fs = require(&#x27;fs&#x27;)fs.writeFile(&#x27;./files/1.txt&#x27;,&#x27;你好，Node&#x27;，&#x27;utf8&#x27;,function(err)&#123;    console.log(err)&#125;)\n\n\n如果文件写入成功，则err的值为Null\n如果文件写入失败，则err的值为错误对象\n\nconst fs = require(&#x27;fs&#x27;)fs.writeFile(&#x27;./files/1.txt&#x27;,&#x27;你好，Node&#x27;,&#x27;utf8&#x27;,function(err)&#123;    if(err) return console.log(&#x27;文件写入失败&#x27; + err.message)    console.log(&#x27;文件写入成功&#x27;)&#125;)\n\n注：写入文件会覆盖之前文件的内容\n3.path路径模块3.1什么是path路径模块​\tpath模块是node官方提供的，用来处理路径的模块，它提供了一系列的方法和属性，用来满足用户对路径的处理需求\n3.2导入path模块const path = require(&#x27;path&#x27;)\n\n3.3路径拼接path.join()path.join([...paths])\n\n\n参数：路径片段序列\n返回值：\n\nconst path = require(&#x27;path&#x27;)const pathStr = path.join(&#x27;/a&#x27;,&#x27;/b&#x27;,&#x27;/c&#x27;,&#x27;../&#x27;,&#x27;./d&#x27;,&#x27;e&#x27;)console.log(pathStr)//  \\a\\b\\d\\e\n\n\n..&#x2F;会抵消前面的一层路径\n参数可以拼接任意的片段序列\n\nconst path = require(&#x27;path&#x27;)const pathStr = path.join(__dirname,&#x27;./files/1.txt&#x27;)\n\n\n__dirname表示文件所处的当前目录\n涉及路径拼接的问题都要用join，不要用 “ + ”\n\n3.4获取路径中的文件名path.basename()path.basename(path[,ext])\n\n\n参数1：必选参数，表示一个路径的字符串\n参数2：可选参数，表示文件的扩展名\n返回值：路径的最后一部分\n\nconst path = require(&#x27;path&#x27;)const fpath = &#x27;a/b/c/index.html&#x27;let fullname = path.basename(fpath)console.log(fullname)//index.htmllet nameWithoutExt = path.basename(fpath,&#x27;.html&#x27;)console.log(nameWithoutExt)//index\n\n3.5获取路径中的文件扩展名path.extname()path.extname(path)\n\n\n参数1：路径的字符串\n返回值：扩展名，字符串\n\nconst path = require(&#x27;path&#x27;)const fpath = &#x27;a/b/c/index.html&#x27;let fext = path.extname(fpath)console.log(fext)// .html\n\n4.http模块4.1什么是http模块​\t在网络节点中，负责对外提供网络资源的电脑叫服务器；负责消费资源的电脑叫客户端\n​\thttp模块是Node.js提供的，用以创建Web服务器的模块，通过http.createServer()方法就可以把一台普通的电脑变成一台服务器，从而对外提供Web资源\nconst http = require(&#x27;http&#x27;)\n\n​\t电脑和服务器的区别在于，服务器上安装了Web服务器软件，如IIS,Apache等，通过这些服务器软件，可以把一台普通的电脑变成一台Web服务器。\n​\t在 Node.js 中，我们不需要使用 IIS、Apache 等这些第三方 web 服务器软件。因为我们可以基于 Node.js 提供的http 模块，通过几行简单的代码，就能轻松的手写一个服务器软件，从而对外提供 web 服务。\n4.2服务器的相关概念4.2.1 IP地址​\tIP地址就是互联网上每台计算机的唯一地址。如果把“个人电脑”比作“一台电话”，那么“IP地址”就相当于“电话号码”，只有在知道对方 IP 地址的前提下，才能与对应的电脑之间进行数据通信。\n​\tIP 地址的格式：通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d 都是 0~255 之间的十进制整数。例如：（192.168.1.1）\n\n互联网中每台 Web 服务器，都有自己的 IP 地址，例如：大家可以在 Windows 的终端中运行 ping www.baidu.com 命令，即可查看到百度服务器的 IP 地址。\n在开发期间，自己的电脑既是一台服务器，也是一个客户端，为了方便测试，可以在自己的浏览器中输入 127.0.0.1 这个IP地址，就能把自己的电脑当做一台服务器进行访问。\n\n4.2.2域名和域名服务器​\t尽管 IP 地址能够唯一地标记网络上的计算机，但IP地址是一长串数字，不直观，而且不便于记忆，于是人们又发明了另一套字符型的地址方案，即所谓的域名（Domain Name）地址。 \n​\tIP地址和域名是一一对应的关系，这份对应关系存放在一种叫做域名服务器(DNS，Domain name server)的电脑中。使用者 只需通过好记的域名访问对应的服务器即可，对应的转换工作由域名服务器实现。因此，域名服务器就是提供 IP 地址和域名之间的转换服务的服务器。 \n\n单纯使用 IP 地址，互联网中的电脑也能够正常工作。但是有了域名的加持，能让互联网的世界变得更加方便\n在开发测试期间， 127.0.0.1 对应的域名是 localhost，它们都代表我们自己的这台电脑，在使用效果上没有任何区别\n\n4.2.3端口号​\t在一台电脑中，可以运行成百上千个 web 服务。每个 web 服务都对应一个唯一的端口号。客户端发送过来的网络请求，通过端口号，可以被准确地交给对应的 web 服务进行处理。\n\n每个端口号不能同时被多个Web服务占用\n在实际应用中，URL中的80端口可以被省略\n\n4.3创建最基本的Web服务器4.3.1实现步骤1.导入http模块2.创建Web服务器实例，createServer()3.为服务器实例绑定request事件，监听客户端请求，server.on()4.启动服务器,server.listen()\n\n//1.导入http模块const http = require(&#x27;http&#x27;)//2.创建Web服务器实例，createServer()const server = http.createServer()//3.为服务器实例绑定request事件，监听客户端请求，server.on()server.on(&#x27;request&#x27;,function(req,res)&#123;    console.log(&#x27;Someone visit our web server&#x27;)&#125;)//4.启动服务器server.listen(80,function()&#123;    console.log(&#x27;server running at http://127.0.0.1:80&#x27;)&#125;)\n\n4.3.2req请求对象server.on(&#x27;request&#x27;,function(req)&#123;    const str = `Your request url is $&#123;req.url&#125;, request method is $&#123;req.method&#125;`    console.log(str)&#125;)\n\nreq请求对象：只要服务器接收到了客户端的请求，就会调用通过server.on()为服务器绑定的事情处理函数。在事件处理函数中访问与客户端相关的数据和属性\nreq是请求对象，包含了客户端相关的数据和属性，如：、\nreq.url:客户端请求的url地址(从端口号后面开始的)\nreq.method:客户端的method请求类型\n\n4.3.3res响应对象server.on(&#x27;request&#x27;,function(req,res)&#123;    const str = `Your request url is $&#123;req.url&#125;, request method is $&#123;req.method&#125;`    res.end(str)&#125;)\n\n\nstr:要发送到客户端的数据\nres.end()：向客户端发送指定内容，并结束这次请求的处理过程\n\n4.3.4解决中文乱码问题server.on(&#x27;request&#x27;,function(req,res)&#123;    const str = `你请求的url地址是$&#123;req.url&#125;, 请求的method类型为$&#123;req.method&#125;`    res.setHeader(&#x27;Context-Type&#x27;,&#x27;txt/html;charset=utf-8&#x27;)    res.end(str)&#125;)\n\n\n为防止显示中文乱码问题，需要设置响应头  Context-Type  的值为   txt&#x2F;html;charset&#x3D;utf-8\n\n4.4根据不同的url响应不同的html内容1.获取请求的URL地址2.设置默认的响应内容为  404 NOT FOUND3.判断用户请求的是否为 / 或 /index.html 首页4.判断用户请求的是否为 /about.html 关于页面5.设置 Content-Type 响应头，防止中文乱码6.使用 res.end() 把内容响应给客户端\n\nconst http = require(&#x27;http&#x27;)const server = http.createServer()server.on(&#x27;request&#x27;,(req,res)=&gt;&#123;    const url = req.url    let content = &#x27;&lt;h1&gt;404 NOT FOUND&lt;/h1&gt;&#x27;    if(url === &#x27;/&#x27; || url ===&#x27;/index.html&#x27;)&#123;        content = &#x27;&lt;h1&gt;首页&lt;/h1&gt;&#x27;    &#125;else if(url === &#x27;/about.html&#x27;)&#123;        content = &#x27;&lt;h1&gt;关于页面&lt;/h1&gt;&#x27;    &#125;    res.setHeader(&#x27;Content-Type&#x27;,&#x27;text/html;charset=utf-8&#x27;)    res.end(content)&#125;)server.listen(80,()=&gt;&#123;    console.log(&#x27;server running at http://127.0.0.1&#x27;)&#125;)\n\n5.模块化的基本概念5.1什么是模块化​\t模块化是指解决一个复杂问题时，自顶向下逐层把系统划分成若干模块的过程。对于整个系统来说，模块是可组合、分解和更换的单元\n​\t编程领域中的模块化，就是遵守固定的规则，把一个大文件拆成独立并互相依赖的多个小模块\n\n提高了代码的复用性\n提高了代码的可维护性\n可以实现按需加载\n\n5.2什么是模块化规范模块化规范就是对代码进行模块化的拆分与组合时，需要遵守的那些规则。\n\n使用什么样的语法格式来引用模块\n在模块中使用什么样的语法格式向外暴露成员\n\n模块化规范的好处：大家都遵守同样的模块化规范写代码，降低了沟通的成本，极大方便了各个模块之间的相互调用， 利人利己\n6.Node.js中的模块化6.1Node.js中的模块分类\n内置模块：内置模块是由 Node.js 官方提供的，例如 fs、path、http 等\n自定义模块：用户创建的每个 .js 文件，都是自定义模块\n第三方模块(包)：由第三方开发出来的模块，使用前需要先下载\n\n6.2加载模块使用强大的require() 方法，可以加载需要的内置模块、用户自定义模块、第三方模块进行使用。\n//内置模块const fs = require(&#x27;fs&#x27;)//自定义模块const custom = require(&#x27;./custom.js&#x27;)//可以省略.js后缀名//第三方模块const moment = require(&#x27;moment&#x27;)\n\n注：使用require()方法加载其他模块时，会执行被加载模块中的代码\n6.3模块作用域与函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域\n\n可以防止全局变量污染的问题\n\n6.4向外共享模块作用域成员6.4.1module对象console.log(module)\n\n在每个 .js 自定义模块中都有一个 module 对象，它里面存储了和当前模块有关的信息\n6.4.2module.exports\n在自定义模块中，可以使用 module.exports 对象，将模块内的成员共享出去，供外界使用。\n外界用 require() 方法导入自定义模块时，得到的就是 module.exports 所指向的对象。\n\nmodele.exports.name = &#x27;zhangsan&#x27;\n\n6.4.3exports​\t由于 module.exports 单词写起来比较复杂，为了简化向外共享成员的代码，Node 提供了 exports 对象。默认情况下，exports 和 module.exports 指向同一个对象\n​\t注：require()模块时，得到的永远是module.exports指向的对象，为了防止混乱，建议不要在同一个模块中同时使用module.exports和exports\n6.5模块化规范Node.js 遵循了 CommonJS 模块化规范，CommonJS 规定了模块的特性和各模块之间如何相互依赖\n\n每个模块内部，module 变量代表当前模块\nmodule 变量是一个对象，它的 exports 属性（即 module.exports）是对外的接口\n加载某个模块，其实是加载该模块的 module.exports 属性。require() 方法用于加载模块\n\n7.npm与包7.1包7.1.1什么是包？​\tNode.js的第三方模块，也叫包\n7.1.2为什么需要包？​\t包是基于内置模块封装出来的，提供更加方便、更加高级的API\n7.1.3下载包\n从 https://www.npmjs.com/ 网站上搜索自己所需要的包\n从 https://registry.npmjs.org/ 服务器上下载自己需要的包\n\n7.1.4包的管理工具npm​\t**Node Package Manager(npm)**可以从 https://registry.npmjs.org/把需要的包下载到本地使用，npm随着Node.js的安装被一起安装到电脑上\n查看电脑上安装的npm包管理工具的版本号npm -v\n\n7.2安装包7.2.1在项目中安装包npm install \t\t\t包的完整名称npm i 包的完整名称      \t简写npm i moment@2.22.2     安装指定版本\n\n7.2.2初次安装后多的文件\nnode_modules文件夹：存放所有已安装到项目中的包，导入包时，就是从这个文件夹中查找并导入\npackage_lock.json文件：记录node_modules目录下每个包的下载信息（名字、版本号、下载地址等）\n\n注：以上文件不要使用，npm会自动维护他们\n7.2.3包的语义化版本规范​\t包的版本号是以“点分十进制”进行定义的，共有3位数，如2.24.0\n\n第一位：大版本号\n\n第二位：功能版本\n\n第三位：Bug修复版本\n只要前面的版本号增加，后面的版本号归0\n\n\n7.3包的管理配置文件​\tnpm规定，在项目的根目录中，必须提供一个叫package.json的管理配置文件，用以记录与项目有关的一些配置信息，如：\n\n项目的名称、版本号、描述等\n项目中用到了哪些包\n哪些包只在开发期间会用到（devDependencies）\n哪些包在开发和部署期间都会用到（dependencies）\n\n7.3.1多人协作问题​\t由于第三方包体积过大，不方便团队成员之间共享项目源代码，建议在共享的时候删除node_modules文件夹\n7.3.2记录项目中安装了哪些包​\t在项目的根目录中，创建一个叫package.json的配置文件，用来记录项目中安装了哪些包，从而方便剔除node_modules后，在团队成员之间共享项目源代码\n​\t注：在开发中一定要把node_modules文件夹添加到.gitignore忽略文件中\n7.3.3快速创建package.json​\t在项目文件夹创建之初，写代码之前，先快速创建package.json这个包管理配置文件\nnpm init -y\n\n\n必须在英文目录下，且不可以包含空格\n运行 npm install 命令安装包时，npm管理工具会自动把包的名称和版本号记录到package.json文件中\n\n7.3.4dependencies节点​\t在package.json中，dependencies节点会专门记录你用npm -i 命令安装了哪些包\n7.3.5devDependencies节点\n包在开发和上线后都用得到，记录到dependencies节点\n包只在开发时用得到，记录到devDependencies节点\n\nnpm i 包名 -D\t\t\t\t\t\t简写，安装指定的包并记录到devDependencies节点npm install 包名 --save-dev\t\t全写\n\n7.3.6一次性安装所有的包​\t当我们删除node_modules文件夹后，需要把所有的包下载到项目中，否则会报错\nnpm i\t\t一次性安装所有的包\n\n7.3.7卸载包npm uninstall 包名\n\n执行成功后，会把卸载的包自动从package.json的dependicies中移除掉\n7.4解决下包速度慢的问题7.4.1为什么速度慢？​\t在使用npm下包时，默认用国外的https://registry.npmjs.org服务器，网络数据的传输需要经过漫长的海底光缆，因此下包的速度会很慢\n7.4.2淘宝的镜像服务器​\t淘宝在国内搭建了一个服务器，会定期把国外官方服务器的包同步到国内服务器，极大提高了下载速度\n​\t镜像（Mirroring）是一种文件存储形式，一个磁盘上的数据在另一个磁盘上存在完全相同的副本就是镜像\n7.4.3切换npm下包镜像源查看当前下包的地址npm config get registry\t将下包的地址切换为淘宝镜像源npm config set registry=https://registry.npm.taobao.org查看切换是否成功npm config get registry\t\n\n7.4.4nrm​\t为了更方便的切换下包的镜像源，可以安装nrm，快速查看和切换镜像源\n通过npm安装nrm为全局可用工具npm i nrm -g查看可用源nrm ls切换镜像源nrm use taobao\n\n7.5包的分类7.5.1项目包​\t被安装到node_modules中的包都是项目包，项目包又分为两类\n\n开发依赖包：devDependencies节点中记录的     npm -i name -D\n核心依赖包：dependencies节点中记录的            npm -i name\n\n7.5.2全局包​\t在执行npm install时，若提供 -g 参数，则会安装为全局包并且安装在C:\\Users\\用户\\Appdata\\Roming\\npm\\node_modules中\nnpm i 包名 -g\t\t\t\t全局安装指定包npm uninstall 包名 -g\t\t卸载指定全局包\n\n\n只有工具性质的包才具有全局安装的必要性，因为它提供了全局命令供使用\n参考包的官方文档说明，判断是否需要全局安装\n\n7.5.3 i5ting_toc​\ti5ting_toc可以把md文档转换为html页面的工具，使用步骤如下：\n将i5ting_toc安装为全局包npm i i5ting_toc -g实现md转htmli5ting_toc -f 要转md的完整路径 -o\n\n7.6规范包的结构\n包必须以单独的目录存在\n包的顶级目录下必须包含package.json这个管理配置文件\npackage.json必须包含name,version,main三个属性，代表包名，版本号，入口\n\n7.7开发属于自己的包7.7.1初始化包的基本结构\n新建tools文件夹，作为根目录\n在tools文件夹中新建：\npackage.json配置文件\nindex.js入口文件\nREADME.md说明文档\n\n\n\n7.7.2package.json配置文件&#123;    &quot;name&quot;:&quot;eddie_tools&quot; ,\t\t\t\t\t\t\t包名，不能重复，设置前先检索有没有    &quot;version&quot;:&quot;1.0.0&quot;,\t\t\t\t\t\t\t\t版本号    &quot;main&quot;: &quot;./index.js&quot;,\t\t\t\t\t\t\t入口文件    &quot;description&quot;: &quot;提供了*******相关的功能&quot;,\t\t   简短的描述信息    &quot;keywords&quot;: [&quot;cyd&quot;,&quot;dateFormat&quot;,&quot;escape&quot;],\t\t搜索的关键词    &quot;license&quot;: &quot;ISC&quot;\t\t\t\t\t\t\t\t开源许可协议&#125;\n\n7.7.3将不同的功能模块拆分\nA功能拆到.&#x2F;src&#x2F;A.js中，并暴露出去\nB功能拆到.&#x2F;src&#x2F;B.js中，并暴露出去\nindex.js先require()导入AB讲个js文件，再分别暴露出去\n\n7.7.4撰写说明文档7.8模块的加载机制7.8.1优先从缓存中加载​\t模块在第一次加载后会被缓存。 这也意味着多次调用 require() 不会导致模块的代码被执行多次。\n​\t注意：不论是内置模块、用户自定义模块、还是第三方模块，它们都会优先从缓存中加载，从而提高模块的加载效率\n7.8.2 内置模块的加载机制​\t内置模块是由 Node.js 官方提供的模块，内置模块的加载优先级最高。​\t例如，require(‘fs’) 始终返回内置的 fs 模块，即使在 node_modules 目录下有名字相同的包也叫做 fs\n7.8.3自定义模块的加载机制​\t使用 require() 加载自定义模块时，必须指定以 .&#x2F; 或 ..&#x2F; 开头的路径标识符。在加载自定义模块时，如果没有指定 .&#x2F; 或 ..&#x2F;  这样的路径标识符，则 node 会把它当作内置模块或第三方模块进行加载\n​\t同时，在使用 require() 导入自定义模块时，如果省略了文件的扩展名，则 Node.js 会按顺序分别尝试加载以下的文件：\n\n按照确切的文件名进行加载\n补全 .js 扩展名进行加载\n补全 .json 扩展名进行加载\n补全 .node 扩展名进行加载\n加载失败，终端报错\n\n7.8.4第三方模块的加载机制​\t如果传递给 require() 的模块标识符不是一个内置模块，也没有以 ‘.&#x2F;’ 或 ‘..&#x2F;’ 开头，则 Node.js 会从当前模块的父目录开始，尝试从 &#x2F;node_modules 文件夹中加载第三方模块。\n​\t如果没有找到对应的第三方模块，则移动到再上一层父目录中，进行加载，直到文件系统的根目录\n例如，假设在 ‘C:\\Users\\project\\foo.js’ 文件里调用了 require(‘tools’)，则 Node.js 会按以下顺序查找： \n① C:\\Users\\project\\node_modules\\tools \n② C:\\Users\\node_modules\\tools \n③ C:\\node_modules\\tools \n7.8.5目录作为模块​\t当把目录作为模块标识符，传递给 require() 进行加载的时候，有三种加载方式： \n① 在被加载的目录下查找一个叫做 package.json 的文件，并寻找 main 属性，作为 require() 加载的入口 \n② 如果目录里没有 package.json 文件，或者 main 入口不存在或无法解析，则 Node.js 将会试图加载目录下的 index.js 文件。 \n③ 如果以上两步都失败了，则 Node.js 会在终端打印错误消息\n8.Express8.1Express简介什么是Express？\t官方：基于Node.js平台，快速、极简、开放的WEB开发框架\t通俗：本质上和http模块类似，用于创建WEB服务器，是npm上的第三方包\thttp://www.expressjs.com.cn/\n\n进一步理解\t由于http模块用起来复杂，Express是基于Node内置的http模块进一步封装出来的，提高开发效率\n\nExpress可以做什么？\t使用 Express，我们可以方便、快速的创建 Web网站的服务器 或 API接口的服务器\tWeb 网站服务器：专门对外提供 Web 网页资源的服务器\tAPI 接口服务器：专门对外提供 API 接口的服务器\n\n8.2Express的基本使用8.2.1安装expressnpm i express@4.17.1\n\n8.2.2创建基本的WEB服务器//1.导入expressconst express = require(&#x27;express&#x27;)//2.创建服务器const app = express()//3.调用app.listen()启动服务器app.listen(80,()=&gt;&#123;    console.log(&#x27;express server running at http://127.0.0.1&#x27;)&#125;)\n\n8.2.3监听GET请求、POST请求，把内容响应给客户端//1.导入expressconst express = require(&#x27;express&#x27;)//2.创建服务器const app = express()//4.监听客户端的get和Post请求,并向客户端响应内容res.send()app.get(&#x27;/user&#x27;,(req,res)=&gt;&#123;    res.send(&#123;name:&#x27;zs&#x27;,age:20&#125;)&#125;)app.post(&#x27;/user&#x27;,(req,res)=&gt;&#123;    res.send(&#x27;请求成功&#x27;)&#125;)//3.调用app.listen()启动服务器app.listen(80, () =&gt; &#123;  console.log(&#x27;express server running at http://127.0.0.1&#x27;)&#125;)\n\n\n参数1：客户端请求的URL地址\n参数2：请求对应的事件处理函数\nreq：请求对象（包含与请求相关的属性、方法）\nres：响应对象（包含与响应相关的属性、方法）\n\n\n\n通过 res.send() 方法，可以把处理好的内容发送给客户端\n8.2.4获取URL中携带的查询参数​\t通过 req.query 对象，可以访问到   客户端通过查询字符串的形式发送到服务器的参数\n//1.导入expressconst express = require(&#x27;express&#x27;)//2.创建服务器const app = express()//4.获取URL中携带的查询参数app.get(&#x27;/&#x27;,(req,res)=&gt;&#123;    console.log(req.query)&#125;)//3.调用app.listen()启动服务器app.listen(80, () =&gt; &#123;  console.log(&#x27;express server running at http://127.0.0.1&#x27;)&#125;)\n\n\nreq.query默认是一个空对象\n客户端使用 ？name&#x3D;zs&amp;age&#x3D;18 这种查询字符串的形式发送到服务器的参数，可以通过req.query访问到\n\n8.2.5获取URL中的动态参数​\t通过 req.params 对象，可以访问到 URL 中，通过 ：匹配到的动态参数\n//1.导入expressconst express = require(&#x27;express&#x27;)//2.创建服务器const app = express()//获取URL中的动态参数app.get(&#x27;/user/:id/:name&#x27;, (req, res) =&gt; &#123;//可以同时匹配两个参数    console.log(req.params)    res.send(req.params)&#125;)//3.调用app.listen()启动服务器app.listen(80, () =&gt; &#123;  console.log(&#x27;express server running at http://127.0.0.1&#x27;)&#125;)\n\n8.3托管静态资源8.3.1express.static()​\t通过express.static()，我们可以非常方便地创建一个静态资源服务器。例如，通过如下代码就可以将 node_modules 目录下的图片、CSS 文件、JavaScript 文件对外开放访问了\nconst express = require(&#x27;express&#x27;)const app = express()//express.static()app.use(express.static(&#x27;node_modules&#x27;))app.listen(80,function()&#123;    console.log(&#x27;express serve running at http://127.0.0.1&#x27;)&#125;)\n\n​\t现在，你就可以访问 node_modules目录中的所有文件了\nhttp://localhost:3000/image.jpg\n\n\nExpress 在指定的静态目录中查找文件，并对外提供资源的访问路径。 因此，存放静态文件的目录名不会出现在 URL 中。\n\n8.3.2托管多个静态资源目录​\t如果要托管多个静态资源目录，请多次调用 express.static() 函数\napp.use(express.static(&#x27;node_modules&#x27;))app.use(express.static(&#x27;files&#x27;))\n\n​\t访问静态资源文件时，express.static() 函数会根据目录的添加顺序查找所需的文件\n8.3.3挂在路径前缀​\t如果希望在托管的静态资源访问路径之前，挂载路径前缀，则可以使用如下的方式：\napp.use(&#x27;/node_modules&#x27;,express.static(&#x27;node_modules&#x27;))\n\n​\t现在，你就可以通过带有 &#x2F;node_modules前缀地址来访问 node_modules 目录中的文件了\nhttp://localhost:3000/node_modules/image.jpg\n\n8.3.4nodemon​\t在编写调试 Node.js 项目的时候，修改代码后需要频繁的手动 close 掉，然后再重新启动，非常繁琐。\nnodemon可以监听文件的变动，自动帮我们重启项目\n安装npm i nodemon使用nodemon app.js\n\n8.4Express路由8.4.1路由1.路由的概念​\t广义上，路由就是映射关系。\n​\t在Express里，路由指的是客户端的请求与服务器处理函数之间的映射关系。\n​\tExpress中的路由以3部分组成：请求类型、URL地址、处理函数\n2.路由的匹配过程每当一个请求到达服务器之后，需要先经过路由的匹配，只有匹配成功之后，才会调用对应的处理函数。\n在匹配时，会按照路由的顺序进行匹配，如果请求类型和请求的 URL 同时匹配成功，则 Express 会将这次请求，转交给对应的 function 函数进行处理。\n\n按照定义的先后顺序进行匹配\n请求类型和请求的URL同时匹配成功，才会调用对应的处理函数\n\n8.4.2路由的使用​\t最简单的用法：直接挂载到app上\napp.get(&#x27;/&#x27;,(req,res) =&gt; &#123;&#125;)\n\n​\t模块化路由：\n​\t\t为了方便对路由进行模块化的管理，Express 不建议将路由直接挂载到 app 上，而是推荐将路由抽离为单独的模块。步骤如下：\n1.创建路由模块对应的 .js 文件2.调用 express.Router() 函数创建路由对象3.向路由对象上挂载具体的路由4.使用 module.exports 向外共享路由对象5.使用 app.use() 函数注册路由模块\n\n//路由模块//1.导入expressconst express = require(&#x27;express&#x27;)//2.创建路由对象const router = express.Router()//3.挂在具体的路由router.get(&#x27;/user/list&#x27;,(req,res)=&gt;&#123;    res.send(&#x27;Get user list&#x27;)&#125;)router.post(&#x27;/user/add&#x27;,(req,res)=&gt;&#123;    res.send(&#x27;Add new user&#x27;)&#125;)//4.向外暴露路由对象module.exports = router\n\nconst express = require(&#x27;express&#x27;)const app = express()//1.导入路由模块const router = require(&#x27;./06router.js&#x27;)//2.注册路由模块app.use(router)app.listen(80, () =&gt; &#123;  console.log(&#x27;express server running at http://127.0.0.1&#x27;)&#125;)\n\n8.4.3Express中间件1.概念：​\t中间件（Middleware ），特指业务流程的中间处理环节\n2.Express 中间件的调用流程：​\t当一个请求到达 Express 的服务器之后，可以连续调用多个中间件，从而对这次请求进行预处理。\n\n3.中间件的格式:​\tExpress 的中间件，本质上就是一个 function 处理函数\napp.get(&#x27;/&#x27;,(req,res,next) =&gt; &#123;&#125;)\n\n\n中间件函数的形参列表中，必须包含 **next **参数\n路由处理函数中只包含 req 和 res\nnext 函数是实现多个中间件连续调用的关键，它表示把流转关系转交给下一个中间件或路由\n\n8.4.4中间件的使用1.定义中间件函数const mw = function(req,res,next)&#123;    console.log(&#x27;这是一个最简单的中间件函数&#x27;)    next()&#125;\n\n2.全局生效的中间件​\t客户端发起的任何请求，到达服务器之后都会触发的中间件，叫做全局生效的中间件。 通过调用 **app.use()**，即可定义一个全局生效的中间件\nconst mw = function(req,res,next)&#123;    console.log(&#x27;这是一个最简单的中间件函数&#x27;)    next()&#125;app.use(mw)\n\n3.全局中间件的简化形式app.use(function(req,res,next)&#123;    console.log(&#x27;这是一个最简单的中间件&#x27;)    next()&#125;)\n\n4.中间件的作用​\t多个中间件之间，共享同一份 req 和 res。基于这样的特性，我们可以在上游的中间件中，统一为 req 或 res 对象添加自定义的属性或方法，供下游的中间件或路由进行使用。\n5.定义多个全局中间件：​\t可以使用 app.use()   连续定义多个全局中间件。客户端请求到达服务器之后，会按照中间件定义的先后顺序依次进行调用\napp.use(function (req, res, next) &#123;  console.log(&#x27;第1个全局中间件&#x27;)  next()&#125;)app.use(function (req, res, next) &#123;  console.log(&#x27;第2个全局中间件&#x27;)  next()&#125;)app.use(function (req, res, next) &#123;  console.log(&#x27;第3个全局中间件&#x27;)  next()&#125;)\n\n6.局部中间件​\t不使用 app.use() 定义的中间件，叫做局部生效的中间件\n//定义中间件函数mw1const mw1 = function (req, res, next) &#123;  console.log(&#x27;jubuzhongjianjian&#x27;)  next()&#125;//mw1只在当前路由生效，局部生效的中间件app.get(&#x27;/&#x27;,mw1, (req, res) =&gt; &#123;  res.send(&#x27;HOME PAGE+&#x27; )&#125;)//mw不会影响下面这个路由app.get(&#x27;/s&#x27;, (req, res) =&gt; &#123;  res.send(&#x27; PAGE&#x27; )&#125;)\n\n7.定义多个局部生效的中间件app.get(&#x27;/&#x27;,mw1,mw2, (req, res) =&gt; &#123;res.send(&#x27;HOME PAGE+&#x27;)&#125;)app.get(&#x27;/&#x27;,[mw1,mw2], (req, res) =&gt; &#123;res.send(&#x27;HOME PAGE+&#x27;)&#125;)\n\n8.中间件的注意点\n一定要在路由之前注册中间件\n客户端发送过来的请求，可以连续调用多个中间件进行处理\n执行完中间件的业务代码之后，不要忘记调用 next() 函数\n为了防止代码逻辑混乱，调用 next() 函数后不要再写额外的代码\n连续调用多个中间件时，多个中间件之间，共享 req 和 res 对象\n\n8.4.5中间件的分类1.应用级别的中间件​\t\t通过 app.use() 或 app.get() 或 app.post() ，绑定到 app 实例上的中间件，叫做应用级别的中间件\napp.use((req,res,next) =&gt; &#123;&#125;)app.get(&#x27;/&#x27;,(req,res,next) =&gt; &#123;&#125;)\n\n2.路由级别的中间件​\t\t绑定到 express.Router() 实例上的中间件，叫做路由级别的中间件。它的用法和应用级别中间件没有任何区别。只不过，应用级别中间件是绑定到 app 实例上，路由级别中间件绑定到 router 实例上\nlet app = express()let router = express.Router()//路由级别的中间件router.use((req,res,next) =&gt; &#123;&#125;)app.use(router)\n\n3.错误级别的中间件​\t\t专门用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题。\nconst express = require(&#x27;express&#x27;)const app = express()app.get(&#x27;/&#x27;,(req,res)=&gt;&#123;    //1.人为的制造错误    throw new Error(&#x27;服务器内部发生了某些错误&#x27;)    res.send(&#x27;HOME PAGE&#x27;)&#125;)//2.定义错误级别的中间件，捕获整个项目的异常错误，从而防止程序的崩溃app.use((err,req,res,next)=&gt;&#123;    console.log(&#x27;发生了错误&#x27; + err.message)    res.send(&#x27;ERROR&#x27; + err.message)&#125;)app.listen(80,function()&#123;    console.log(&#x27;express serve running at http://127.0.0.1:80&#x27;)&#125;)\n\n\n错误级别的中间件， 必须注册在所有路由之后\n\n4.Express内置的中间件​\t自 Express 4.16.0 版本开始，Express 内置了 3 个常用的中间件\n\nexpress.static 快速托管静态资源的内置中间件\nexpress.json 解析 JSON 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）\nexpress.urlencoded 解析 URL-encoded 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）\n\n//配置解析 application/json格式数据的内置中间件app.use(express.json())//配置解析 application/x-www-form-urlencoded 格式数据的内置中间件app.use(express.urlencoded(&#123; extended: false &#125;))\n\n5.第三方中间件​\t非 Express 官方内置的，而是由第三方开发出来的中间件\n8.4.6自定义中间件自己手动模拟一个类似于 express.urlencoded 这样的中间件，来解析 POST 提交到服务器的表单数据\nconst qs = require(&#x27;querystring&#x27;)const bodyParser = (req, res, next) =&gt; &#123;  //定义中间件具体的业务逻辑，这是解析表单数据的中间件  //1.定义变量，来存储客户端发送过来的请求体数据  let str = &#x27;&#x27;  //2.监听req对象的data事件（客户端发送过来的新请求体数据）  /*在中间件中，需要监听 req 对象的 data 事件，来获取客户端发送到服务器的数据。如果数据量比较大，无法一次性发送完毕，则客户端会把数据切割后，分批发送到服务器。所以 data 事件可能会触发多次，每一次触发 data 事件时，获取到数据只是完整数据的一部分，需要手动对接收到的数据进行拼接。  */  req.on(&#x27;data&#x27;, (chunk) =&gt; &#123;    str += chunk //此时ste存储的是最完整的数据  &#125;)  //3.监听req的end事件 /*当请求体数据接收完毕之后，会自动触发 req 的 end 事件。因此，我们可以在 req 的 end 事件中，拿到并处理完整的请求体数据 */  req.on(&#x27;end&#x27;, () =&gt; &#123;    console.log(str) //此时ste存储的是最完整的数据    /*Node.js 内置了一个 querystring 模块，专门用来处理查询字符串。通过这个模块提供的 parse() 函数，可以轻松把查询字符串，解析成对象的格式。*/    const body = qs.parse(str)    console.log(body)    /*上游的中间件和下游的中间件及路由之间，共享同一份 req 和 res。因此，我们可以将解析出来的数据，挂载为 req 的自定义属性，命名为 req.body，供下游使用。*/    req.body = body    next()  &#125;)&#125;module.exports = bodyParser\n\nconst express = require(&#x27;express&#x27;)const app = express()const custombodyparser = require(&#x27;./15custom-body-parser&#x27;)app.use(custombodyparser)app.post(&#x27;/user&#x27;, (req, res) =&gt; &#123;  res.send(req.body)&#125;)app.listen(80,function()&#123;    &#x27;console.log(running)&#x27;&#125;)\n\n8.4.7使用Express写接口const express = require(&#x27;express&#x27;)const router = express.Router()//定义get接口router.get(&#x27;/get&#x27;,(req,res)=&gt;&#123;    //通过req.query获取客户端通过查询字符串，发送到服务器的数据    const query = req.query    //调用res.send方法，向客户端响应处理结果    res.send(&#123;        status : 0,//表示处理成功，1表示处理失败        msg : &#x27;GET请求成功&#x27;,//状态的描述        data : query//需要响应给客户端的数据    &#125;)&#125;)//定义post接口router.post(&#x27;/post&#x27;,(req,res)=&gt;&#123;    //通过req.body获取请求体重包含的url-encoded格式的数据    const body = req.body    //调用res.send方法，向客户端响应结果    res.send(&#123;        status : 0,        msg : &#x27;POST请求成功&#x27;,        data : body    &#125;)&#125;)module.exports = router\n\n//1.创建最基本的服务器const express = require(&#x27;express&#x27;)const app = express()//在路由模块之前配置解析表单数据的中间件app.use(express.urlencoded(&#123;extended : false&#125;))//在路由之前配置cors中间件，解决接口跨域的问题const cors = require(&#x27;cors&#x27;)app.use(cors())//导入路由模块const router = require(&#x27;./16apiRouter&#x27;)//注册路由模块app.use(&#x27;/api&#x27;,router)app.listen(80,()=&gt;&#123;    console.log(&#x27;Express running at http://127.0.0.1&#x27;)&#125;) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["前端"],"tags":["Node.js"]},{"title":"和小达一起学Linux","url":"/2022/08/11/%E5%92%8C%E5%B0%8F%E8%BE%BE%E4%B8%80%E8%B5%B7%E5%AD%A6Linux/","content":":+1: 常用命令1、权限文件\n\nchgrp：更改文件属组；chgrp [-R] 属组名 文件名，-R递归\nchown：更改文件属主，也可以同时更改文件属组；chown [–R] 属主名 文件名 或 chown [-R] 属主名：属组名 文件名\nchmod：更改文件9个属性；chmod [-R] xyz 文件或目录\n\n用户\n\nuseradd：添加账号；-m创建使用者目录，-g用户组，-d指定用户主目录\nuserdel：删除用户；-r删除使用者目录\nusermod：修改账号；\npasswd：用户口令；-i锁定，-u解锁，-d无口令，-f强迫修改\nsu：切换用户；su - root 新工作环境\nsudo：获取临时的root权限；sudo su\n\n用户组\n\ngroupadd：创建用户组；-g指定GID\ngroupdel ：删除用户组；\ngroupmod：修改用户组；-n 新名字\nnewgrp ：切换组；\n\n2、目录-f：强制，-i：再次询问\n\nls: 列出目录，-a隐藏文件，-l列表，-i显示inode\ncd：切换目录\npwd：显示目前的目录\nmkdir：创建一个新的目录，-p递归创建子目录，-m配置权限\nrmdir：删除一个空的目录，-p递归删除子目录\ncp: 复制文件或目录\nrm: 移除文件或目录，-r递归删除\nmv: 移动文件与目录，或修改文件与目录的名称\n\n3、文件\ntouch：新建文件\nvim：新建、修改\necho：输入字符串；echo &quot;str&quot; &gt;&gt; 文件名\ncat：由第一行开始显示文件内容\ntac：从最后一行开始显示，可以看出 tac 是 cat 的倒着写！\nnl ：显示的时候，顺道输出行号！\nmore：一页一页的显示文件内容\nless：与 more 类似，但是比 more 更好的是，他可以往前翻页！\nhead：只看头几行；-n+数字\ntail：只看尾巴几行\nln：创建连接；默认硬链接（inode 节点号相同），-s 软连接\n\n上传文件到linux服务器：scp .\\id_rsa.pub root@101.35.119.69:~/.ssh/id_rsa.pub\n下载：wget -P /home/sofice http://cn.wordpress.org/wordpress-3.1-zh_CN.zip \n4、磁盘\ndf：整体磁盘使用量；-h KBytes，-H 1024进制，-T文件系统类型，-i inode数量\ndu：目录下磁盘空间使用量；-s 总量，-m MBytes\nmount：挂载；mount /dev/hdc6 /mnt/hdc6\numount：卸载；\n\n5、进程与服务\nps：进程信息；-u 用户信息，-x 后台参数， ps -aux|grep python，ps -ef查看父进程\n\nnetstat -anp：端口信息；\n\njps：启动的任务及端口；\n\npstree：进程树；-p 父id，-u 用户组，pstree -pu\n\nkill：结束进程；kill -9 PID\n\nwhereis：进程位置；\n\nsystemctl：服务管理；\n# 启动服务systemctl redis start# 停止服务systemctl redis stop# 开机自启systemctl enable redissystemctl disable redis# 查看状态systemctl status redis\n\ncurl：测试服务；curl localhost:8080\n\n\n6、系统状况\nuname：操作系统的发行版号； uname -a \nfree：查看内存使用；free -h\n\n:door: Linux简介Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX（可移植操作系统接口） 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。\nLinux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。\n\n\nCentOS是一款流行的开源Linux发行版，是RHEL（Red Hat Enterprise Linux）源代码经过再编译而成。\n通常服务器使用 LAMP（Linux + Apache + MySQL + PHP）或 LNMP（Linux + Nginx+ MySQL + PHP）组合。\nman + 命令：查看命令使用手册\nlinux加载配置文件顺序：&#x2F;etc&#x2F;profile → &#x2F;etc&#x2F;profile.d&#x2F;*.sh → ~&#x2F;.bash_profile → ~&#x2F;.bashrc → [&#x2F;etc&#x2F;bashrc]\n&#x3D;&#x3D;centos改颜色&#x3D;&#x3D;：\n# 在/etc/bashrc 最后加上export PS1=&quot;\\[\\e[32;1m\\]\\u\\[\\e[33;1m\\]@\\[\\e[35;1m\\]\\h \\[\\e[0m\\]\\w\\$&quot;# 激活环境source /etc/bashrc\n\n&#x3D;&#x3D;ssh公钥位置&#x3D;&#x3D;：将公钥id_rsa.pub导入 ~/.ssh/authorized_keys；并更改权限chmod 600 ~/.ssh/authorized_keys，chmod 700 ~/.ssh\n:file_folder: 文件及目录文件权限文件类型权限，链接数，拥有者，用户组，大小，最后修改时间，文件名\n\n文件类型权限\n文件类型：【d】目录、【-】文件、【l】连接、【b】存储设备、【c】串行端口设备\n权限权值：r：4，w：2，x：1\n文件与目录\n\n以下是对这些目录的解释：\n\n&#x2F;bin：bin是Binary的缩写, 这个目录存放着最经常使用的命令。\n\n&#x2F;boot： 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。\n\n&#x2F;dev ： dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。\n\n&#x3D;&#x3D;&#x2F;etc&#x3D;&#x3D;：这个目录用来存放所有的系统管理所需要的配置文件和子目录。\n【&#x2F;etc&#x2F;passwd】用户信息\n【&#x2F;etc&#x2F;shadow】密码\n【&#x2F;etc&#x2F;group】用户组信息\n【&#x2F;etc&#x2F;profile】【&#x2F;etc&#x2F;profile.d&#x2F;*.sh】环境变量\n\n&#x3D;&#x3D;&#x2F;home&#x3D;&#x3D;：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。\n\n&#x2F;lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。\n\n&#x2F;lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。\n\n&#x2F;media：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。\n\n&#x2F;mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在&#x2F;mnt&#x2F;上，然后进入该目录就可以查看光驱里的内容了。\n\n&#x3D;&#x3D;&#x2F;opt&#x3D;&#x3D;：这是给主机额外安装软件所摆放的目录。比如安装maven，mysql等\n\n&#x2F;proc：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。\n\n&#x2F;root：该目录为系统管理员，也称作超级权限者的用户主目录。\n\n&#x2F;sbin：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。\n\n&#x2F;srv：该目录存放一些服务启动之后需要提取的数据。\n\n&#x2F;sys：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。\n\n&#x2F;tmp：这个目录是用来存放一些临时文件的。\n\n&#x2F;usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。\n\n&#x2F;usr&#x2F;bin： 系统预装的可执行程序，会随着系统升级而改变。\n\n&#x2F;usr&#x2F;sbin： 超级用户使用的比较高级的管理程序和系统守护程序。\n\n&#x2F;usr&#x2F;src： 内核源代码默认的放置目录。\n\n&#x2F;usr&#x2F;local&#x2F;bin：用户放置自己的可执行程序的地方，不会被系统升级而覆盖同名文件。\n\n&#x2F;var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。\n\n&#x2F;run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。\n\n&#x2F;www：存放服务器网站相关资源，环境及项目\n\n\nVim\n\n命令模式：\n用户刚刚启动 vi&#x2F;vim，便进入了命令模式。\n常用的几个命令：\n\ni 前面插入，a 后面插入，o下一新行\nx 删除当前光标所在处的字符\n: 切换到底线命令模式，以在最底一行输入命令。\n\n输入模式：\n在输入模式中，可以使用以下按键：\n\n字符按键以及Shift组合，输入字符\nENTER，回车键，换行\nBACK SPACE，退格键，删除光标前一个字符\nDEL，删除键，删除光标后一个字符\n方向键，在文本中移动光标\nHOME&#x2F;END，移动光标到行首&#x2F;行尾\nPage Up&#x2F;Page Down，上&#x2F;下翻页\nInsert，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线\nESC，退出输入模式，切换到命令模式\n\n底线命令模式\n在命令模式下按下:（英文冒号）就进入了底线命令模式。\n底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。\n在底线命令模式中，基本的命令有（已经省略了冒号）：\n\nq 退出程序\nw 保存文件\n\n按ESC键可随时退出底线命令模式。\n磁盘管理根文件系统之外的其他文件要想能够被访问，都必须通过“关联”至根文件系统上的某个目录来实现，此关联操作即为“挂载”，此目录即为“挂载点”,解除此关联关系的过程称之为“卸载”\n文件压缩:shell: Shell用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX&#x2F;TOPS-20 type C Shell), bash(Bourne Again Shell)等。\n系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为&#x2F;bin&#x2F;sh。\n利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。\nBASH正则表达式与文件格式化shell脚本:person_frowning: 使用者管理https://blog.csdn.net/sam305415304/article/details/105513451/?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=xshell%20ssh%20%E9%9D%9Eroot&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-105513451.first_rank_v2_pc_rank_v29&amp;spm=1018.2226.3001.4187\n账号管理用户信息【&#x2F;etc&#x2F;passwd】，密码【&#x2F;etc&#x2F;shadow】\n增加用户账号就是在&#x2F;etc&#x2F;passwd文件中为新用户增加一条记录，同时更新其他系统文件如&#x2F;etc&#x2F;shadow, &#x2F;etc&#x2F;group等。\nUID 用户标识号\n$ 表示普通用户，# 表示root用户\n伪用户（pseudo users）\n这些用户在&#x2F;etc&#x2F;passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。\nbin 拥有可执行的用户命令文件sys 拥有系统文件adm 拥有帐户文件uucp UUCP使用lp lp或lpd子系统使用nobody NFS使用\n\n\n\n添加sudo权限\nvisudo 命令是用来编辑修改【&#x2F;etc&#x2F;sudoers】，加入一行：\nsofice  ALL=(ALL)    ALL \n\n用户组管理用户组信息【&#x2F;etc&#x2F;group】\nGID 用户组标识号\n进程管理PID进程标识号\n包管理rpmRPM包格式：name-version.type.rpm  软件名-版本号.包类型.rpm安装：rpm -i /PATH/TO/RPM包名全称卸载：rpm -e --nodeps RPM包名 //--nodeps 强制跳过依赖卸载升级：rpm -U RPM包名查询：rpm [参数] RPM包名常用参数：        rpm -vh                    //显示安装进度        rpm -qa                    //查询系统中安装的所有RPM软件包        rpm -q RPM包名             //查询指定软件包是否已安装        rpm -qp RPM包文件名         //查询包中文件信息，安装前了解软件包中信息        rpm -qi RPM包名            //查询系统中已安装包的描述信息        rpm -ql RPM包名            //查询系统中已安装包里所包含的文件        rpm -qf RPM包名            //查询系统中指定文件所属的软件包        rpm -qa | grep php         //检索系统中已经安装有关php的软件包        rpm --noscript             //不安装脚本        rpm --nosignature          //不检查合法来源        rpm --nodigest             //不检查完整性验证：rpm -V [参数]\n\n\n\ntarUnix和类Unix系统上的压缩打包工具，可以将多个文件合并为一个文件，打包后的文件后缀亦为“tar”。tar文件格式已经成为POSIX标准，最初是POSIX.1-1988，当前是POSIX.1-2001。本程序最初的设计目的是将文件备份到磁带上（tape archive），因而得名tar。tar命令是Unix&#x2F;Linux系统中备份文件的可靠方法，几乎可以工作于任何环境中，它的使用权限是所有用户。\ntar代表未压缩的tar文件。已压缩的tar文件则附加压缩文件的扩展名，如经过gzip压缩后的tar文件，扩展名为“.tar.gz”\n建立TAR包：将多个文件或目录打包成一个文件\ntar -cvf TAR包名.tar /PATH/TO/&lt;文件或目录名&gt;　　 //只打包不压缩 \ntar -zcvf TAR包名.gz /PATH/TO/&lt;文件或目录名&gt; 　　//将指定目录或文件打包后压缩，指定压缩格式为gz\ntar -jcvf TAR包名.bzip2 /PATH/TO/&lt;文件或目录名&gt; 　　//将指定目录或文件打包后压缩，指定压缩格式为bzip2\ntar -Jkc --level=9 -f TAR包名.xz /PATH/TO/&lt;文件或目录名&gt;    //将指定目录或文件打包后压缩，指定压缩格式为XZ,压缩级别为9（默认为6），并且强制执行,压缩后保留源文件\n\n查询TAR包中内容\ntar -tf /PATH/TO/TAR包名.tar\ntar -ztf /PATH/TO/TAR包名.tar.gz\ntar -tvf /PATH/TO/TAR包名.tar.xz\n\n释放TAR包\ntar -xvf /PATH/TO/TAR包名.tar\ntar -zxvf /PATH/TO/TAR包名.gz\ntar -xvf /PATH/TO/TAR包名.xz -C /newpath/    //将压缩包解压到指定的目录,通用的解压缩格式\n\nyumYum（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。\nyum 配置文件默认目录位置为 【&#x2F;etc&#x2F;yum.repos.d】\nyum -y install 包名   -y所有的提示都为yyum remove 包名       卸载\n\n修改yum源\n备份\nmv /etc/yum.repos.d/CentOS-AppStream.repo.repo /etc/yum.repos.d/CentOS-AppStream.repo.bakmv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bakmv /etc/yum.repos.d/CentOS-centosplus.repo.repo /etc/yum.repos.d/CentOS-centosplus.repo.bakmv /etc/yum.repos.d/CentOS-Devel.repo.repo /etc/yum.repos.d/CentOS-Devel.repo.bakmv /etc/yum.repos.d/CentOS-Epel.repo.backup /etc/yum.repos.d/CentOS-Epel.repo.bakmv /etc/yum.repos.d/CentOS-Extras.repo.backup /etc/yum.repos.d/CentOS-Extras.repo.bakmv /etc/yum.repos.d/CentOS-HA.repo /etc/yum.repos.d/CentOS-HA.repo.bakmv /etc/yum.repos.d/CentOS-PowerTools.repo /etc/yum.repos.d/CentOS-PowerTools.repo.bak\n\n下载新的 http://mirrors.aliyun.com/repo/Centos-8.repo,并命名为CentOS-Base.repo\nwget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-8.repo\n\n清除缓存\nyum clean all     # 清除系统所有的yum缓存yum makecache     # 生成yum缓存\n\n","categories":["Linux"],"tags":["Linux"]},{"title":"和小达一起学数据结构","url":"/2022/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95JS/","content":"1.数组JS中的数据结构相当于是API的调用\n1.1声明let arr = [&#x27;data1&#x27;,&#x27;data2&#x27;,&#x27;data3&#x27;]let arr = new Array()let arr = new Array(7)\n\n\n可以使用new关键字，也可以直接使用**中括号[]**声明一个数组\n用new创建数组可以定义数组的长度\n\n1.2取值arr[0]\n\n1.3长度arr.length\n\n1.4增删改查//增arr.push(元素1,元素2)//将一个或多个元素添加到数组的*末尾*，*并返回该数组的新长度*arr.unshift(元素1,元素2)//将一个或多个元素添加到数组的*开头*，*并返回该数组的新长度*//删arr.shift()//从数组中删除*第一个*元素，并*返回该元素的值*arr.pop()//从数组中删除*最后一个*元素，并*返回该元素的值*arr.splice(起始位置,删除个数)//从数组中删除*指定*元素//改arr[i] = 新值//查arr[i]\n\n1.5API//所有arr都相当于是Array构造的let arr = new Array(1,2,3)arr instanceof Array//1.concat数组拼接  let newarr = arr.concat(arr1,arr2)//2.sort数组排序    从小到大let newarr = arr.sort(function(a,b)&#123;return a-b&#125;)//3.join连接数组的每个元素成为字符串let str = arr.join(&#x27;-&#x27;)//4.reverse翻转数组顺序let newarr = arr.reverse()//5.from伪数组转真数组   伪数组中必须有length属性let newarr = Array.from(伪数组)//6.indexOf查找某个元素在数组中首次出现的索引值let num = arr.indexOf(&#x27;a&#x27;)//7.lastIndexOf查找某个元素在数组中最后出现的索引值let num = arr.lastIndexOf(&#x27;a&#x27;)//8.forEach遍历数组    第一个元素表示数组中的每一项，第二个表示每一项的下标，第三个表示数组本身arr.forEach(function(item,index,o)&#123;&#125;)//9.find用于查找首次出现的满足条件的值let re = arr.find(function(item,index,o)&#123;    return item &gt; 5&#125;)//10.findIndex用于查找首次出现的满足条件的值，返回找到的下标let re = arr.findIndex(function(item,index,o)&#123;    return item &gt; 5&#125;)//11.some用于查找，如果有一个满足，返回truearr.some(function(item,index,o)&#123;    return item &gt; 5&#125;)//12.every用于查找，全部满足，返回truearr.every(function(item,index,o)&#123;    return item &gt; 5&#125;)//13.filter筛选数组，把满足条件的元素放入新数组返回let newarr = arr.every(function(item,index,o)&#123;    return item &gt; 5&#125;)//14.map遍历数组，让每个元素都执行一遍回调函数，把所有结果放入新数组返回let newarr = [1,2,3,4].map(function(item,index,o)&#123;    return item * item&#125;)\n\n2.栈2.1栈的基本说明2.1.1数组\n数组是一种线性结构，可以在数组的任意位置插入和删除数据\n有时候需要对这种任意性加以限制，而栈和队列就是比较常见的受限的线性结构\n\n2.1.2栈\n栈是一种遵循**后进先出(LIFO-last in first out)**的有序集合。只能在一端添加或删除元素。\n新添加的或者待删除的元素都保存在栈的末尾，称为栈顶\n新元素靠近栈顶，旧元素靠近栈底\n\n问题：有六个元素6，5，4，3，2，1的顺序进栈，下列哪一个不是合法的出栈序列？A 5 4 3 6 1 2B 4 5 3 2 1 6C 3 4 6 5 2 1 D 2 3 4 1 5 6答案：C\n\n2.1.3代码实现栈结构//1.基于数组实现栈-----用数组保存放在栈里的元素//封装栈类function Stack()&#123;    //栈中的属性    this.items = []    //栈的相关操作    //1.push()       添加新元素到栈顶    Stack.prototype.push = function(element)&#123;        this.items.push(element)    &#125;    //2.pop()        删除栈顶元素，同时返回被删元素    Stack.prototype.pop = function()&#123;        return this.items.pop()       &#125;    //3.peek()       返回栈顶元素，不对栈做任何修改    Stack.prototype.peek = function()&#123;        return this.items[this.items - 1]    &#125;    //4.isEmpty()    如果栈里没有任何元素返回True，否则返回False    Stack.prototype.isEmpty = function()&#123;        return this.items.length == 0    &#125;    //5.size()       返回栈里元素个数，类似length    Stack.prototype.size = function()&#123;        return this.items.length    &#125;    //6.toString()   将栈结构的内容以字符的形式返回    Stack.prototype.toString = function()&#123;        let resultString = &#x27;&#x27;        for(let i = 0; i &lt; this.items.length; i++)&#123;            resultString += this.items[i] + &#x27; &#x27;        &#125;        return resultString    &#125;&#125;\n\n2.1.4栈实现十进制转二进制function dec2bin(decNumber)&#123;    //1.定义栈对象，用于保存    let stack = new Stack()    //2.循环操作    while(decNumber &gt; 0)&#123;        //2.1获取余数，放入栈        stack.push(decNumber % 2)        //2.2获取整出后的结果，作为下次一运算的数据        decNumber = Math.floor(decNumber / 2)    &#125;    //3.从栈中依次弹出    let binaryString = &#x27;&#x27;    while(!stack.isEmpty())&#123;        binaryString += stack.pop()    &#125;    return binaryString&#125;\n\n3.队列2.1对列的基本说明2.1.1队列\n栈是一种遵循**先进先出(FIFO-first in first out)**的有序集合。\n只允许在表的前端(front)进行删除操作，在表的后端(rear)进行插入操作\n\n2.1.2代码实现队列结构//1.基于数组实现队列-----用数组保存放在队列里的元素//封装队列类function Queue()&#123;    //属性    this.items = []    //方法    //1.enqueue()向队列尾部添加一个或多个新的项    Queue.prototype.enqueue = function()&#123;        this.items.push(element)    &#125;    //2.dequeue()删除队列第一的项，并返回该元素    Queue.prototype.dequeue = function()&#123;        this.items.shift()    &#125;    //3.front()返回队列中第一个元素    Queue.prototype.front = function()&#123;        return this.items[0]    &#125;    //4.isEmpty()如果队列没有任何元素，则返回true，否则false    Queue.prototype.isEmpty()&#123;        return this.items.length == 0    &#125;    //5.size()返回队列包含的元素个数，类似于length    Queue.prototype.size()&#123;        return this.items.length    &#125;    //6.toString()将队列的内容转成字符串形式    Queue.prototype.toString = function()&#123;        let resultString = &#x27;&#x27;        for(let i = 0; i &lt; this.items.length; i++)&#123;            resultString += this.items[i] + &#x27; &#x27;        &#125;        return resultString    &#125;&#125;\n\n2.1.3击鼓传花function passGame(nameList,num)&#123;    //1.创建队列    let queue = new Queue()    //2.把所有人加进来    for(let i = 0; i &lt; nameList.length; i++)&#123;        queue.enqueue(nameList[i])    &#125;    while(queue.size() &gt; 1)&#123;        //3.开始数数，不是num的时候，重新加入到队列的末尾        //是num的时候将其删除        for(let i = 0; i &lt; num - 1; i++)&#123;            queue.enqueue(queue.dequeue())        &#125;        queue.dequeue()    &#125;    //4.获取剩下的那个人    let endName = queue.front()    alert(endName)    return nameList.indexOf(endName)&#125;let names = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;,&#x27;g&#x27;,&#x27;h&#x27;,&#x27;i&#x27;,&#x27;j&#x27;]let num = 2passGame(names,2)\n\n2.2优先级队列2.2.1优先级队列\n普通的队列插入一个元素，数据会放在后端，并且需要前面所有的元素都处理完后才会处理后面的数据\n但是优先级队列在插入一个元素的时候会考虑该数据的优先级，和其他数据进行比较，比较完成后得出这个元素在队列的正确位置\n每个元素不再只是一个数据，还包含了数据的优先级\n在添加方式中，根据优先级放入正确的位置\n\n2.2.2代码实现优先级队列// 封装优先级队列function PriorityQueue()&#123;    function QueueElement(element,priority)&#123;        this.element = element        this.priority = priority    &#125;    //属性    this.items = []    //方法    //1.插入    PriorityQueue.prototype.enqueue = function(element,priority)&#123;        //1.创建QueueElement对象        let queueElement = new QueueElement(element,priority)        //2.判断队列是否为空        if(this.items == 0)&#123;            this.items.push(queueElement)        &#125;else&#123;            let add = false            for(let i = 0; i &lt; this.items.length; i++)&#123;                if(queueElement.priority &lt; this.items[i].priority)&#123;                    this.items.splice(i,0,queueElement)                    add = true                    break                &#125;              &#125;            if(!add)&#123;                this.items.push(queueElement)            &#125;        &#125;    &#125;    PriorityQueue.prototype.dequeue = function()&#123;        return this.items.shift()    &#125;    //3.front()返回队列中第一个元素    PriorityQueue.prototype.front = function()&#123;        return this.items[0]    &#125;    //4.isEmpty()如果队列没有任何元素，则返回true，否则false    PriorityQueue.prototype.isEmpty = function()&#123;        return this.items.length == 0    &#125;    //5.size()返回队列包含的元素个数，类似于length    PriorityQueue.prototype.size = function()&#123;        return this.items.length    &#125;    //6.toString()将队列的内容转成字符串形式    PriorityQueue.prototype.toString = function()&#123;        let resultString = &#x27;&#x27;        for(let i = 0; i &lt; this.items.length; i++)&#123;            resultString += this.items[i].element + &#x27; &#x27; + this.items[i].priority        &#125;        return resultString    &#125;&#125;let pq = new PriorityQueue()pq.enqueue(&#x27;abc&#x27;,1)pq.enqueue(&#x27;ccc&#x27;,5)pq.enqueue(&#x27;ccf&#x27;,3)pq.enqueue(&#x27;cgc&#x27;,2)alert(pq)\n\n3.链表3.1数组与链表3.1.1数组\n数组需要申请一段连续的内存空间，并且大小是固定的。当数组不能满足容量需求时，需要进行扩容，一般是申请一个更大的数组，然后将原数组中的元素复制过去\n数组开头或者中间插入数据成本很高，需要进行大量元素位移\n\n3.1.2链表\n链表中的元素在内存中不必是连续的空间\n链表中的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用组成\n\n优势\n\n内存空间不是必须连续的，可以充分利用计算机的内存，实现灵活的内存动态管理\n链表不必在创建时就确定大小，并且大小可以无限的延伸下去\n链表在插入和删除数据时,时间复杂度可以达到O(1)，相对数组效率高很多.\n\n缺点\n\n链表访问任何一个位置的元素时，都需要从头开始访问\n无法通过下标直接访问元素，需要从头一个个访问，直到找到对应元素\n\n3.2代码实现链表//封装链表类function LinkedList()&#123;    //内部的类   节点类    function Node(data)&#123;        this.data = data        this.next = null    &#125;    //属性    this.head = null  //会指向第一个节点    this.length = 0   //记录链表的长度    //方法    //1.append(element)在最后追加一个新节点    LinkedList.prototype.append = function(data)&#123;        //1.创建新节点        let newNode = new Node(data)        //2.判断是否添加的是第一个节点        if(this.length == 0)&#123;//2.1是第一个节点            //head指针指向第一个节点            this.head = newNode        &#125;else&#123;               //2.2不是第一个节点            let current = this.head            //找到最后一个节点            while(current.next)&#123;                current = current.next            &#125;            //最后节点的Next指向新节点            current.next = newNode        &#125;        //length        this.length += 1    &#125;    //2.toString()将链表的内容转成字符串形式    LinkedList.prototype.toString = function()&#123;        //1.定义变量        let current = this.head        let listString = &#x27;&#x27;        //2.循环获取一个个节点        while(current)&#123;            listString += current.data + &#x27; &#x27;            current = current.next        &#125;        return listString    &#125;    //3.insert()在任意位置插入数据    LinkedList.prototype.insert = function(position,data)&#123;        //1.对position进行越界判断        if(position &lt; 0 || position &gt; this.length) return false        //2.根据data创建newNode        let newNode = new Node(data)        //3.判断插入的位置是否是第一个        if(position == 0)&#123;            newNode.next =  this.head            this.head = newNode        &#125;else&#123;            let index = 0            let current = this.head            let previous = null            while(index++ &lt; position)&#123;                previous = current                current = current.next            &#125;            newNode.next = current            previous.next = newNode        &#125;        //4.length        this.length += 1        return true    &#125;    //4.get()获取对应位置的元素    LinkedList.prototype.get = function(position)&#123;        //1.越界判断        if(position &lt; 0 || position &gt;= this.length) return null        //2.获取对应的data        let current = this.head        let index = 0        while(index++ &lt; position)&#123;            current = current.next        &#125;        return current.data    &#125;    //5.indexOf(element)返回元素在列表中的索引，如果没有返回-1    LinkedList.prototype.indexOf = function(data)&#123;        //1.定义变量        let current = this.head        let index = 0        //2.开始查找        while(current)&#123;            if(current.data == data)&#123;                return index            &#125;            current = current.next            index += 1        &#125;        return -1    &#125;    //6.update()修改某个位置的元素    LinkedList.prototype.update = function(position,newData)&#123;        //1.越界判断        if(position &lt; 0 || position &gt;= this.length) return false        //2.获取对应的data        let current = this.head        let index = 0        while(index++ &lt; position)&#123;            current = current.next        &#125;        current.data = newData        return true    &#125;    //7.removeAt()从链表的特定位置删除一项    LinkedList.prototype.removeAt = function(position)&#123;        if(position &lt; 0 || position &gt;= this.length) return null        //判断是否删除的是第一个节点        let current = this.head        if(position == 0)&#123;            this.head = this.head.next        &#125;else&#123;            let index = 0                        let previous = null            while(index++ &lt; position)&#123;                previous = current                current = current.next            &#125;            previous.next = current.next        &#125;        this.length -= 1        return current.data    &#125;    //8.remove()从链表删除指定项    LinkedList.prototype.remove = function(data)&#123;        //获取data在列表中的位置        let position = this.indexOf(data)        //2.根据位置信息删除节点        return this.removeAt(position)    &#125;    //9.isEmpty()判断当前列表是不是空    LinkedList.prototype.isEmpty = function()&#123;        return this.length == 0    &#125;    //10.size()返回节点个数    LinkedList.prototype.isEmpty = function()&#123;        return this.length    &#125;&#125;\n\n3.3双向链表单向链表\n\n单向链表只能从头遍历到尾，或者从尾遍历到头，是单向的\n单向链表可以轻松到达下一个节点，但是很难回到前一个节点\n\n双向链表\n\n既可以从头遍历到尾，也可以从尾遍历到头\n一个节点既有向前连接的引用，也有向后连接的引用\n\n缺点\n\n实现复杂，每次插入或删除节点时需要处理四个引用\n占用内存空间更大\n\n3.4代码实现双向链表\nfunction DoublyLinkedList()&#123;    //属性    function Node(data)&#123;        this.data = data        this.prev = null        this.next = null    &#125;    this.head = null    this.tail = null    this.length = 0    //方法    //1.append(element)在最后追加一个新节点    DoublyLinkedList.prototype.append = function(data)&#123;        let newNode = new Node(data)        //1.判断原来的链表是否为空        if(this.length == 0)&#123;            this.head = newNode            this.tail = newNode        &#125;else&#123;            this.tail.next = newNode            newNode.prev = this.tail            this.tail = newNode        &#125;        this.length += 1    &#125;    //2.将链表转成字符串形式    //2.1 toString()    DoublyLinkedList.prototype.toString = function()&#123;        return this.backwardString()    &#125;    //2.2 forwardString()向前遍历    DoublyLinkedList.prototype.forwardString = function()&#123;        let current = this.tail        let resultString = &quot;&quot;        while(current)&#123;            resultString += current.data + &quot; &quot;            current = current.prev        &#125;        return resultString    &#125;    //2.3 backwardString()向后遍历    DoublyLinkedList.prototype.backwardString = function()&#123;        //1.定义变量        let current = this.head//current指向第一个节点        let resultString = &#x27;&#x27;        //2.一次向后遍历，获取每一个节点        while(current)&#123;            resultString += current.data + &quot; &quot;            current = current.next        &#125;        return resultString    &#125;    //3.insert(position,data)在任意位置插入数据    DoublyLinkedList.prototype.insert = function(position,data)&#123;        //1.越界判断        if(position &lt; 0 || position &gt; this.length) return false        //2.创建新的节点        let newNode = new Node(data)        //3.找到位置        let index = 0        let current = this.head        let previous = null        //3.1原来的列表是否为空        if(this.length == 0)&#123;            this.head = newNode            this.tail = newNode         &#125;else&#123;            //3.1判断position是否为0            if(position == 0)&#123;                this.head.prev = newNode                newNode.next = this.head                this.head = newNode            &#125;else if(position == this.length)&#123;                newNode.prev = this.tail                this.tail.next = newNode                this.tail = newNode            &#125;else&#123;                while(index++ &lt; position)&#123;                    current = current.next                &#125;                newNode.next = current                newNode.prev = current.prev                current.prev.next = newNode                current.prev = newNode            &#125;        &#125;        this.length += 1        return true    &#125;    //4.get(position)获取对应位置的元素    DoublyLinkedList.prototype.get = function(position)&#123;        if(position &lt; 0 || position &gt;= this.length) return null        let current = this.head        let index = 0        while(index++ &lt; position)&#123;            current = current.next         &#125;        return current.data    &#125;    //5.indexOf(element)返回元素在列表中的索引，如果没有返回-1    DoublyLinkedList.prototype.indexOf = function(data)&#123;        let current = this.head        let index = 0        while(current)&#123;            if(current.data == data)&#123;                return index            &#125;            current = current.next            index += 1        &#125;        return -1    &#125;    //6.update()修改某个位置的元素    DoublyLinkedList.prototype.update = function(position,newData)&#123;        if(position &lt; 0 || position &gt;= this.length) return false        let index = 0        let current = this.head        while(index++ &lt; position)&#123;            current = current.next        &#125;        current.data = newData        return true    &#125;    //7.removeAt()从链表的特定位置删除一项    DoublyLinkedList.prototype.removeAt = function(position)&#123;        if(position &lt; 0 || position &gt;= this.length) return null        //判断是否删除的是第一个节点        let current = this.head        if(this.length == 1)&#123;            this.head = null            this.tail = null        &#125;else&#123;            if(position == 0)&#123;                this.head.next.prev = null                this.head = this.head.next            &#125;else if(position == this.length - 1)&#123;                current = this.tail                this.tail.prev.next = null                this.tail = this.tail.prev            &#125;else&#123;                let index = 0                while(index++ &lt; position)&#123;                    current = current.next                &#125;                current.prev.next = current.next                current.next.prev = current.prev            &#125;        &#125;        this.length -= 1        return current.data    &#125;    //8.remove()从链表删除指定项    DoublyLinkedList.prototype.remove = function(data)&#123;        let index = this.indexOf(data)        return this.removeAt(index)    &#125;    //9.isEmpty()    DoublyLinkedList.prototype.isEmpty = function()&#123;        return this.length == 0    &#125;    //10.size()    DoublyLinkedList.prototype.isEmpty = function()&#123;        return this.length    &#125;    //11.getHead()获取链表第一个元素    DoublyLinkedList.prototype.getHead = function()&#123;        return this.head.element    &#125;    //12.getTail()获取链表最后一个元素    DoublyLinkedList.prototype.getTail = function()&#123;    return this.tail.element    &#125;&#125;\n\n4.集合4.1集合的基本说明\n集合比较常见的实现方式是哈希表\n\n集合是由一组无序的，不重复的元素构成\n\n没有顺序意味着不能通过下标访问，相同的对象在集合只有一份\n\nES6里面已经包含了Set类\n\n\n4.2代码封装集合结构基于Object对象实现\nfunction Set()&#123;    //属性    this.items = &#123;&#125;    //方法    //1.add(value)向集合添加一个新的项    Set.prototype.add = function(value)&#123;        //元素添加到集合        //判断集合中是否已经包含了该元素        if(this.has(value))&#123;            return false        &#125;        this.items[value] = value        return true    &#125;    //2.remove(value)从集合删除一个值    Set.prototype.remove = function(value)&#123;        if(!this.has(value))&#123;            return false        &#125;        delete this.items[value]        return true    &#125;    //3.has(value)如果值在集合中，返回True    Set.prototype.has = function(value)&#123;        return this.items.hasOwnProperty(value)    &#125;    //4.clear()移除集合中所有项    Set.prototype.clear = function()&#123;        this.items = &#123;&#125;    &#125;    //5.size()返回集合包元素的数量，类似于length    Set.prototype.size = function()&#123;        return Object.keys(this.items).length    &#125;    //6.values()返回一个包含集合所有值的数组    Set.prototype.values = function()&#123;        return Object.keys(this.items)    &#125;&#125;\n\n4.3集合间操作\n并集\n交集\n差集：存在于第一个集合且不存在第二个集合\n子集：验证一个给定集合是否是另一个集合的子集\n\n\nfunction Set()&#123;    //属性    this.items = &#123;&#125;    //方法    //1.add(value)向集合添加一个新的项    Set.prototype.add = function(value)&#123;        //元素添加到集合        //判断集合中是否已经包含了该元素        if(this.has(value))&#123;            return false        &#125;        this.items[value] = value        return true    &#125;    //2.remove(value)从集合删除一个值    Set.prototype.remove = function(value)&#123;        if(!this.has(value))&#123;            return false        &#125;        delete this.items[value]        return true    &#125;    //3.has(value)如果值在集合中，返回True    Set.prototype.has = function(value)&#123;        return this.items.hasOwnProperty(value)    &#125;    //4.clear()移除集合中所有项    Set.prototype.clear = function()&#123;        this.items = &#123;&#125;    &#125;    //5.size()返回集合包元素的数量，类似于length    Set.prototype.size = function()&#123;        return Object.keys(this.items).length    &#125;    //6.values()返回一个包含集合所有值的数组    Set.prototype.values = function()&#123;        return Object.keys(this.items)    &#125;    //1.并集    Set.prototype.union = function(otherSet)&#123;        //this:集合A        //ohterSet集合B        //1.创建新集合        let unionSet = new Set()        //2.将集合A中所有元素添加到新集合中        let values = this.values()        for(let i = 0; i &lt; values.length; i++)&#123;            unionSet.add(values[i])        &#125;        //3.去除B的元素判断是否需要加到新集合        values = otherSet.values()        for(let i = 0; i &lt; values.length; i++)&#123;            unionSet.add(values[i])        &#125;        return unionSet    &#125;    //2.交集    Set.prototype.intersection = function(otherSet)&#123;        let intersectionSet = new Set()        //从A中取出一个个元素判断是否同时存在于B中        let values = this.values()        for(let i = 0; i &lt; values.length; i++)&#123;            let item = values[i]            if(otherSet.has(item))&#123;                intersectionSet.add(item)            &#125;        &#125;        return intersectionSet    &#125;    //3.差集    Set.prototype.difference = function(otherSet)&#123;        let differenceSet = new Set()        //从A中取出一个个元素判断是否同时存在于B中        let values = this.values()        for(let i = 0; i &lt; values.length; i++)&#123;            let item = values[i]            if(!otherSet.has(item))&#123;                differenceSet.add(item)            &#125;        &#125;        return differenceSet    &#125;    //4.子集    Set.prototype.subset = function(otherSet)&#123;        //遍历集合A中所有的元素，如果发现A中的元素在B中不存在，返回false        let values = this.values()        for(let i = 0; i &lt; values.length; i++)&#123;            let item = values[i]            if(!otherSet.has(item)) return false        &#125;        return true    &#125;&#125;let setA = new Set()let setB = new Set()setA.add(1)setA.add(2)setA.add(2)setA.add(&#x27;q&#x27;)setB.add(&#x27;q&#x27;)setB.add(&#x27;w&#x27;)setB.add(&#x27;e&#x27;)setB.add(1)setB.add(2)setB.add(3)alert(setA.subset(setB))\n\n5.字典\n字典的主要特点是  对应关系–键值\n使用字典的方式{“age” : 18, “name” : “aoteman”}，可以通过key取出value\n字典中key不可重复，无序， value可以重复\n在JS中，似乎对象本身就是一种字典，在所有早期JS中没有字典这种数据类型，因此可以用对象取代替\n\n6.哈希表6.1数组和哈希数组\n\n数组在进行插入操作时，效率很低，因为后面的数据需要依次向后移\n数组进行查找操作时\n基于索引进行查找，效率非常高\n基于内容进行查找，效率很低\n\n\n数组进行删除操作时，效率也不高\n\n哈希表\n\n哈希表可以提供非常快速的插入-删除-查找操作，无论多少数据，插入和删除只需要接近常量的时间，即O(1)时间级，实际上只需要几个机器指令即可完成\n哈希表的速度比树还要快，基本可以瞬间查找到想要的元素，且编码容易得多\n但是，哈希表中的数据没有顺序，不能以一种固定的方式(从小到大等)遍历其中的元素\n而且哈希表中的key不允许重复，不能放置相同的key保存不同的元素\n\n6.2哈希表的基本说明\n哈希表的结构就是数组，不同的在于它对下标值的一种变换，称之为哈希函数，通过哈希函数可以获得HashCode\n哈希化： 将大数字转化成数组范围内下标的过程，称之为哈希化\n哈希函数： 通常我们将单词转化成大数字，大数字再进行哈希化的代码实现放在一个函数中，称之为哈希函数\n哈希表： 最终将数据插入到的这个数组，对整个结构的封装，称之为哈希表\n\n6.3冲突\n哈希化后的下标值依然可能会重复，称之为冲突，冲突不可避免但是有两种解决方案，链地址法，开放地址法\n\n链地址法：在数组的每一个位置都不再存储单独的一个元素，而是存储一个链表或者数组，重复的元素添加到链表的首端或者末端即可\n\n根据哈希化的Index找到这个数组或者链表时，通常使用线性查找，效率差不多\n如果新插入的数据用于取出的可能性更大，那么最好采用链表，因为数组在首位插入数据需要所有其他项后移\n\n\n\n开放地址法： 主要的工作方式是寻找空白的单元格来添加冲突的数据项，根据探索这个空白位置的方式不同，有三种方法线性探测，二次探测，再哈希法，区别是步长的不同。\n\n线性探测：依次向后找空白的单元格index+1。\n查找的过程也是index+1，但是查询到空位置就停止。\n删除的过程不能直接设置为null，否则再查找的过程中会出现问题，一般进**行特殊处理(比如设置为-1)**。\t\n但是线性探测容易产生一个问题–聚集，当有一连串的填充单元，会使我们需要探索多次，影响哈希表的性能。\n\n二次探测：优化的使线性探测的步长，比如从下标值x开始，x+1^2,x+2^2，一次探测比较长的距离。\n但是二次探测时当插入的数据如32-112-82-2-192，，那么他们依次累加的时候步长时相同的，会造成步长不一的一种聚集，依旧会影响效率，当然概率会小很多\n\n再哈希法：二次探测的探测步长时固定的，1，4，9，16以此类推，需要产生一种依赖关键字的探测序列，再哈希法就是把关键字用另外一个哈希函数(和第一个哈希函数不同，且输出不为0)，再做一次哈希化，用这次哈希化的结果作为步长\n\n\n/*stepSize = constant - (key % constant)*///其中constant是质数，且小于数组的容量，保证数据的分布更加均匀\n\n6.4哈希化的效率\n哈希表中执行插入和搜索的操作，如果没有产生冲突效率是非常高的\n如果发生冲突，平均探测长度以及平均时间取决于装填因子，随着装填因子变大，探测长度也越来越长\n\n/*装填因子 = 总数据项 / 哈希表长度*///开放地址法： 最大装填因子是1，必须寻找到空白的单元才能将元素放入//链地址法：\t 最大装填因子可以大于1，因为拉链法可以无限的延伸下去\n\n6.5优秀的哈希函数\n哈希表的主要优点是他的速度，所以哈希函数中应尽量少使用乘法和除法，因为性能低\n\n/*在前面，我们计算哈希值时cats = 3*x^3 + 1*x^2 + 20*x^1 + 17*x^0a_n*x^n + a_(n-1)*x^(n-1) + ... + a_1*x + a_0乘法次数:n(n+1)/2加法次数:n可以通过  霍纳法则(秦久韶算法),进行优化(((((a_n*x + a_(n-1))x + a_(n-2))x + a_(n-3))x...)x + a_1)x + a_0乘法次数:n加法次数:n时间复杂度直接从O(N2),降到了O(N)*/\n\n\n优秀的哈希函数应该尽可能将元素映射到不同的位置，让元素在哈希表中**均匀分布\n\n/*在使用常量的地方尽可能使用质数，如哈希表的长度，N次幂的底数但是，链地址法中质数没那么重要，甚至在java中故意是2的N次幂*/\n\n6.6Java中的哈希表\nJava中的哈希表采用的是链地址法\n\nHash Map 的初始长度是16，每次自动扩展，长度必须是2的次幂\n\nHash Map采用位运算的方式\n\nindex &#x3D; HashCode &amp; (length - 1)\n\n/*book的Hashcode为 3029737(十进制)/1011100011101011101001(二进制)length-1(16-1)的十进制为15，二进制为1111两个结果做 与运算 1011100011101011101001 &amp; 1111 = 1001，十进制为9，所以index = 9这样的方式相对于取模来说性能是高的，因为计算机更容易运算二进制的数据*//*但是JS中较大数据的位运算时会出问题，所以本文代码实现中还是使用取模此外，为了代码之后向开放地址法迁移，容量还是选择使用质数*/\n\n6.7哈希函数的代码实现//设计哈希函数1.字符串-&gt;比较大的数字(hashcode)2.大数字(hashcode)-&gt;压缩到数组范围function hashFunction(str,size)&#123;    //size:数组大小    //1.定义hashCode变量    let hashCode = 0    //2.霍纳算法,来计算hashcode的值    //cats -&gt; 获取Unicode编码    for(let i = 0; i &lt; str.length; i++)&#123;        hashCode = 37 * hashCode + str.charCodeAt(i)  //31 37 41        str.charCodeAt(i)//获取当前每一个字符对应的Unicode编码    &#125;    //3.取余操作    index = hashCode % size    return index&#125;//测试哈希函数alert(hashFunction(&#x27;abc&#x27;,7))alert(hashFunction(&#x27;cab&#x27;,7))alert(hashFunction(&#x27;nba&#x27;,7))\n\n6.8哈希表的代码实现\n//链地址法      //封装哈希表类function HashTable() &#123;  //属性  this.storage = [] //所有元素都放在数组里  //[[[key,vaue,[key,value]]],[],[],...,[]]  this.count = 0 //当前存放多少个长度,用来计算加载因子loadFactor,&gt;0.75扩容,&lt;0.25减少容量  this.limit = 7 //哈希表当前的总长度  //方法  //1.哈希函数  HashTable.prototype.hashFunc = function (str, size) &#123;    //size:数组大小    //1.定义hashCode变量    let hashCode = 0    //2.霍纳算法,来计算hashcode的值    //cats -&gt; 获取Unicode编码    for (let i = 0; i &lt; str.length; i++) &#123;      hashCode = 37 * hashCode + str.charCodeAt(i) //31 37 41      str.charCodeAt(i) //获取当前每一个字符对应的Unicode编码    &#125;    //3.取余操作    index = hashCode % size    return index  &#125;  //2.插入/修改：当传入一个(key,value)，如果不存在该key，插入；如果存在该key，修改。  HashTable.prototype.put = function(key,value)&#123;    //1.根据key获取索引值，降数据插入到对应的位置    let index = this.hashFunc(key,this.limit)    //2.根据索引值取出/创建bucket    let bucket = this.storage[index]      //2.1如果bucket不存在，创建并防止在该索引位置    if(bucket == null)&#123;      bucket = []      this.storage[index] = bucket    &#125;    //3.判断是新增还是修改原来的值，如果有值了，修改；没有，执行添加操作    for(let i = 0; i &lt; bucket.length ; i++)&#123;      let tuple = bucket[i]      if(tuple[0] == key)&#123;        tuple[1] = value        return      &#125;    &#125;    //4.添加操作    bucket.push([key,value])    this.count += 1   &#125;  //3.获取  HashTable.prototype.get = function(key)&#123;    //1.根据key获取对应的index    let index = this.hashFunc(key,this.limit)    //2.根据index获取对应的bucket    let bucket = this.storage[index]    //3.判断bucket是否为null，如果为null直接返回    if(bucket == null) return null    //4.线性查找bucket中俄每一个key是否等于传入的，如果等于直接返回对应value    for(let i = 0; i &lt; bucket.length; i++)&#123;      let tuple = bucket[i]      if(tuple[0] == key) return tuple[1]    &#125;    //5.遍历完后依然没有找到，return null    return null  &#125;  //4.删除操作  HashTable.prototype.remove = function(key)&#123;    //1.根据key获取index    let index = this.hashFunc(key,this.limit)    //2.根据index获取bucket    let bucket = this.storage[index]    //3.判断bucket是否存在，如果不存在返回false或者Null    if(bucket == null)&#123;      return null    &#125;    //4.线性查找bucket，寻找对应的数据，删除    for(let i = 0; i &lt; bucket.length; i++)&#123;      let tuple = bucket[i]      if(tuple[0] == key)&#123;        bucket.splice(i,1)      &#125;      this.count--      return tuple[1]    &#125;    //5.依然没有找到返回Null    return null  &#125;  // 5.isEmpty方法  HashTable.prototype.isEmpty = function () &#123;      return this.count == 0  &#125;  // 6.size方法  HashTable.prototype.size = function () &#123;      return this.count  &#125;&#125;//测试let hs = new HashTable()hs.put(&#x27;abc&#x27;,&#x27;123&#x27;)hs.put(&#x27;aaa&#x27;,&#x27;321&#x27;)hs.put(&#x27;bbb&#x27;,&#x27;124&#x27;)hs.put(&#x27;ccc&#x27;,&#x27;125&#x27;)hs.put(&#x27;ddd&#x27;,&#x27;126&#x27;)alert(hs.get(&#x27;abc&#x27;))hs.put(&#x27;abc&#x27;,&#x27;999&#x27;)alert(hs.get(&#x27;abc&#x27;))hs.remove(&#x27;abc&#x27;)alert(hs.get(&#x27;abc&#x27;))\n\n6.9哈希表的扩容思想\n上述代码将所有的数据放在长度为7的数组中，因为我们使用的是链地址法，LoadFactor(装载因子)可以大于1，也就是说这个哈希表可以无限插入新数据\n但是随着数据量的增多，每一个index对应的bucket会越来越长，也就会造成效率的降低 \n一旦扩容，所有的数据都需要重新调用哈希函数，获取不同的index，重新插入\n\n//封装哈希表类function HashTable() &#123;  //属性  this.storage = [] //所有元素都放在数组里  //[[[key,vaue,[key,value]]],[],[],...,[]]  this.count = 0 //当前存放多少个长度,用来计算加载因子loadFactor,&gt;0.75扩容,&lt;0.25减少容量  this.limit = 7 //哈希表当前的总长度  //方法  //1.哈希函数  HashTable.prototype.hashFunc = function (str, size) &#123;    //size:数组大小    //1.定义hashCode变量    let hashCode = 0    //2.霍纳算法,来计算hashcode的值    //cats -&gt; 获取Unicode编码    for (let i = 0; i &lt; str.length; i++) &#123;      hashCode = 37 * hashCode + str.charCodeAt(i) //31 37 41      str.charCodeAt(i) //获取当前每一个字符对应的Unicode编码    &#125;    //3.取余操作    index = hashCode % size    return index  &#125;  //2.插入/修改：当传入一个(key,value)，如果不存在该key，插入；如果存在该key，修改。  HashTable.prototype.put = function (key, value) &#123;    //1.根据key获取索引值，降数据插入到对应的位置    let index = this.hashFunc(key, this.limit)    //2.根据索引值取出/创建bucket    let bucket = this.storage[index]    //2.1如果bucket不存在，创建并防止在该索引位置    if (bucket == null) &#123;      bucket = []      this.storage[index] = bucket    &#125;    //3.判断是新增还是修改原来的值，如果有值了，修改；没有，执行添加操作    for (let i = 0; i &lt; bucket.length; i++) &#123;      let tuple = bucket[i]      if (tuple[0] == key) &#123;        tuple[1] = value        return      &#125;    &#125;    //4.添加操作    bucket.push([key, value])    this.count += 1    //5.判断是否需要扩容操作    if (this.count &gt; this.limit * 0.75) &#123;      let newSize = this.limit * 2      let newPrime = this.getPrime(newSize)      HashTable.resize(newPrime)    &#125;  &#125;  //3.获取  HashTable.prototype.get = function (key) &#123;    //1.根据key获取对应的index    let index = this.hashFunc(key, this.limit)    //2.根据index获取对应的bucket    let bucket = this.storage[index]    //3.判断bucket是否为null，如果为null直接返回    if (bucket == null) return null    //4.线性查找bucket中俄每一个key是否等于传入的，如果等于直接返回对应value    for (let i = 0; i &lt; bucket.length; i++) &#123;      let tuple = bucket[i]      if (tuple[0] == key) return tuple[1]    &#125;    //5.遍历完后依然没有找到，return null    return null  &#125;  //4.删除操作  HashTable.prototype.remove = function (key) &#123;    //1.根据key获取index    let index = this.hashFunc(key, this.limit)    //2.根据index获取bucket    let bucket = this.storage[index]    //3.判断bucket是否存在，如果不存在返回false或者Null    if (bucket == null) &#123;      return null    &#125;    //4.线性查找bucket，寻找对应的数据，删除    for (let i = 0; i &lt; bucket.length; i++) &#123;      let tuple = bucket[i]      if (tuple[0] == key) &#123;        bucket.splice(i, 1)      &#125;      this.count--      return tuple[1]      //判断是否需要缩小容量      if (this.limit &gt; 7 &amp;&amp; this.count &lt; this.limit * 0.25) &#123;        let newSize = Math.floor(this.limit / 2)        let newPrime = this.getPrime(newSize)        this.rezize(newPrime)      &#125;    &#125;    //5.依然没有找到返回Null    return null  &#125;  // 5.isEmpty方法  HashTable.prototype.isEmpty = function () &#123;    return this.count == 0  &#125;  // 6.size方法  HashTable.prototype.size = function () &#123;    return this.count  &#125;  //7.哈希表的扩容  HashTable.prototype.resize = function (newLimit) &#123;    //1.保存旧数组的内容    let oldStorage = this.storage    //2.重置所有的属性    this.storage = []    this.count = 0    this.limit = newLimit    //3.遍历oldStorage中所有的bucket    for (let i = 0; i &lt; oldStorage.length; i++) &#123;      //3.1取出对应的bucket      let bucket = oldStorage[i]      //3.2判断bucket是否为null      if (bucket == null) continue      //3.3如果bucket中有数据，那么取出数据，重新插入      for (let j = 0; j &lt; bucket.length; j++) &#123;        let tuple = bucket[j]        HashTable.put(tuple[0], tuple[1])      &#125;    &#125;  &#125;  //8.判断某个数字是否是质数  HashTable.prototype.isPrime = function (num) &#123;    let temp = parseInt(Math.sqrt(num))    for (let i = 2; i &lt;= temp; i++) &#123;      if (num % i == 0) return false    &#125;    return true  &#125;  //9.获取质数  HashTable.prototype.getPrime = function (num) &#123;    while(!this.isPrime(num))&#123;      num++    &#125;    return num  &#125;&#125;\n\n7.二叉树7.1树和其他数据解构\n数组\n优点：下标值访问效率很高\n缺点：插入和删除操作有大量位移，效率很低\n\n\n链表\n优点：插入和删除效率很高\n缺点：查找效率很低，需要从头访问\n\n\n哈希表\n优点：插入&#x2F;查询&#x2F;删除效率都很高\n缺点：空间利用率不高；元素是无序的，不能按照固定顺序来便利；不能快速找出最大值最小值等特殊的值\n\n\n树结构\n优点：综合了上面数据结构的优点，也弥补了上面的缺点；为了模拟某些场景，使用树解构非常方便\n\n\n\n7.2树的术语\n数： 由 n个节点构成的有限集合\n当 n=0时，称为空树\n\n\n对于任意非空树，具备以下性质：\n树中有一个称为 根 的特殊节点，用r表示\n其余节点可分为m个互不相交的有限子集，每个集合本身又是一棵树，称为原来树的子树\n\n\n节点的度：节点的子树个数\n数的度：树的所有节点中最大的度数\n叶节点：度为0的节点\n节点的层次：规定根节点在1层，其他任一节点的层数是父节点的层数+1\n树的深度：树中所有节点中的最大层次是这棵树的深度\n\n7.3二叉树\n如果树中每个节点最多只有两个子节点，这样的树就称为二叉树\n几乎所有的树都可以表示成二叉树\n\n\n二叉树的定义\n二叉树可以为空，也就是没有节点\n若不为空，则它是由根节点和称为其左子树TL和右子树TR两个不相交的二叉树组成\n\n\n二叉树的特性\n第i层的最大节点数： 2^(i-1)\n深度为k的二叉树有最大节点的总数为： 2^k - 1\n对于任何非空二叉树T。若a表示叶节点的个数，b是度为2的非叶节点个数，那么二者满足a = b + 1\n\n\n二叉树 的分类\n满二叉树：只有度为0和2的节点，且度为0的节点在同一层\n完全二叉树：除了底层节点未满，其余各层节点数都满。且最后一层自左向右的叶节点连续存在，只缺右侧若干节点\n二叉搜索树：左子树的所有节点值都大于根节点的值，右节点的所有节点值都大于根节点值\n平衡二叉搜索树：空树，或左右两个子树的高度差不超过1，并且左右两个子树都是平衡二叉树\n\n\n二叉树的存储\n链式存储：使用链表（一般都用链式存储）\n顺序存储：使用数组，父节点的下表是i，左子节点2i+1,右节点2i+2\n\n\n二叉树的遍历\n深度优先遍历：一般使用递归的方式实现的，一条路搜到底，再换一条路\n前序遍历（递归法、迭代法）：中，左，右（这里指的是子树，不是子节点）\n中序遍历（递归法、迭代法）：左，中，右\n后序遍历（递归法、迭代法）：左，右，中\n\n\n广度优先遍历：一层一层的去遍历\n层次遍历(迭代法)\n\n\n\n\n\n7.4封装二叉树// 创建BinarySearchTreefunction BinarySerachTree() &#123;  // 创建节点构造函数  function Node(key) &#123;    this.key = key    this.left = null    this.right = null  &#125;  // 保存根的属性  this.root = null  // 二叉搜索树相关的操作方法      //1. 向树中插入数据  BinarySerachTree.prototype.insert = function (key) &#123;    // 1.根据key创建对应的node    var newNode = new Node(key)    // 2.判断根节点是否有值    if (this.root === null) &#123;      this.root = newNode    &#125; else &#123;      this.insertNode(this.root, newNode)    &#125;  &#125;  BinarySerachTree.prototype.insertNode = function (node, newNode) &#123;    if (newNode.key &lt; node.key) &#123;      // 1.准备向左子树插入数据      if (node.left === null) &#123;        // 1.1.node的左子树上没有内容        node.left = newNode      &#125; else &#123;        // 1.2.node的左子树上已经有了内容        this.insertNode(node.left, newNode)      &#125;    &#125; else &#123;      // 2.准备向右子树插入数据      if (node.right === null) &#123;        // 2.1.node的右子树上没有内容        node.right = newNode      &#125; else &#123;        // 2.2.node的右子树上有内容        this.insertNode(node.right, newNode)      &#125;    &#125;  &#125;  //2. 获取最大值和最小值  BinarySerachTree.prototype.min = function () &#123;    var node = this.root    while (node.left !== null) &#123;      node = node.left    &#125;    return node.key  &#125;  BinarySerachTree.prototype.max = function () &#123;    var node = this.root    while (node.right !== null) &#123;      node = node.right    &#125;    return node.key  &#125;  // 3.搜搜特定的值  /*  BinarySerachTree.prototype.search = function (key) &#123;      return this.searchNode(this.root, key)  &#125;  BinarySerachTree.prototype.searchNode = function (node, key) &#123;      // 1.如果传入的node为null那么, 那么就退出递归      if (node === null) &#123;          return false      &#125;      // 2.判断node节点的值和传入的key大小      if (node.key &gt; key) &#123; // 2.1.传入的key较小, 向左边继续查找          return this.searchNode(node.left, key)      &#125; else if (node.key &lt; key) &#123; // 2.2.传入的key较大, 向右边继续查找          return this.searchNode(node.right, key)      &#125; else &#123; // 2.3.相同, 说明找到了key          return true      &#125;  &#125;  */  BinarySerachTree.prototype.search = function (key) &#123;    var node = this.root    while (node !== null) &#123;      if (node.key &gt; key) &#123;        node = node.left      &#125; else if (node.key &lt; key) &#123;        node = node.right      &#125; else &#123;        return true      &#125;    &#125;    return false  &#125;  // 4.删除节点  BinarySerachTree.prototype.remove = function (key) &#123;    // 1.获取当前的node    var node = this.root    var parent = null    // 2.循环遍历node    while (node) &#123;      if (node.key &gt; key) &#123;        parent = node        node = node.left      &#125; else if (node.key &lt; key) &#123;        parent = node        node = node.right      &#125; else &#123;        if (node.left == null &amp;&amp; node.right == null) &#123;        &#125;      &#125;    &#125;  &#125;  BinarySerachTree.prototype.removeNode = function (node, key) &#123;    // 1.如果传入的node为null, 直接退出递归.    if (node === null) return null    // 2.判断key和对应node.key的大小    if (node.key &gt; key) &#123;      node.left = this.removeNode(node.left, key)    &#125;  &#125;  // 删除结点  BinarySerachTree.prototype.remove = function (key) &#123;    // 1.定义临时保存的变量    var current = this.root    var parent = this.root    var isLeftChild = true    // 2.开始查找节点    while (current.key !== key) &#123;      parent = current      if (key &lt; current.key) &#123;        isLeftChild = true        current = current.left      &#125; else &#123;        isLeftChild = false        current = current.right      &#125;      // 如果发现current已经指向null, 那么说明没有找到要删除的数据      if (current === null) return false    &#125;    // 3.删除的结点是叶结点    if (current.left === null &amp;&amp; current.right === null) &#123;      if (current == this.root) &#123;        this.root == null      &#125; else if (isLeftChild) &#123;        parent.left = null      &#125; else &#123;        parent.right = null      &#125;    &#125;    // 4.删除有一个子节点的节点    else if (current.right === null) &#123;      if (current == this.root) &#123;        this.root = current.left      &#125; else if (isLeftChild) &#123;        parent.left = current.left      &#125; else &#123;        parent.right = current.left      &#125;    &#125; else if (current.left === null) &#123;      if (current == this.root) &#123;        this.root = current.right      &#125; else if (isLeftChild) &#123;        parent.left = current.right      &#125; else &#123;        parent.right = current.right      &#125;    &#125;    // 5.删除有两个节点的节点    else &#123;      // 1.获取后继节点      var successor = this.getSuccessor(current)      // 2.判断是否是根节点      if (current == this.root) &#123;        this.root = successor      &#125; else if (isLeftChild) &#123;        parent.left = successor      &#125; else &#123;        parent.right = successor      &#125;      // 3.将删除节点的左子树赋值给successor      successor.left = current.left    &#125;    return true  &#125;  // 找后继的方法  BinarySerachTree.prototype.getSuccessor = function (delNode) &#123;    // 1.使用变量保存临时的节点    var successorParent = delNode    var successor = delNode    var current = delNode.right // 要从右子树开始找    // 2.寻找节点    while (current != null) &#123;      successorParent = successor      successor = current      current = current.left    &#125;    // 3.如果是删除图中15的情况, 还需要如下代码    if (successor != delNode.right) &#123;      successorParent.left = successorParent.right      successor.right = delNode.right    &#125;  &#125;  // 遍历方法  // 先序遍历  BinarySerachTree.prototype.preOrderTraversal = function (handler) &#123;    this.preOrderTranversalNode(this.root, handler)  &#125;  BinarySerachTree.prototype.preOrderTranversalNode = function (node, handler) &#123;    if (node !== null) &#123;      handler(node.key)      this.preOrderTranversalNode(node.left, handler)      this.preOrderTranversalNode(node.right, handler)    &#125;  &#125;  // 中序遍历  BinarySerachTree.prototype.inOrderTraversal = function (handler) &#123;    this.inOrderTraversalNode(this.root, handler)  &#125;  BinarySerachTree.prototype.inOrderTraversalNode = function (node, handler) &#123;    if (node !== null) &#123;      this.inOrderTraversalNode(node.left, handler)      handler(node.key)      this.inOrderTraversalNode(node.right, handler)    &#125;  &#125;  // 后续遍历  BinarySerachTree.prototype.postOrderTraversal = function (handler) &#123;    this.postOrderTraversalNode(this.root, handler)  &#125;  BinarySerachTree.prototype.postOrderTraversalNode = function (node, handler) &#123;    if (node !== null) &#123;      this.postOrderTraversalNode(node.left, handler)      this.postOrderTraversalNode(node.right, handler)      handler(node.key)    &#125;  &#125;&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["计算机基础"],"tags":["数据结构"]},{"title":"数据结构指南","url":"/2022/08/11/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/","content":"一、基本概念1. 什么是数据结构简单地说，数据结构是以某种特定的布局方式存储数据的容器。这种“布局方式”决定了数据结构对于某些操作是高效的，而对于其他操作则是低效的。首先我们需要理解各种数据结构，才能在处理实际问题时选取最合适的数据结构。\n2. 数据结构三要素逻辑结构：数据元素之间的逻辑关系\n\n线性结构（一对一关系）：线性表、栈、队列\n非线性结构（一对多关系）：树、图、集合\n\n存储结构（物理结构）：数据结构在计算机中的表示，是用计算机语言实现的逻辑结构\n\n顺序存储\n链式存储\n索引存储\n散列存储\n\n数据的运算：施加在数据上的运算，包括运算的定义和实现。运算的定义针对逻辑结构，运算的实现针对存储结构。\n3. 什么是算法算法是对特定问题求解步骤的一种描述，它是指令的有限序列。\n算法的5个重要特性：\n\n有穷性：一个算法必须在执行有穷步之后结束，且每一步都在有限时间内完成\n确定性：算法中的每条指令必须有确切的含义，不会产生二义性\n可行性：算法中描述的操作都是通过已经实现的基本运算执行有限次来实现的\n输入：一个算法有零个或多个输入（可以没有输入）\n输出：一个算法有一个或多个输出（至少存在一个输出）\n\n4. 算法效率的度量\n时间复杂度\n一个语句的频度是指该语句在算法中被重复执行的次数。算法中所有语句的频度之和记为 T(n)，n 表示问题的规模，T(n) 是问题规模的函数。时间复杂度 &#x3D; T(n) 的数量级\n\n空间复杂度\n该算法耗费的存储空间\n\n\n5. 数据结构和算法之间的关系算法是对特定问题的求解步骤，在计算机中表现为指令的有穷序列。\n算法 + 数据结构 &#x3D; 程序。\n算法只有在合适的数据结构中才能发挥作用，数据结构的不同，会影响算法的选择和效率。\n\n\n\n\n二、线性表1. 数组&#x2F;顺序表和链表的区别从逻辑结构上来看\n\n数组必须实现定于固定的长度，不能适应数据动态增减的情况，即数组的大小一旦定义就不能改变。当数据增加是，可能超过原先定义的元素的个数；当数据减少时，造成内存浪费\n\n链表动态进行存储分配，可以适应数据动态地增减的情况，且可以方便地插入、删除数据项。\n\n\n从内存存储的角度看\n\n数组从栈中分配空间（用new则在堆上创建），对程序员方便快速，但是自由度小；\n链表从堆中分配空间，自由度大但是申请管理比较麻烦。\n\n从访问方式类看\n\n数组在内存中是连续的存储，逻辑上相邻，物理位置也相邻，因此可以实现随机存取，利用下标索引进行访问；\n链表是链式存储结构，在访问元素时候只能够通过线性方式由前到后顺序的访问，所以访问效率比数组要低。\n\n\n2. 相关算法题\n顺序表相关算法\n链表相关算法\n\n\n\n\n\n三、栈和队列1. 栈和队列的区别\n队列先进先出，栈先进后出。\n\n对插入和删除操作的”限定”不同。\n栈是限定只能在表的同一端进行插入和删除操作的线性表。   \n队列是限定只能在表的一端进行插入和在另一端进行删除操作的线性表。 \n\n遍历数据速度不同。\n栈只能从头部取数据，也就最先放入的需要遍历整个栈最后才能取出来，而且在遍历数据的时候还得为数据开辟临时空间，保持数据在遍历前的一致性。\n队列则不同，它基于地址指针进行遍历，而且可以从头或尾部开始遍历，但不能同时遍历，无需开辟临时空间，因为在遍历的过程中不影像数据结构，速度要快的多\n\n\n2. 什么是队列的假上溢现象，如何解决队列从队尾入队，从队头出队。\n每次出队队头指针+1，当队头指针 &#x3D; maxnum 时，出现假溢出现象。即队列中尚有足够的空间，但元素确不能入队。\n\n解决方法：\n\n建立一个足够大的存储空间以避免溢出，但这样做空间使用率低，浪费存储空间\n移动元素：每当出队一个元素，就将移动队列中所有的已有元素向队头移动一个位置\n循环队列：将队头和队尾看作是一个首尾相接的循环队列\n\n3. 循环队列的优缺点\n循环队列的优点：\n可以有效的利用资源。用数组实现队列时，如果不移动，随着数据的不断读写，会出现假满队列的情况。即尾数组已满但头数组还是空的；循环队列也是一种数组，只是它在逻辑上把数组的头和尾相连，形成循环队列，当数组尾满的时候，要判断数组头是否为空，不为空继续存放数据。\n\n循环队列的缺点：\n循环队列中，由于入队时尾指针向前追赶头指针；出队时头指针向前追赶尾指针，造成队空和队满时头尾指针均相等。因此，无法通过条件front &#x3D;&#x3D; rear来判别队列是”空”是”满”。\n解决这个问题有两个办法：\n\n增加一个参数，用来记录数组中当前元素的个数；\n第二个办法是，少用一个存储空间，也就是数组的最后一个存数空间不用，当（rear+1）%maxsize&#x3D;front 时，队列满\n\n这也就是为什么循环队列的顺序表中要空一个位置（用来区分队列空和队列满）。\n\n\n4. 堆和栈的区别首先：讨论的堆和栈是内存中的 堆区 和 栈区，而不是数据结构中的堆和栈\nC++中的内存区域分为5个区：堆区、栈区、全局&#x2F;静态存储区、常量存储区、代码程序区\n\n栈（stack）：存放函数的参数值、局部变量等，由编译器自动分配和释放，通常在函数执行完后就释放了，其操作方式类似于数据结构中的栈。栈内存分配运算内置于CPU的指令集，效率很高，但是分配的内存量有限。\n\n堆（heap）：由程序员控制内存的分配和释放的存储区，是不连续的存储空间，堆的分配(new)和释放(delete)有程序员控制，容易造成二次删除和内存泄漏，堆的分配方式类似于链表\nvoid fun()&#123;    int *p = new int[5];&#125;\n\n在上述代码中就包含了堆和栈，看到new，我们就知道分配了一块堆内存，那么指针p呢，它分配的是一块栈内存。即在栈内存中存放了一个指向一块堆内存的指针p\n\n静态存储区（static）：存放全局变量和静态变量的存储区，初始化的变量放在初始化区，未初始化的变量放在未初始化区。在程序结束后释放这块空间\n\n常量存储区（const）：存放常量字符串的存储区，只能读不能写\n\n程序代码区：存放源程序二进制代码\n\n\n\n\n了解上述知识后我们再来明确堆和栈的区别：\n\n\n\n不同点\n栈\n堆\n\n\n\n① 管理方式不同\n编译器自动分配和释放\n程序员手动分配(new)和释放(delete)\n\n\n② 空间大小不同\n可分配的栈区内存空间较小\n可分配的堆区内存较大。一般在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的\n\n\n③ 能否产生碎片不同\n栈不存在碎片问题，因为它是严格的先进先出，在某个数据弹出之前，它上面的后进入的内容已经被全部弹出了\n对于堆来说，频繁的new&#x2F;delete势必会造成内存空间的不连续，从而造成大量的内存碎片\n\n\n④地址生长方向不同\n生长方向向下，向着内存地址减小的方向增长\n生长方向向上，向着内存地址增加的方向增长\n\n\n⑤分配方式不同\n栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配，动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。\n堆都是动态分配的，没有静态分配的堆。\n\n\n⑥ 分配效率不同\n栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高\n堆则是C&#x2F;C++函数库提供的，它的机制是很复杂的，堆的效率比栈要低得多\n\n\n\n\n\n\n四、树1. 二叉树的存储方式\n顺序存储结构：\n用一个数组来存储一颗二叉树，二叉树中的结点值按照编号依次存入一个一维数组中。 适用于完全二叉树，若用于一般的二叉树则会浪 费大量 存储空间。\n\n链式存储结构：\n二叉树中的每一个结点用一个链结点来存放，拥有左右孩子结点\n\n\n2. 什么是堆？有什么作用？定义：\n堆是一种数据结构，可以把堆看成一个完全二叉树，并且这个完全二叉树满足： 任何一个非叶节点的值都不大于（或不小于）其左右子树的结点的值。若父亲大孩子小，则为大顶堆，若 父亲小孩子大，则为小顶堆。 \n作用：\n应用于堆排序\n3. 完全二叉树若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。\n完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。\n4. 完全二叉树的判定思路： 完全二叉树的结点编码是连续的，根据层次遍历，把所有结点依次入队，包括空结点，若空结点之后还有非空结点，就不是完全二叉树\n代码：\nbool isComplete(BiTree T)&#123;    if(!T)        return true;    InitQueue(Q);    BiTNode *p = T;    EnQueue(Q,T);    while(!isEmpty(Q))&#123;        DeQueue(Q,p);        if(p)&#123;            EnQueue(Q,p-&gt;lchild);            EnQueue(Q,p-&gt;rchild);        &#125;        else&#123;            while(!isEmpty(Q))&#123;                DeQueue(Q,p);                if(p)                    return false;            &#125;        &#125;    &#125;    return true;&#125;\n\n5. 二叉排序树 BST定义：\n二叉排序树又称二叉搜索树，它或者是一颗空树，或者满足一下性质的二叉树：\n\n若左子树不空，则左子树上所有结点的值均小于根节点的值； \n\n若右子树不空，则右子树上所有结点的值均大于根节点的值；\n\n左右子树也分别是二叉排序树。\n\n\n查找过程：\n\n若根结点的关键字值等于查找的关键字，成功。 \n否则，若小于根结点的关键字值，递归查左子树。 \n若大于根结点的关键字值，递归查右子树。 \n若子树为空，查找不成功。\n\n6. 二叉排序树的判定思路：二叉排序树的中序遍历序列一定为递增序列\n代码：\n//利用中序遍历为递增bool isBST(BiTree T)&#123;    if(T==NULL)        return true;    else&#123;        bool bl = isBST(T-&gt;lchild);        if(bl==false || pre&gt;T-&gt;data)            return false;        pre = T-&gt;data;        bool br = isBST(T-&gt;rchild);        return br;    &#125;&#125;\n\n\n\n7. 平衡二叉树 AVL定义：平衡二叉树又称AVL树，是一种特殊的二叉排序树，其左右子树都是平衡二叉树，且左右子树的高度差的 绝对值不超过1. \n平衡因子： 左子树高度减去右子树高度的差。 \n平衡调整： 先找到失去平衡的最小子树，即以距离插入结点最近，且平衡因子绝对值大于 1 的结点作为为根节点的子树，分为LL,LR,RL,RR四种调节方式。 \n8. 平衡二叉树的判定思路：平衡二叉树的每一个结点都是平衡的，利用后序遍历按照左右根的次序依次判断是否平衡二叉树\nint isAVL(BiTree T,int &amp;h,int &amp;balance)&#123;    int bl,br,hl,hr; //左右子树的高度和平衡性    if(T==NULL)&#123;        balance = 1;        h = 0;    &#125;    else if(!T-&gt;lchild &amp;&amp; !T-&gt;rchild)&#123; //左右孩子均不存在        balance = 1;        h = 1;    &#125;    else&#123;        isAVL(T-&gt;lchild,hl,bl); //判定左子树        isAVL(T-&gt;rchild,hr,br); //判定右子树        h = hl&gt;hr?hl:hr;        if(bl&amp;&amp;br &amp;&amp; abs(hl-hr)&lt;2) //若左右子树均平衡且高度差小于等于1            balance = 1;        else            balance = 0;    &#125;&#125;\n\n9. 哈夫曼树（最优二叉树）定义： \n给定n个权值作为n个叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman tree)。 \n构造方法： \n假设有 n 个权值，则构造出的哈夫曼树有 n 个叶子结点。 n 个权值分别设为 w1、w2、…、wn，则哈夫 曼树的构造规则为： \n\n将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)； \n\n在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其 左、右子树根结点权值之和； \n\n从森林中删除选取的两棵树，并将新树加入森林； \n\n重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。\n\n\n特点：\n\n权值越大的结点，距离根节点越近； \n\n树中没有度为一的结点。\n\n\n应用： \n哈夫曼编码，减少编码的长度。哈夫曼编码就是长度最短的前缀编码\n\n\n\n\n五、图1. 图的相关概念\n图：由结点的有穷集合V和边的集合E组成。 \n\n类别：有向图和无向图。 \n\n顶点的度：出度和入度。 \n\n有向完全图和无向完全图：  \n若有向图有n个顶点，则最多有 n(n-1) 条边，则称为有向完全图\n无向图有n个顶点，则最多有 n(n-1)&#x2F;2 条边，则称为无向完全图。 \n\n路径：相邻顶点序偶所构成的序列。 \n\n简单路径：序列中的顶点不重复出现的路径。 \n\n回路：路径中第一个顶点和最后一个顶点相同的路径。 \n\n连通： \n无向图中，如果Vi到Vj有路径，则称这两个顶点连通。如果图中任意两个顶点之间都连通，则称该图为连通图。 \n有向图中，如果 Vi 到 Vj 有路径，且反过来 Vj 到 Vi 也有路径，则称这两个顶点强连通。如果图中每一对顶点 Vi 和 Vj，从 Vi到 Vj 和 Vj 到 Vi 都有路径，则称该图为强连通图。\n\n\n2. 图的存储方式\n邻接矩阵：是图的顺序存储结构，用两个数组分别存储数据元素（顶点）信息和数据元素之间的关系（边&#x2F;弧）的信息。一维数组存储顶点集，二维数组存储边集。图的邻接矩阵表示是唯一的，无向图的邻接矩阵是对称 的。\n邻接表：是图的链式存储结构，一个单链表表示该顶点的边表；各个单链表的头指针和顶点采用顺序存储连接起来表示顶点表\n十字链表：有向图的另一种链式存储结构。 \n邻接多重表：无向图的链式存储结构。\n\n3. 邻接矩阵和邻接表对比\n\n\n邻接矩阵\n邻接表\n\n\n\n① 顺序存储\n① 链式存储\n\n\n② 无向图的邻接矩阵第i行（列）非零元素的个数表示该顶点的度\n② 无向图的同一条边在邻接表中存储的两次。如果想要知道顶点的度，只需要求出所对应链表的结点个数即可。\n\n\n③ 有向图的邻接矩阵第i行（列）非零元素的个数表示该顶点的出度（入度）\n③ 有向图中每条边在邻接表中只出现一次，求顶点的出度只需要遍历所对应链表即可。求入度则需要遍历其他顶点的链表。\n\n\n④ 无向图的邻接矩阵是对称的\n\n\n\n邻接矩阵的优点是可以快速判断两个顶点之间是否存在边，可以快速添加边或者删除边。而其缺点是如果顶点之间的边比较少，会比较浪费空间，因为是一个 n∗n 的矩阵。\n邻接表的优点是节省空间，只存储实际存在的边，可以方便的找出一顶点的所有领边。其缺点是求解顶点的入度时，就可能需要遍历一个链表。\n\n\n4. 深度优先搜索遍历和广度优先搜索遍历的过程BFS: 类似于层次遍历\n基本思想 ：利用 队列 实现。\n\n首先访问起始顶点 V 并将其入队\nV出队，并遍历V的所有邻接点 w1，w2，….，wn并依次入队\nw1出队，并遍历 w1 的全部邻接点(不包括已经被访问的点)\nw2出队，并遍历w2的全部邻接点(不包括已经被访问的点)\n……. 以此类推\n\nDFS: 类似于先序遍历\n基本思想：利用 递归/栈 实现。当不能继续向下访问时，依次回退到最近的被访问结点\n\n首先访问顶点V，并将其标记为已访问\n然后访问与顶点V的其中一个未被访问的邻接点W，并将其标记为已访问\n再访问W的其中一个未被访问的邻接点，并将其标记为已访问\n依次类推….. 当一个顶点所有的邻接顶点都被访问过时，则依次退回最近被访问过的顶点\n\n\n图的深度遍历是否唯一 \n不一定唯一。因为我们可以取图中任一顶点进行深度遍历。\n\n5. 最小生成树及相关算法最小生成树的定义：\n一个包含原图中所有结点的连通图的生成树就是原图的极小连通子图，并且拥有保持图连通的最少的边。如果在最小生成树中添加一条边，必定成一个环。\nN个结点的最小生成树有 N 个结点，N-1 条边。\n\n\n相关算法：\n\nPrim 算法\n每次都在互相连通的基础上选取相对最小的边。需保证无环\n\nKruscal 算法\n每次选取最小的边，无须保证此过程是否连通。需保证无环\n\n\n5. 最短路径及相关算法① Dijkstra 算法\n该算法可以求得某一顶点到其余各顶点的最短路径。\n算法思想：\n\n设有两个顶点集合 S 和 T，其中集合 S 中存放的是图中已找到最短路径的顶点，集合 T 中存放 的是图中的剩余顶点。\n\n初始状态时，集合 S 中只包含源点 V0，然后不断从集合 T 中选取到顶点 V0 路径最短的顶点 Vu 并加入集合 S 中，之后的路径可通过该结点\n\n集合 S 每加入一个新的顶点 Vu，都要修改 V0 到集合 T 中各个顶点的最短路径的长度值。\n\n不断重 复这个过程，直至集合T中的顶点全部并入到 S 中为止。\n\n\n\n\n\n② Floyd算法\n每次都试图在路径上添加新的中间结点\n\n7. 拓扑排序什么图可以进行拓扑排序？ 有向无环图\n基本思想 ：每次去除一个入度为0的结点和该与顶结点相连的边\n若图中存在一条A——&gt;B的路径，则在拓扑排序中表示B事件在A事件的后面\n\n\n\n\n\n六、查找1. 总览\n顺序结构\n顺序查找\n折半查找：仅适用于有序的顺序表\n分块查找：索引顺序查找\n\n\n树形结构\n二叉排序树\n平衡二叉树\nB &#x2F; B+ 树\n红黑树\n\n\n散列结构\n散列表\n\n\n字符串模式匹配\nKMP 算法\n\n\n\n1. 常见的哈希函数构造方法\n直接定址法\nH(key) = a*key + b\n\n数字分析法\n\n平方取中法\n\n除留余数法\nH(key) = key % p (p为不大于m的最大质数)\n\n\n2. 什么是哈希冲突？处理冲突的方法散列（哈希）表： 根据关键码值(Key value)而直接进行访问的数据结构。根据给定的关键字来计算出关键字在表中的地址，以加快查找的速度。 \n哈希冲突：指的是多个关键字映射同一个地址的情况。 \n解决办法： \n\n开放定址法 \n\n① 线性探查法（产生堆积问题）：冲突发生时顺序查找下一个位置\n② 平方探查法（不能探查到哈希表上所有的地址，但至少能探查到一半的地址）\n\n\n链地址法 \n所有的同义词都存储在一个线性链表中。\n\n\n3. KMP 算法在一个字符串中查找是否包含目标的匹配字符串。其主要思想是每趟比较过程让子串先后滑动一个合适的位置。当发生不匹配的情况时，不是右移一位，而是移动（当前匹配的长度– 当前匹配子串的部分匹配值）位。使用一个next数组维护每个字符对应的移动位数。\n4. M阶B树和M阶B+树的主要区别B&#x2F;B+树一种平衡的多路查找树，一般被用在文件系统（我们常说的B树其实是叫 B- 树）\n\n\n\nB 树 M阶\nB+ 树 M阶\n\n\n\n① 关键字个数 + 1 &#x3D; 子树个数\n① 关键字个数 &#x3D; 子树个数\n\n\n② 根节点至少2棵子树（1个关键字），至多M棵子树（M-1个关键字）\n② 根节点至少2棵子树（2个关键字），至多M棵子树（M个关键字）\n\n\n③ 除根节点的分支结点至少 M&#x2F;2 取上整 棵子树（至少 M&#x2F;2 取上整 - 1 个关键字），至多 M 棵子树（至多 M - 1个关键字）\n③ 除根节点的分支结点至少 M&#x2F;2 取上整 棵子树至少 M&#x2F;2 取上整 -个关键字），至多 M 棵子树至多 M 个关键字）\n\n\n④ B 树的叶节点不带任何信息，所有的信息（key，value）都存在分支结点中\n④ B+树叶子结点携带所有结点的全部信息（key，value），且按照大小顺序通过指针链接起来，分支结点仅携带索引信息（key）起索引作用。所以B+ 树的查找更稳定，因为每次都是从根节点到叶节点的查找路径\n\n\n下图为 B+ 树\n\n\n\n\n\n七、排序1. 排序算法总览① 插入排序：O(n^2)\n直接插入 稳定\n边查边移动。把待排序的记录按照关键字的大小逐个插入到已经排好序的有序序列中，直到所有的记录都插入完为止\n\n\n折半插入 稳定\n先查后移。将直接插入排序中 寻找待排记录在有序序列中的位置的方法 改为采用折半查找。\n仅仅减少了查找排序的比较次数，元素的移动次数并未改变\n\n希尔排序 不稳定\n又称缩小增量排序。把记录按照下标的一定增量进行分组，对每组使用直接插入排序算法进行排序。\n随着增量的减少，每组包含的关键字越来越多，当增量减为 1 时，整个序列被分为一组，算法便终止。\n\n\n② 交换排序\n冒泡排序 O(n^2) 稳定\n从前往后（从后往前）两两比较相邻的元素，若为逆序，则交换，直到序列比较完，最小（大）的元素浮现在末端（顶端）称为一组冒泡。\n下一趟冒泡时，前一趟已经确定的最小（大）元素不再参加冒泡排序，待排序列减少一个元素。\n\n冒泡排序在数列有序时最快，数列反序时最慢\n\n快速排序 O(nlog2n) 不稳定\n1）从数列中选取一个元素作为基准 pivot，一般选取第一个元素；\n2）重新排序，比基准小的数都在基准的前面，比基准大的数都在基准的后面。一趟排序完成后，这个基准元素就位于他的最终位置了；\n3）然后对基准前面子序列和后面子序列使用相同地方法进行递归排序，每趟排序都能确定一个元素的最终位置。\n\n\n\n③ 选择排序：不稳定\n简单选择 O(n^2)\n每次排序都从未排序列中选取最小元素放在相应位置，第 i 次排序即从 i - n 中选取最小元素与 A[i] 交换，一共循环 i - 1 次。\n每次排序后数列都是局部有序的。\n\n选择排序是最稳定的排序算法之一，因为无论什么数据进去都是O(n²)的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间。\n\n堆排序 O(nlog2n)\n1）构造堆：将无序序列构建成一个堆，根据升序降序需求决定转换成大根堆还是小根堆。（从最后一个非叶结点开始，调整该结点和他的孩子结点，然后依次从下往上进行调整，直到这个堆的父结点都大（小）于它们的孩子结点）；\n2）堆排序：将堆顶元素和最后一个叶子结点进行交换，将最大（小）元素沉到数组末端，然后重新构造堆。重复这个过程直到整个序列有序\n\n\n\n④ 归并排序：O(nlog2n) 稳定归并的含义是将两个或两个以上的有序表合并成一个新的有序表\n\n\n和选择排序一样，归并排序不受输入数据的影响，时间复杂度始终是 O(nlog2n)\n⑤ 基数排序：稳定基数排序可用于比较整数。原理是将整数按照位数切割成不同的数字，然后按每个位数分别进行比较（个位数和个位数比较，十位数和十位数比较）\n\n2. 各类排序算法对比\n\n3. 如何选择排序算法选择排序算法准则：\n一般而言，需要考虑的因素有以下四点：\n设待排序元素的个数为n.\n\n当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序序。\n\n当n较大，内存空间允许，且要求稳定性：归并排序\n\n当n较小，可采用直接插入或直接选择排序。\n直接插入排序：当元素分布有序，直接插入排序将大大减少比较次数和移动记录的次数。\n简单选择排序 ：元素分布有序，如果不要求稳定性，选择直接选择排序\n\n一般不使用或不直接使用传统的冒泡排序。\n\n基数排序：它是一种稳定的排序算法，但有一定的局限性\n\n关键字可分解。\n记录的关键字位数较少，如果密集更好\n如果是数字时，最好是无符号的\n\n\n\n4. 冒泡排序算法的改进设置一个 flag 位，用于标识这趟排序有没有发生交换，如果本趟遍历后没有发生交换，则说明元素已经有序了，则退出排序过程。\n5. 快排、堆排、归并排序对比\n时间复杂度：这三个排序算法平均时间复杂度都是O(nlog2n)，快排在数据有序的情况下最坏时间复杂度可达到O(n^2)\n\n空间复杂度：归并排序需要额外的数组开销，因为需要一个辅助数组对数据进行归并排序\n\n稳定性：快排和堆排是不稳定的，归并排序稳定\n\n\n6. 堆和二叉排序树的区别 堆的特点是双亲结点的关键字必然大于（小于）该孩子结点的关键字，但这两个孩子结点的关键字没有次序规定。\n中序遍历二叉树得到的结果为有序序列，而堆不一定能得到一个有序的序列。\n📚 References\n🎐 2020 王道考研 - 数据结构\n\n🥞 红黑树详解\n\n👚 在c++中关于堆和堆栈的区别\n\n👒 图解十大经典排序算法\n\n\n","categories":["计算机基础"],"tags":["数据结构指南"]},{"title":"和小达一起学计算机网络","url":"/2022/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","content":"Written By Eddie~~:question: 在浏览器地址栏输入一个 URL 后回车，背后发生了什么\n解析 URL\n浏览器封装 HTTP 请求报文\nDNS 域名解析获取 IP 地址\n建立 TCP 连接（长链接）\n浏览器发送请求\n负责传输的 IP 协议\n使用 ARP 协议凭借 MAC 地址通信\n服务器响应请求\n断开 TCP 连接\n浏览器渲染界面\n\n1.数据传输方式和交换方式1.1传输方式\n按数据传输的流向和时间关系分类\n\n单工通信：只能指定方向。广播\n半双工通信：双向，但不能同时。对讲机\n全双工通信：双向同时。电话\n\n\n按数据传输的顺序分类\n\n串行：易于实现。缺点是要解决收、发双方码组或字符的同步，需外加同步措施。\n并行：传输信道多，设备复杂，成本较高，故较少采用。\n\n\n按数据传输的同步方式划分\n\n同步：发送方和接收方的时钟要同步，同步符号(起始字符)＋数据块＋同步符号(结束字符） \n异步：在发送每一个字符代码的前面均加上一个 “起” 信号（起始位），后面均加一个 “止” 信号（终止位）。字符可以连续发送，也可以单独发送；不发送字符时，连续发送止信号。\n\n\n\n1.2交换方式​\t\t数据交换（Data Switching）是指在多个数据终端设备之间，为任意两个终端设备建立数据通信临时互连通路的过程。通俗来说交换是就通过某些交换中心将数据进行集中和传送，传输线路为各个用户共用，从而大大节省通信线路，降低系统费用。如果网络规模较大，则把交换设备连接在一起形成交换网络。\n\n电路交换\n用户之间要传输数据时，交换中心在用户之间建立一条暂时的数据电路。电路接通后，用户双方便可传输数据，并一直占用到传输完毕拆除电路为止。电路交换引入的时延很小，而且交换机对数据不加处理，是这几种交换方式中最快的一种。因而适合传输实时性强和批量大的数据。\n\n报文交换\n报文（message）是网络中交换与传输的数据单元，即站点一次性要发送的数据块。报文包含了将要发送的完整数据信息，其长短很不一致，长度不限且可变。传送过程采用存储转发的方式，中间方必须收到完整的报文并检查有无错误后才能进行转发。\n\n分组交换\n分组，就是将一个大的数据包（报文）分成一个个更小的数据包，这些一个个更小的数据报就称为分组。在每个分组的首部写入发送端和接收端的地址。分组交换同样采用存储转发，不同站点的数据分组可以交织在同一线路上传输，也就是说一个报文分成了若干个分组之后，这些分组不一定都沿着同一条路径进行转发，提高了线路的利用率。当然，由于将大的报文分割成了若干小分组，所以分组交换的速度比报文交换快得多\n三种交换方式比较\n\n\n\n\n电路交换\n报文交换\n分组交换\n\n\n\n建立连接\n需要\n不需要\n不需要\n\n\n数据交换单位\n比特流\n报文\n分组\n\n\n传输方式\n比特流直达\n存储转发\n存储转发\n\n\n每个分组沿着规定路径\n是\n\n不是\n\n\n分组按序到达\n是\n\n不是\n\n\n优点\n通信时延小；实时性强；适用范围广；控制简单；避免冲突\n无需建立连接；动态分配陆续；可靠性高；线路利用率高；可提供多目标服务\n加速传输；简化存储管理；减少出错几率和重发数据\n\n\n缺点\n建立连接时间长；信道利用率低；缺乏统一标准；灵活性差\n由于存储转发导致时延；对报文大小没有限制，需要较大的存储缓存空间\n由于存储转发导致时延；工作量大，可能出现分组丢失等情况\n\n\n\n\n数据交换方式的选择\n\n传送数据量大，且传送时间远大于呼叫时，选择电路交换。电路交换传输时延最小。\n当端到端的通路有很多段的链路组成时，采用分组交换传送数据较为合适\n从信道利用率上看，报文交换和分组交换优于电路交换，其中分组交换比报文交换的时延小，尤其适用于计算机之间的突发式的数据通信（比如我们用微信发消息）\n\n2.网络分层模型2.1 OSI协议模型和TCP&#x2F;IP协议模型\nOSI:Open System Interconnection,开放式系统互联。国际标准化组织(ISO)制定的 理论 模型。\n\n应用层、表示层、会话层、传输层、网络层、数据链路层、物理层\n\nTCP/IP:基于OSI建立的 实际 实现模型\n\n应用层、传输层、网络层、主机到网络层\n\n:question: 为什么要分层\n1.各层次之间是独立的。某一层并不需要知道它的下一层是如何实现的，而仅仅需要知道该层通过层间的接口所提供的服务。这样，整个问题的复杂程度就下降了。也就是说上一层的工作如何进行并不影响下一层的工作，这样我们在进行每一层的工作设计时只要保证接口不变可以随意调整层内的工作方式。\n2.灵活性好。当任何一层发生变化时，只要层间接口关系保持不变，则在这层以上或以下层均不受影响。当某一层出现技术革新或者某一层在工作中出现问题时不会连累到其它层的工作，排除问题时也只需要考虑这一层单独的问题即可。\n3.结构上可分割开。各层都可以采用最合适的技术来实现。技术的发展往往不对称的，层次化的划分有效避免了木桶效应，不会因为某一方面技术的不完善而影响整体的工作效率。\n4.易于实现和维护。这种结构使得实现和调试一个庞大又复杂的系统变得易于处理，因为整个的系统已经被分解为若干个相对独立的子系统。进行调试和维护时，可以对每一层进行单独的调试，避免了出现找不到、解决错问题的情况。\n5.能促进标准化工作。因为每一层的功能及其所提供的服务都已有了精确的说明。标准化的好处就是可以随意替换其中的某一层，对于使用和科研来说十分方便。\n2.2五层协议模型所谓通信协议就是通信双方都必须要遵守的通信规则。如果没有网络通信协议，计算机的数据将无法发送到网络上，更无法到达对方计算机，即使能够到达，对方也未必能读懂。有了通信协议，网络通信才能够发生。\n每一层都是在下一层的基础上，通过层间接口向上一层提供一定的服务，而把 “这种服务是如何实现的” 细节对上层加以屏蔽。\n\n对等层之间通信（不同开放系统中的相同层次之间的通信，对等层实体之间的信息交换）：OSI 标准为每一层的通信都严格定义了 协议数据单元 PDU的格式。 对等层之间的通信是目的，对等层实体的协作保证该层功能和服务的实现\n相邻层之间通信（相邻的上下层之间的通信，属于局部问题）：相邻层之间的通信是手段，保证对等层实体之间的通信得以实施\n\n\n\n3.应用层应用层最接近于用户，它的任务就是通过应用进程间的交互来完成特定网络应用。\n应用层协议定义的是应用进程间的通信和交互的规则。由于传输层传来的数据五花八门，有 html 格式的，有 mp4 格式等等，所以对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。我们把应用层交互的数据单元称为报文。\n3.1URI &amp; URLURI（Uniform Resource Identifier， 统一资源标志符）表示的是web上每一种可用的资源，如 HTML文档、图像、视频片段、程序等都由一个URI进行标识的。\nURL（Uniform Resource Locator，统一资源定位符）是URI概念的一种实现方式，一般格式为：protocol :// hostname[:port] / path / [;parameters][?query]#fragment\nURL的格式由三部分组成： \n①第一部分是协议(或称为服务方式)。\n②第二部分是存有该资源的主机IP地址(有时也包括端口号)。\n③第三部分是主机资源的具体地址，如目录和文件名等。\n3.2DNS 域名解析协议port：53（UDP+TCP）\n域名系统（DNS，Domain Name System），将域名和 IP 地址相互映射的一个分布式数据库 (这里的分布式数据库是指，每个站点只保留它自己的那部分数据)，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 地址。\n全世界域名的最高管理机构，是一个叫做 ICANN （Internet Corporation for Assigned Names and Numbers）的组织，总部在美国加州。ICANN 负责管理全世界域名系统的运作。\n\n域名具有层次结构，从上到下依次为：根域名（在有些场合，www.xxx.com 被写成 www.xxx.com.，即最后还会多出一个点，这个点就是根域名）、顶级域名、二级域名。\n\n\nDNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。\n域名解析方式：迭代查询，（递归查询效率低）\n\n\nDNS搜索顺序：浏览器的缓存（固定的 DNS 缓存时间），操作系统的缓存（hosts 文件，DNS 缓存服务DNSClient），本地域名服务器，迭代解析\n:question: DNS 分别在什么情况下使用 UDP 和 TCP\n1）若客户端事先知道 DNS 响应报文的长度会大于 512 字节，则应当直接使用 TCP 建立连接\n2）若客户端事先不知道 DNS 响应报文的长度，一般会先使用 UDP 协议发送 DNS 查询报文，若 DNS 服务器发现 DNS 响应报文的长度大于 512 字节，则多出来的部分会被 UDP 抛弃（截断 TrunCation），那么服务器会把这个部分被抛弃的 DNS 报文首部中的 TC 标志位置为 1，以通知客户端该 DNS 报文已经被截断。客户端收到之后会重新发起一次 TCP 请求，从而使得它将来能够从 DNS 服务器收到完整的响应报文。\n当然了，在域名解析的时候，一般返回的 DNS 响应报文都不会超过 512 字节，用 UDP 传输即可。事实上，很多 DNS 服务器进行配置的时候，也仅支持 UDP 查询包。\n在进行区域传输（辅助域名服务器与主域名服务器通信，并同步数据信息）的时候 DNS 会强制使用 TCP 协议。 \n3.3HTTP 协议HTTP：超文本传输协议（HyperText Transfer Protocol）是当今互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。HTTP 和 TCP&#x2F;IP 协议簇中的众多协议一样，用于客户端和服务器端之间的通信。\nHTTP&#x2F;0.9：HTTP 于 1990 年问世，功能简陋，仅支持 GET 请求方式，并且仅能访问 HTML 格式的资源。那时的 HTTP 并没有作为正式的标准被建立，因此被被称为 HTTP 0.9。\nHTTP&#x2F;1.0：1996 年 5 月 HTTP 正式作为标准被公布，版本号为 HTTP 1.0。在 0.9 版本上做了进步，增加了请求方式 POST 和 HEAD；不再局限于 0.9 版本的 HTML 格式，根据 Content-Type 可以支持多种数据格式…… 需要注意的是：1.0 版本的工作方式是短连接。虽说 HTTP&#x2F;1.0 是初期标准，但该协议标准至今仍然在被广泛使用。\nHTTP&#x2F;1.1：1997 年公布的 HTTP 1.1 是目前主流的 HTTP 协议版本。当年的 HTTP 协议的出现主要是为了解决文本传输的难题，现在的 HTTP 早已超出了 Web 这个框架的局限，被运用到了各种场景里。当然，1.1 版本的最大变化，就是引入了长连接以及流水线机制（管道机制）。\nHTTP 请求和响应① HTTP 请求报文\nHTTP 请求报文由 3 大部分组成：\n1）请求行（必须在 HTTP 请求报文的第一行）\n2）请求头（从第二行开始，到第一个空行结束。请求头和请求体之间存在一个空行）\n3）请求体（通常以键值对 &#123;key:value&#125;方式传递数据，非必须）\n\n\nHTTP 请求方法\n包括（HTTP 1.1）：GET（获取资源）、POST（传输数据）、PUT（传输文件，不带验证机制）、HEAD（获取报文首部）、DELETE（删除文件，不带验证机制）、OPTIONS（查询支持的方法）、CONNECT、TRACE。\nHTTP 请求头\n1）Referer：表示这个请求是从哪个 URI 跳过来的。\n2）Accept：告诉服务端，该请求所能支持的响应数据类型。（对应的，HTTP 响应报文中也有这样一个类似的字段 Content-Type，用于表示服务端发送的数据类型，如果 Accept 指定的类型和服务端返回的类型不一致，就会报错）\ntext/plain;q = 0.3 表示对于 text/plain 媒体类型的数据优先级&#x2F;权重为 0.3（q 的范围 0 ~ 1）。不指定权重的，默认为 1.0。\n\n3）Host：告知服务器请求的资源所处的互联网主机名和端口号。该字段是 HTTP&#x2F;1.1 规范中唯一一个必须被包含在请求头中的字段。\n4）Cookie：客户端的 Cookie 就是通过这个报文头属性传给服务端的\nCookie: JSESSIONID=15982C27F7507C7FDAF0F97161F634B5\n\n5）Connection：表示客户端与服务连接类型；Keep-Alive 表示持久连接，close 已关闭\n6）Content-Length：请求体的长度\n7）Accept-Language：浏览器通知服务器，浏览器支持的语言\n8）Range：对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围\n② HTTP响应报文\nHTTP的响应报文也由三部分组成：\n\n响应行（必须在 HTTP 响应报文的第一行）\n响应头（从第二行开始，到第一个空行结束。响应头和响应体之间存在一个空行）\n响应体\n\n\n\nHTTP 状态码HTTP 状态码负责表示客户端 HTTP 请求的的返回结果、标记服务器端处理是否正常、通知出现的错误等工作。\n状态码由 3 位数字组成，第一个数字定义了响应的类别：\n\n\n\n\n类别\n原因短语\n\n\n\n1xx\nInformational 信息性状态码\n接收的请求正在处理\n\n\n2xx\nSuccess 成功状态码\n请求正常处理完毕\n\n\n3xx\nRedirection 重定向状态码\n需要进行附加操作以完成请求\n\n\n4xx\nClient Error 客户端错误状态码\n服务器无法处理请求\n\n\n5xx\nServer Error 服务器错误状态码\n服务器处理请求出错\n\n\n🔶 2xx：请求正常处理完毕\n\n200 OK：客户端请求成功\n204 No Content：无内容。服务器成功处理，但未返回内容。一般用在只是客户端向服务器发送信息，而服务器不用向客户端返回什么信息的情况。不会刷新页面。\n206 Partial Content：服务器已经完成了部分 GET 请求（客户端进行了范围请求）。响应报文中包含 Content-Range 指定范围的实体内容\n\n🔶 3xx：需要进行附加操作以完成请求（重定向）\n\n301 Moved Permanently：永久重定向，表示请求的资源已经永久的搬到了其他位置。\n302 Found：临时重定向，表示请求的资源临时搬到了其他位置\n303 See Other：临时重定向，应使用GET定向获取请求资源。303功能与302一样，区别只是303明确客户端应该使用GET访问\n304 Not Modified：表示客户端发送附带条件的请求（GET方法请求报文中的IF…）时，条件不满足。返回304时，不包含任何响应主体。虽然304被划分在3XX，但和重定向一毛钱关系都没有\n307 Temporary Redirect：临时重定向，和302有着相同含义。POST不会变成GET\n\n🔶 4xx：客户端错误\n\n400 Bad Request：客户端请求有语法错误，服务器无法理解。\n401 Unauthorized：请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用。\n403 Forbidden：服务器收到请求，但是拒绝提供服务\n404 Not Found：请求资源不存在。比如，输入了错误的 URL\n415 Unsupported media type：不支持的媒体类型\n\n🔶 5xx：服务器端错误，服务器未能实现合法的请求。\n\n500 Internal Server Error：服务器发生不可预期的错误。\n503 Server Unavailable：服务器当前处于超负载或正在停机维护，暂时不能处理客户端的请求，一段时间后可能恢复正常\n\n\nHTTP 响应头\n响应头也是用键值对 k：v，用于补充响应的附加信息、服务器信息，以及对客户端的附加要求等。\n\nHTTP 连接管理① 短连接（非持久连接）\n客户端和服务器每进行一次 HTTP 会话，就建立一次连接，任务结束就中断连接，大大增加了通信量的开销。\n当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如JavaScript 文件、图像文件、CSS文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话。这种方式称为短连接（也称非持久连接）。\n② 长连接（持久连接）\n使用长连接的 HTTP 协议，会在响应头加入这行代码：Connection:keep-alive\n在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如 Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。\n③ 流水线（管线化）\n默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。\n持久连接使得多数请求以流水线（管线化 pipeline）方式发送成为可能，即在同一条持久连接上连续发出请求，而不用等待响应返回后再发送，这样就可以做到同时并行发送多个请求，而不需要一个接一个地等待响应了。\n无状态的 HTTP（Cookie和Session）HTTP 协议是无状态协议。也就是说他不对之前发生过的请求和响应的状态进行管理，即无法根据之前的状态进行本次的请求处理。\n由于不必保存状态，自然就减少了服务器的 CPU 及内存资源的消耗。\nCookie：一小段文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie（响应头中加上 Set-Cookie 字段）。客户端会把Cookie保存起来，后续请求服务器的时候，带上Cookie即可。\nSession：客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。每个用户访问服务器都会建立一个session，用户与服务器建立连接的同时，服务器会自动为其分配一个SessionId。\n:question: Session和Cookie的区别\n1、数据存储位置：cookie数据存放在客户的浏览器上，session数据放在服务器上。\n2、安全性：cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。\n3、服务器性能：session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。\n4、数据大小：单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。\n5、信息重要程度：可以考虑将登陆信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中。\nHTTP 断点续传所谓断点续传指的是下载传输文件可以中断，之后重新下载时可以接着中断的地方开始下载，而不必从头开始下载。断点续传需要客户端和服务端都支持。\n理很简单，其实就是 HTTP 请求头中的字段 Range 和响应头中的字段 Content-Range 的简单使用。\nHTTP 的缺点\n通信使用明文（不加密），内容可能被窃听\n不验证通信对方的身份，因此有可能遭遇伪装\n无法证明报文的完整性，所以有可能被篡改\n\n3.4HTTPS 协议HTTP 的不安全性体现在很多方面，即 HTTP 的缺点。\n\n内容被窃听：即使是加密过的通信内容，也会被窥视到，这点和未加密的通信是相同的，只能说经过加密后的内容，即便被攻击者窥视到，他也可能无法破解其中的含义罢了\n身份被伪装：服务器伪装，客户端伪装，访问权限，无意义请求\n报文被篡改：完整性不保证，中间人攻击（Main-in-the-Middle attack, MITM）\n\nHTTPS 协议并非应用层的一个新协议，只是 HTTP 通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。\n另外，SSL 是独立于 HTTP 协议的，所有运行在应用层的协议都可以配合 SSL 协议使用。可以说，SSL 协议是当今世界上应用最为广泛的网络安全技术。\n\n\n由于使用了加密通信， 相比于纯文本通信的 HTTP 来说，HTTPS 会消耗掉更多的 CPU 及内存资源，另外，开启 HTTPS 需要申请 SSL 证书，高额的证书申购费用会让很多网站开发者望而却步。\n加密密钥：就是钥匙，加密方有一把密钥，用来上锁，解密方也拥有一把密钥，用来解锁。而且加密方和解密方使用的密钥不一定是同一把。\n对称密钥加密和解密使用同一密钥的方式称为对称密钥加密，也称做共享密钥加密（Common Key crypto system）。\n以共享密钥加密时必须将密钥也发送给对方。显然，如果通信双方都各自持有同一个密钥，且没有别人知道，则两方的通信安全是可以被保证的（除非密钥被破解），而且效率很高。\n那么，最大的问题就是如何保证这个密钥的安全传输，不被外部攻击者知道。如果由服务器生成一个密钥并传输给浏览器，这个传输过程中密钥被攻击者劫持，那么之后攻击者就能用这把密钥解开双方传输的任何内容。因此&#x3D;&#x3D;一般在建立连接时用非对称加密传输共享秘钥，之后通信时再用对称加密方法，即混合加密&#x3D;&#x3D;。\n非对称的密钥加密和解密使用不同密钥。\n\n\nRSA非对称秘钥加密算法\n需要一个算法，正向计算容易，但逆向反推难——模运算符合这个特性：计算模简单，但反推指数难，只能穷举（当除数很大时不可取）\n\n\n使用模运算即可实现加密解密过程：\n\n\n合并两式得：\n\n\n如何选取e和d成为关键。此时要用到欧拉定理：\n\n\n这里的 $\\varphi(n)$ 表示：小于等于n的正整数中，有多少与n互质的数。将欧拉公式进行变换并对比上式可得下式，其中k为任意正整数\n\n\n可以通过选取k，n，e，计算得到d：\n\n\n计算 $\\varphi(n)$ 的一般方法为质因数分解，但大数质因数分解很难。但如果n是一个质数p，则有：\n\n\n运用到d的计算中：\n\n由于这里的p和q是自己选取，别人不知道，所以无法通过大数n的质因数分解得到p和q，因而无法计算出 $\\varphi(n)$和 d\n数字签名遗憾的是，混合加密的方式仍然还是有漏洞的。攻击者（中间人）的确无法得到浏览器生成的对称密钥 X，但攻击者完全不需要拿到服务器私有的私钥就能劫持信息！\n中间人只需截获服务器发布的公钥，篡改成自己的公钥发给客户端，客户端就会用中间人的公钥加密共享秘钥，中间人再用自己的私钥解密即可获得共享秘钥。根本原因是：浏览器客户端无法确认自己收到的公钥是不是真正的网站服务器的。\n\n\n❓ 如何证明浏览器客户端收到的公钥一定是该网站服务器的公钥\n服务器在发布公钥和文件时，会同时用私钥将文件哈希值运算得到数字签名，放到网站上。客户端将文件的数字签名和公钥运算得到的文件哈希值与文件本身哈希值对比即可确定文件没有被篡改，并且签名来自于私钥拥有者。\n\n但私钥拥有者不一定等于服务器，因为中间人也可生成一套公钥私钥，对文件签名。客户端验证时使用伪公钥和伪签名对文件进行验证，依旧可以通过。\n数字证书为确保客户端验证时使用的是目的服务器的公钥和数字签名，需要使用公信机构： 数字证书认证机构（Certificate Authority, CA），即客户端和浏览器都信赖的第三方机构。\n网站服务器在使用 HTTPS 前，需要向 CA 申请颁发数字证书，数字证书里有证书持有者、证书持有者的公钥，前两者的数字签名等信息。服务器把数字证书明文传输给浏览器客户端，然后浏览器从证书里取出服务器的公钥就可以了。\n\n由于计算机里默认安装了根证书，其中包括CA机构的公钥，因此数字证书具有不可为造性。\n\n\n\n\n3.5DHCP 协议DHCP 协议（Dynamic Host Configuration Protocol，动态主机配置协议）实现自动配置 IP 地址、统一管理 IP 地址分配\n4.传输层在从计算机 A 传数据给计算表 B 的时候，还得指定一个端口（Port），以供特定的应用程序来接受处理。即 IP 地址 + 端口号就可以唯一确定某个主机上的某个应用进程\n&#x3D;&#x3D;网络层的功能&#x3D;&#x3D;：建立主机到主机的通信，而传输层的功能就是建立端口到端口的通信（也可以说是进程到进程之间的通信）\n传输层最常见的两大协议是 TCP 协议和 UDP 协议，其中 TCP 协议与 UDP 最大的不同就是 TCP 提供可靠的传输，而 UDP 提供的是不可靠传输。\n4.1TCP 传输控制协议TCP（Transmission Control Protocol） 提供面向连接，面向字节流的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。\nTCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、流量控制、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。\n4.2TCP 报文首部\n\n首部固定部分各字段意义如下：\n\n1 - 源端口和目的端口：各占 2 个字节，分别写入源端口和目的端口。IP 地址 + 端口号就可以确定一个进程地址\n\n2 - 序号&#x2F;序列号（Sequense Number，SN）：在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号。该字段表示本报文段所发送的数据的第一个字节的序号。初始序号称为 Init Sequense Number, ISN（序号&#x2F;序列号这个字段很重要，大家留个印象，下文会详细讲解）\n例如，一报文段的序号是 101，共有 100 字节的数据。这就表明：本报文段的数据的第一个字节的序号是 101，最后一个字节的序号是 200。显然，下一个报文段的数据序号应当从 201 开始，即下一个报文段的序号字段值应为 201。\n\n3 - 确认号 ack：期望收到对方下一个报文段的第一个数据字节的序号。若确认号为 N，则表明：到序号 N-1 为止的所有数据都已正确收到。\n\n4 - 数据偏移（首部长度）：它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。这个字段实际上是指出TCP报文段的首部长度。\n\n5 - 保留：占 6 位，应置为 0，保留为今后使用。\n\n\n⭐ 大家看上图，保留位的右边还有 6 个控制位（重要），这是TCP 用来说明该报文段性质的：\n\n紧急位 URG：当 URG &#x3D; 1 时，表明此报文段中有紧急数据，是高优先级的数据，应尽快发送，不用在缓存中排队。该控制位需配合紧急指针使用（紧急指针指出本报文段中紧急数据的字节数）\n举个例子：我们需要取消一个已经发送了很长程序的运行，因此用户从键盘发出中断命令。如果不使用紧急数据，那么这个指令将存储在接收 TCP 的缓存末尾，只有在所有的数据被处理完毕后这两个字符才被交付接收方的应用进程，这样做就无法实现立即中断。\n\n确认 ACK：仅当 ACK &#x3D; 1 时确认号字段才有效，当 ACK &#x3D; 0 时确认号无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置为 1。\n\n推送 PSH：当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，TCP 就可以使用推送（push）操作。这时，发送方 TCP 把 PSH 置为 1，并立即创建一个报文段发送出去。接收方 TCP 收到 PSH &#x3D; 1 的报文段，就尽快地交付接收应用进程。而不用等到整个缓存都填满了后再向上交付。\n\n复位 RST：当 RST &#x3D; 1 时，表明 TCP 连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。\n\n同步 SYN：SYN &#x3D; 1 表示这是一个连接请求或连接接受报文。\n当 SYN &#x3D; 1 而 ACK &#x3D; 0 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使 SYN &#x3D; 1 且 ACK &#x3D; 1。\n\n终止 FIN：用来释放一个连接。当 FIN &#x3D; 1时，表明此报文段的发送发的数据已发送完毕，并要求释放连接。\n\n\n4.3TCP 三次握手建立连接进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的 初始化序列号(Init Sequense Number,  ISN) 为后面的可靠性传输做准备。\n\n\n刚开始客户端处于 Closed 的状态，而服务端处于 Listen 状态：\n\nCLOSED ：没有任何连接状态\nLISTEN ：侦听来自远方 TCP 端口的连接请求\n\n1）第一次握手：客户端向服务端发送一个 SYN 报文（SYN &#x3D; 1），并指明客户端的初始化序列号 ISN(x)，即图中的 seq &#x3D; x，表示本报文段所发送的数据的第一个字节的序号。此时客户端处于 SYN_Send 状态。\n\nSYN-SENT ：在发送连接请求后等待匹配的连接请求\n\n2）第二次握手：服务器收到客户端的 SYN 报文之后，会发送 SYN 报文作为应答（SYN &#x3D; 1），并且指定自己的初始化序列号 ISN(y)，即图中的 seq &#x3D; y。同时会把客户端的 ISN + 1 作为确认号 ack 的值，表示已经收到了客户端发来的的 SYN 报文，希望收到的下一个数据的第一个字节的序号是 x + 1，此时服务器处于 SYN_REVD 的状态。\n\nSYN-RECEIVED：在收到和发送一个连接请求后等待对连接请求的确认\n\n3）第三次握手：客户端收到服务器端响应的 SYN 报文之后，会发送一个 ACK 报文，也是一样把服务器的 ISN + 1 作为 ack 的值，表示已经收到了服务端发来的的 SYN 报文，希望收到的下一个数据的第一个字节的序号是 y + 1，并指明此时客户端的序列号 seq &#x3D; x + 1（初始为 seq &#x3D; x，所以第二个报文段要 +1），此时客户端处于 Establised 状态。\n服务器收到 ACK 报文之后，也处于 Establised 状态，至此，双方建立起了 TCP 连接。\n\nESTABLISHED：代表一个打开的连接，数据可以传送给用户\n\n:question: 为什么要三次握手\n三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。\n只有经过三次握手才能确认双发的收发功能都正常，缺一不可：\n\n第一次握手（客户端发送 SYN 报文给服务器，服务器接收该报文）：\n客户端什么都不能确认；\n服务器确认了对方发送正常，自己接收正常；\n\n第二次握手（服务器响应 SYN 报文给客户端，客户端接收该报文）：\n客户端确认了：自己发送、接收正常，对方发送、接收正常；\n服务器确认了：对方发送正常，自己接收正常；\n\n第三次握手（客户端发送 ACK 报文给服务器）：\n客户端确认了：自己发送、接收正常，对方发送、接收正常；\n服务器确认了：自己发送、接收正常，对方发送、接收正常\n\n\n半连接队列\n服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把这种状态下的请求连接放在一个队列里，我们把这种队列称之为半连接队列。\n当然还有一个全连接队列，完成三次握手后建立起的连接就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。\nSYN 洪泛攻击（DDOS攻击的一种）\nSYN 攻击就是 Client 在短时间内伪造大量不存在的 IP 地址，并向 Server 不断地发送 SYN 包，Server 则回复确认包，并等待 Client 确认，由于源地址不存在，因此 Server 需要不断重发直至超时，这些伪造的 SYN 包将长时间占用半连接队列，导致正常的 SYN 请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。 \n:question: ISN (Initial Sequence Number) 是固定的吗\nISN 随时间而变化，因此每个连接都将具有不同的 ISN。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。\n:question: 三次握手过程中可以携带数据吗\n第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手绝对不可以携带数据\n假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，然后疯狂重复发 SYN 报文的话（因为攻击者根本就不用管服务器的接收、发送能力是否正常，它就是要攻击你），这会让服务器花费很多时间、内存空间来接收这些报文。\n⭐ 简单的记忆就是，请求连接&#x2F;接收 即 SYN = 1 的时候不能携带数据\n而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以当然能正常发送&#x2F;携带数据了。\n:question: 如果第三次握手丢失了，客户端服务端会如何处理\n服务器发送完 SYN-ACK 包，如果未收到客户端响应的确认包，也即第三次握手丢失。那么服务器就会进行首次重传，若等待一段时间仍未收到客户确认包，就进行第二次重传。如果重传次数超过系统规定的最大重传次数，则系统将该连接信息从半连接队列中删除。\n注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…\n4.4TCP 四次挥手释放连接客户端或服务端均可主动发起挥手动作。\n\n\n刚开始双方都处于ESTABLISHED 状态，假设是客户端先发起关闭请求。四次挥手的过程如下：\n1）第一次挥手：客户端发送一个 FIN 报文（请求连接终止：FIN &#x3D; 1），报文中会指定一个序列号 seq &#x3D; u。并停止再发送数据，主动关闭 TCP 连接。此时客户端处于 FIN_WAIT1 状态，等待服务端的确认。\n\nFIN-WAIT-1 - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；\n\n2）第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。\n\nCLOSE-WAIT - 等待从本地用户发来的连接中断请求；\n\n此时的 TCP 处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待 2）状态，等待服务端发出的连接释放报文段。\n\nFIN-WAIT-2 - 从远程TCP等待连接中断请求；\n\n3）第三次挥手：如果服务端也想断开连接了（没有要向客户端发出的数据），和客户端的第一次挥手一样，发送 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态，等待客户端的确认。\n\nLAST-ACK - 等待原来发向远程TCP的连接中断请求的确认；\n\n4）第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答（ack &#x3D; w+1），且把服务端的序列值 +1 作为自己 ACK 报文的序号值（seq&#x3D;u+1），此时客户端处于 TIME_WAIT （时间等待）状态。\n\nTIME-WAIT - 等待足够的时间以确保远程TCP接收到连接中断请求的确认；\n\n🚨 注意 ！！！这个时候由服务端到客户端的 TCP 连接并未释放掉，需要经过时间等待计时器设置的时间 2MSL（一个报文的来回时间） 后才会进入 CLOSED 状态（这样做的目的是确保服务端收到自己的 ACK 报文。如果服务端在规定时间内没有收到客户端发来的 ACK 报文的话，服务端会重新发送 FIN 报文给客户端，客户端再次收到 FIN 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文给服务端）。服务端收到 ACK 报文之后，就关闭连接了，处于 CLOSED 状态。\n:question: 为什么要四次挥手\n由于 TCP 的半关闭（half-close）特性，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。\n任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。\n通俗的来说，两次握手就可以释放一端到另一端的 TCP 连接，完全释放连接一共需要四次握手。\n举个例子：A 和 B 打电话，通话即将结束后，A 说 “我没啥要说的了”，B 回答 “我知道了”，于是 A 向 B 的连接释放了。但是 B 可能还会有要说的话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，于是 B 向 A 的连接释放了，这样整个通话就结束了。\n4.5TCP 可靠传输\n可靠传输就是保证接收方收到的字节流和发送方发出的字节流是完全一样的\n\n网络层是没有可靠传输机制的，尽自己最大的努力进行交付。而传输层使用 TCP 实现可靠传输，TCP 保证可靠传输的机制有如下几种：\n\n校验和（Checksum）\n序列号和确认应答机制\n重传机制\n流量控制（滑动窗口协议）\n拥塞控制\n\n重传机制① 超时重传\n超时重传就是 TCP 发送方在发送报文的时候，设定一个定时器，如果在规定的时间内没有收到接收方发来的 ACK 确认报文，发送方就会重传这个已发送的报文段。\n对于发送方没有正确接收到接收方发来的 ACK 确认报文的情况，有以下两种（也就是在这两种情况下会发生超时重传）：\n\n第一种情况：报文段丢失\n第二种情况：接收方的 ACK 确认报文丢失\n\n超时重传时间我们一般用 RTO（Retransmission Timeout） 来表示，其值应略大于RTT。如果超时重传的数据又超时了，TCP 的策略是重传的 RTO 加倍。\n② 快速重传（Fast Retransmit）\n快速重传机制不以时间为驱动，而是以数据驱动重传：每当接收方收到比期望序号大的失序报文段到达时，就向发送方发送一个冗余 ACK，指明下一个期待字节的序号。当发送方接收到多个冗余ACk时，就进行重传。\n\n\n滑动窗口协议① 累积确认与窗口\n只有收到了上一个报文段的确认应答后才能发送下一个报文段的这种模式效率非常低下。每个报文段的往返时间越长，网络的吞吐量就越低，通信的效率就越低。\n为此，TCP 引入了 窗口 的概念。窗口大小就是指无需等待确认应答，可以继续发送数据的最大值。\n⭐ 窗口的实现实际上是操作系统开辟的一个缓冲区：发送方在等待确认应答报文返回之前，必须在缓冲区中保留已发送的数据。如果在规定时间间隔内收到确认应答报文，就可以将数据从缓冲区中清除。\n② 发送方的滑动窗口\n下图就是发送方缓存的数据，根据处理的情况分成四个部分：\n\n已发送并收到 ACK 确认应答的数据\n已发送但未收到 ACK 确认应答的数据\n未发送但总大小在接收方处理范围内的数据\n未发送但总大小超过接收方处理范围的数据\n\n\n\n\n\n当发送方把数据全部发送出去后，可用窗口的大小就为 0 了，表明可用窗口耗尽，在没收到 ACK 确认之前无法继续发送数据：\n\n\n\n\n当收到之前发送的数据 32~36 字节的 ACK 确认应答后，如果发送窗口的大小没有变化，则滑动窗口往右边移动 5 个字节，因为有 5 个字节的数据被确认应答，接下来 52~56 字节又变成了可用窗口，那么后续也就可以发送 52~56 这 5 个字节的数据了：\n\n\n③ 接收方的滑动窗口\n接收方的滑动窗口可分为三个部分：\n\n已成功接收并确认的数据\n未收到数据但可以接收的数据\n未收到数据且不可以接收的数据（超出接收方窗口大小）\n\n\n\n同样的，接收方的滑动窗口在成功接收并确认的数据后，窗口右移。\n流量控制重传的过程中，若主机 B 的接收缓冲区情况仍未好转，则会将大量的时间浪费在重传数据上，降低传送数据的效率。\n所以引入了流量控制机制，主机 B 通过告诉主机 A 自己接收缓冲区的大小，来使主机 A 控制发送的数据量。总结来说：所谓流量控制就是控制发送方发送速率，保证接收方来得及接收。\nTCP首部中窗口字段的含义是指自己接收缓冲区的剩余大小。\n接收端会在发送 ACK 确认应答报文时，将自己的即时窗口大小（接收窗口 rwnd）填入，并跟随 ACK 报文一起发送出去。而发送方根据接收到的 ACK 报文中的窗口大小的值改变自己的发送速度。如果接收到窗口大小的值为 0，那么发送方将停止发送数据。并定期的向接收端发送窗口探测数据段，提醒接收端把窗口大小告诉发送端。\n拥塞控制在某段时间，对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能变差。如果网络出现拥塞，TCP 报文可能会大量丢失，此时就会大量触发重传机制，从而导致网络拥塞程度更高，严重影响传输。\n:question: 流量控制和拥塞控制的区别\n\n流量控制是为了让接收方能来得及接收\n拥塞控制是为了降低整个网络的拥塞程度，防止过多的数据注入到网络中。\n\n为了调节发送方所要发送数据的量，定义了「拥塞窗口 cwnd」的概念。拥塞窗口是发送方维护的一个状态变量，它会根据网络的拥塞程度动态变化：\n\n只要网络中出现了拥塞，cwnd 就会减少\n若网络中没有出现拥塞，cwnd 就会增大\n\n在引入拥塞窗口概念之前，发送窗口大小和接收窗口大小基本是相等的关系（取决于接收窗口大小）。引入拥塞窗口后，发送窗口的大小就等于拥塞窗口和接收窗口的最小值。\nTCP 的拥塞控制采用了四种算法：\n① 慢开始\nTCP 在刚建立连接完成后，如果立即把大量数据字节注入到网络，那么很有可能引起网络阻塞。好的方法是先探测一下，一点一点的提高发送数据包的数量，即由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍（指数增长）。\n\n\n当然不能一直执行慢启动，这里会设置一个慢启动轮限 ssthresh 状态变量：\n\n当 cwnd &lt; ssthresh 时，继续使用慢启动算法\n当 cwnd &gt;= ssthresh 时，开始使用「拥塞避免算法」\n\n② 拥塞避免\n拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 cwnd 加 1。\n\n\n🚨 注意，无论是慢开始阶段还是拥塞避免，只要出现了网络拥塞（触发超时重传机制），慢开始轮限 sshresh 和 拥塞窗口大小 cwnd 的值会发生变化（乘法减小）：\n\nssthresh 设为 cwnd/2\ncwnd 重置为 1\n\n由于拥塞窗口大小重置为 1 了，所以就会重新开始执行慢启动算法。\n\n\n③ 快重传和快恢复\n快速重传和快速恢复算法一般同时使用。\n快重传：接收方收到三个重复的 ACK 确认的时候，就会执行快重传算法（触发快速重传机制和超时重传机制的情况不同，TCP 认为触发快速重传的情况并不严重，因为大部分没丢，只丢了一小部分），快速重传做的事情有：\n\ncwnd = cwnd/2 \nssthresh = cwnd\n进入快速恢复阶段\n\n快恢复：快速恢复的思想是“数据包守恒”原则，即同一个时刻在网络中的数据包数量是恒定的，只有当“老”数据包离开了网络后，才能向网络中发送一 个“新”的数据包，如果发送方收到一个重复的 ACK，那么根据 TCP 的 ACK 机制就表明有一个数据包离开了网络，于是 cwnd 加 1。如果能够严格按照该原则那么网络中很少会发生拥塞，事实上拥塞控制的目的也就在修正违反该原则的地方。\n具体来说快速恢复的主要步骤是：\n\n把 cwnd 设置为 ssthresh 的值加 3，然后重传丢失的报文段，加 3 的原因是因为收到 3 个重复的 ACK，表明有 3 个“老”的数据包离开了网络。\n再收到重复的 ACK 时，拥塞窗口 cwnd 增加 1\n当收到新的数据包的 ACK 时，把 cwnd 设置为第一步中的 ssthresh 的值。原因是因为该 ACK 确认了新的数据，说明从重复 ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态。\n\n\n\n\n\n4.UDP 用户数据报协议UDP（User Datagram Protocol） 在传送数据之前不需要先建立连接，远程主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比 QQ 语音、 QQ 视频 、直播等等\nUDP首部8个字节\nUDP面向报文，不做任何的拆分与合并，默认只有一个 UDP 报文，这么做就会导致一个问题，UDP 报文被限制在 512 字节以内\n5.网络层在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。\n&#x3D;&#x3D;网络层的任务&#x3D;&#x3D;：就是选择合适的网间路由和交换结点， 确保数据及时传送。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。\n5.1IP 协议IP 协议用于屏蔽下层物理网络的差异，为上层提供统一的 IP 数据报。IP 数据报中含有发&#x2F;收方的 IP 地址。 \n\n\nIP 协议提供&#x3D;&#x3D;无连接的、不可靠的、尽力的&#x3D;&#x3D;数据报投递服务\n\n无连接\n发送端可于任何时候自由发送数据，而接收端永远不知道自己会在何时从哪里接收到数据。每个数据报独立处理和传输， 一台主机发出的数据报序列，可能取不同的路径， 甚至其中的一部分数据报会在传输过程中丢失； \n\n不可靠\nIP 协议本身不保证数据报投递的结果。 在传输的过程中，数据报可能会丢失、重复、延迟和乱序等， IP协议不对内容作任何检测，也不将这些结果通知收发双方； 数据报的丢失，通过路由器发 ICMP报文 告知； 必要时，由高层实体（如TCP）负责差错恢复动作。 \n\n尽力 \n执行数据报的分段和封装，以适应具体的传输网络， 由最终结点的IP模块进行合段处理\n不同物理网络对传输的帧 &#x2F;分组的体积有不同的规定； 当数据报长度 &gt; MTU（Maximun Transfer Unit，最大传输单元）时，需对数据报分段 。\n\n\nIP地址IPV4 地址长 32 比特 &#x2F; 4 字节，而 IPV6 地址占 128 比特 &#x2F; 16 字节\n\n\n\n\n\n网络类别\n第一个可用的网络号\n最后一个可用的网络号\n每个网络中的最大主机数\n\n\n\nA\n1\n126\n$2^{24} - 2$\n\n\nB\n128.1\n191.255\n$2^{16} - 2$\n\n\nC\n192.0.1\n223.255.255\n$2^{8} - 2$\n\n\n当主机号全为 0：该网络的地址\n当主机号全为 1：该网络的广播地址\n127.0.0.1：环回地址，数据包就不会流向网络\n:question: 为什么要分离网络号和主机号？\n因为两台计算机要通讯，首先要判断是否处于同一个广播域内，即网络地址（网络号）是否相同：\n\n如果网络地址相同，表明接受方在本网络上（本地网络主机），那么可以把数据包直接发送到目标主机，无需转发给其他的网络\n网络号不相同的主机称之为远程网络主机，远程网络中的主机要相互通信必须通过本地网关（Gateway）来传递转发数据\n\nIP 单播&#x2F;广播&#x2F;多播\nIP 广播：用网络的广播地址，如192.168.0.255，一般进行本地广播，路由器上设置为不转发广播包。\nIP 单播：只有一个发送方和一个接收方。单播是可以穿透路由器的。\nIP 多播（组播）：将包发送给特定组内的所有主机（可以穿透路由器），即一个发送方，特定的多个接收方\n\n子网划分将传统的两级 IP 地址（网络号 + 主机号）转换成粒度更小的三级 IP 地址（网络号 + 子网号 + 主机号），也就是将主机地址划分为子网号和子网内的主机号。划分子网后，对外仍表现为一个网络。\n\n\n子网掩码\n将某个 IP 地址划分成网络地址和主机地址两部分\n以网络地址 192.168.1.0（C 类二级 IP 地址），子网掩码 255.255.255.192 为例，我们可以写成：192.168.1.0/26，表示网络号 + 子网号共 26 位。\n子网掩码 255.255.255.192 中共有 26 个 1，即代表网络号 + 子网号共 26 位，而 C 类地址的网络号（加上分类号）共 24 位，由此可知，需要从 8 位主机号中借用 2 位作为子网号。由于子网网络地址被划分成 2 位，那么子网地址就有 $2^2 &#x3D; 4$ 个，分别是 00、01、10、11，具体划分如下图：\n\n\n划分后的 4 个子网如下表格：\n\n\n拯救枯竭的 IPV4 地址\n无分类 IP 地址 CIDR\n放弃 IP 地址的分类，采用任意长度分割 IP 地址的网络号和主机号。CIDR 的表现形式为 a.b.c.d/x，其中 /x 表示前 x 位属于网络号（网络前缀），网络号的长度可以根据需要变化。\n\nNAT 地址转换\n用于在本地网络中使用私有地址，在连接互联网时使转而使用全局 IP 地址的技术。虽然说 NAT 实际上是为正在面临地址枯竭的 IPV4 而开发的技术，不过在 IPV6 中，为了提高网络安全也在使用 NAT。\n\nIPV6\n\n\n路由控制为了将数据包发送给目标主机，所有主机和路由器都维护着一张路由控制表（Routing Table），该表记录着如下两个字段：\n\nIP 地址\n如果想要到达这个 IP 地址，在当前路由器，数据包的下一步应该是发送到哪个路由器\n\n在发送 IP 数据报时，首先要确定 IP 数据报首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将 IP 数据报转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择相同位数最多的网络地址，也就是最长匹配。\n默认路由 Default Route 就是指路由表中任何一个地址都能与之匹配的记录。如果一张路由表中包含所有的网络和子网信息，将会造成无端的浪费。这时，默认路由就是一个不错的选择。默认路由一般标记为 0.0.0.0/0 或 default\n\n路由协议\n路由控制表的形成有两种方式：\n\n一种是管理员手动设置，也叫静态路由控制\n另一种是路由器与其他路由器相互交换信息时自动刷新，也叫动态路由控制\n\n为了让动态路由即时刷新路由控制表，在网络上互联的路由器之间必须设置好某种协议，保证正常读取路由控制信息。这种协议就称为路由协议。\n人们根据路由控制的范围将路由协议大致分为两类：\n\n外部网关协议 EGP（包含 RIP、OSPF 等协议）\n内部网关协议 IGP（包含 BGP 等协议）\n\n没有 EGP 就不可能有世界上各个不同组织机构之间的通信，没有 IGP 就不可能有机构内部的通信。\n5.2ARP 地址解析协议ARP（Address Resolution Protocol ）协议就可以实现由 IP 地址得到 MAC 地址。\n\n\n每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。\n如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组（该分组携带自己的 IP 地址 和 MAC 地址 以及 目标主机的 IP 地址），主机 B 收到该请求后会发送 ARP 响应分组 给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。\n&#x3D;&#x3D;ARP请求包为广播，ARP响应包为单播&#x3D;&#x3D;\n\n\n💡 对应的，RARP 协议可以实现由 MAC地址转化为 IP 地址\n5.3ICMP 网际控制报文协议网际控制报文协议（Internet Control Message Protocol，ICMP）\n&#x3D;&#x3D;作用&#x3D;&#x3D;：解决ip协议不可靠的特点，确认网络是否能够正常工作，并且即使诊断出现异常时的原因所在\nICMP 报文是由路由器发出来的。\n\n\nICMP 报文类型\n\n查询报文\n用于主机进行诊断的查询消息，&#x3D;&#x3D;ping&#x3D;&#x3D;\n\n回送应答（Echo Reply），类型：0\n回送请求（Echo Request），类型：8\n\n\n差错报文\n用于通知主机出错的原因，&#x3D;&#x3D;traceroute &#x2F; tracert&#x3D;&#x3D;\n\n目标不可达（Destination Unreachable），类型：3。路由器无法将 IP 数据报发送给目标地址。分为网络不可达、主机不可达、协议不可达、端口不可达、需要进行分片但设置了不分片位。\n原点抑制（Source Quench），类型：4。\n重定向或改变路由（Redirect），类型：5。如果路由器发现发送端主机使用了某个不是最优的路径发送数据，他就会返回一个 ICMP 重定向消息（ICMP Redirect Message）给这个主机，并且，在这个消息中包含了最优的路由信息和源数据。\n超时（Time Exceeded），类型：11。TTL减到0就发送，为了在路由控制遇到问题发生循环状况时，避免 IP 包无休止地在网络上被转发。\n\n\n\n6.数据链路层物理层只是简单的把计算机连接起来并在上面传输比特流，它还是存在着很多问题的：\n\n1）物理连接是有差错和不可靠的\n2）物理设备之间可能存在传输速度不匹配问题\n\n也就是说仅仅靠物理层是无法保证数据传输的正确性的。\n&#x3D;&#x3D;数据链路层的主要作用&#x3D;&#x3D;：加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造成为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。在物理层提供服务的基础上，数据链路层还肩负着为网络层提供服务的责任，其最基本的服务是将来自网络层的 IP 数据报封装成帧，可靠的传输到相邻结点的目标网络层。\n6.1封装成帧为什么需要封装成帧：前需要制定一套规则来进行 0、1 的传送，让计算能够读懂这些序列。\n封装成帧就是：发送端的数据链路层接收到上层网络层传过来的 IP 数据报后，在其前后部分添加首部（&#x3D;&#x3D;包含MAC地址&#x3D;&#x3D;）、尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。\n\n\n6.2MAC 地址MAC 地址就是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。计算机之间的数据传送，就是通过 MAC 地址来唯一寻找、传送的。\n一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。\n:question: 如果没有 MAC 地址，仅仅只有 IP 地址可以吗？\n从理论上来说，如果 IP 地址够用，交换机也支持根据 IP 地址进行转发，我们只需要在 IP 数据报中加一个 “下一跳 IP 地址” 的字段就行了，MAC 地址确实并不是必要的。但从宏观来说，IP 地址只管上层建筑即路线规划，底层具体走的逻辑交给 MAC 地址来做，这样其实才符合 TCP&#x2F;IP 协议体系这种分层的理念！所以，这种设计并非多次一举，而是为了符合最根本的设计理念。\n","categories":["计算机基础"],"tags":["计算机网络"]}]